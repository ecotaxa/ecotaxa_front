/*! For license information please see src_modules_js-upload_js.js.LICENSE.txt */
"use strict";(self.webpackChunk=self.webpackChunk||[]).push([["src_modules_js-upload_js"],{"./src/modules/js-upload.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   JsUpload: () => (/* binding */ JsUpload)\n/* harmony export */ });\n/* harmony import */ var dompurify__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! dompurify */ \"./node_modules/dompurify/dist/purify.js\");\n/* harmony import */ var dompurify__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(dompurify__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var fflate__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! fflate */ \"./node_modules/fflate/esm/browser.js\");\n/* harmony import */ var _modules_form_submit_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../modules/form-submit.js */ \"./src/modules/form-submit.js\");\n/* harmony import */ var _modules_utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../modules/utils.js */ \"./src/modules/utils.js\");\n/* harmony import */ var _modules_modules_config_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../modules/modules-config.js */ \"./src/modules/modules-config.js\");\n\n\n\n\n\n\nconst already_compressed = new Set([\n  'zip', 'gz', 'png', 'jpg', 'jpeg', 'pdf', 'doc', 'docx', 'ppt', 'pptx',\n  'xls', 'xlsx', 'heic', 'heif', '7z', 'bz2', 'rar', 'gif', 'webp', 'webm',\n  'mp4', 'mov', 'mp3', 'aifc'\n]);\nconst accept = '.tsv,.png,.jpg, .jpeg,.zip,.gz,.7z,.bz2';\nconst largefile = 50000;\nconst chunksize = 2000000;\nlet instance = null;\nconst defdir = \"ecotaxa_import\";\n\nclass JsUpload {\n  zipstream;\n  zipsize = 0;\n  pathname;\n  zipname;\n  numfiles = 0;\n  sizefiles = 0;\n  zipparts = [];\n  counter = 0;\n  counterdisplay = null;\n  ziptrigger = null;\n  displaylist = null;\n  timer = 0;\n  targetdir = '';\n  sent = false;\n  dropzone;\n  root = '.';\n  constructor(container, callback = null, options = {}) {\n    if (instance) return instance;\n    container = (container instanceof HTMLElement) ? container : document.querySelector(container);\n    if (!container) return;\n    this.container = container;\n    this.callback = callback;\n    const defaultOptions = {\n      level: 0,\n      //  url: \"http://localhost:5001/gui/files/upload\",\n      url: \"https://localhost:8000/my_files/\",\n      filefield: 'file',\n      selector: {\n        makezip: '.makezip',\n        droptarget: '.droptarget',\n        trigger: '.trigger',\n        uploadfile: 'uploadfile',\n        formu: 'formupload',\n        stepper: 'stepper',\n        stepitem: 'stepper-item',\n        filetoload: 'file_to_load',\n        progress: \"progress-upload\"\n      },\n      display: {\n        dropzone: 'dropzone',\n        counter: 'counter',\n        size: 'sizetozip',\n        counterzipped: 'counterzipped',\n        sizezipped: 'sizezipped',\n        dirlist: 'dirlist',\n        boxtitle: 'boxtitle',\n        timer: 'timer'\n      },\n      css: {\n        enabled: 'enabled'\n      }\n    };\n\n    this.options = Object.assign(defaultOptions, options);\n\n    this.init(container);\n    instance = this;\n    return instance;\n  }\n\n  init(container) {\n    // create a filepicker depends on browser\n    this.dropzone = document.createElement('div');\n    this.dropzone.id = this.options.display.dropzone;\n    this.dropzone.innerHTML = `<input type=\"file\" class=\"hidden\"  name=\"${this.options.selector.uploadfile}\" id=\"${this.options.selector.uploadfile}\">\n            <div class=\"${this.options.selector.droptarget.slice(1)}\">\n            <div id=\"${this.options.display.boxtitle}\"><span class=\"${this.options.selector.trigger.slice(1)}\">${this.container.dataset.textbrowse}</span>  ${this.container.dataset.textdrop}</div>\n          </div><div class=\"grid grid-cols-2 grid-gap-4\"><div>Files</div><div>Compressesd</div></div><div class=\"grid grid-cols-2 grid-gap-4\"><div id=\"${this.options.display.counter}\"></div><div id=\"${this.options.display.counterzipped}\"></div>\n          <div class=\"grid grid-cols-2 grid-gap-4\" id=\"${this.options.display.size}\"></div><div id=\"${this.options.display.sizezipped}\"></div><div id=\"${this.options.display.timer}\"></div>\n          <div id=\"${this.options.selector.makezip.slice(1)}\" class=\"button ${this.options.selector.makezip.slice(1)} ${_modules_modules_config_js__WEBPACK_IMPORTED_MODULE_3__.css.hide} \"><div id=\"${this.options.selector.progress}\"></div>${container.dataset.ended}</div>`;\n    container.append(this.dropzone);\n    this.counterdisplay = document.getElementById(this.options.display.counter);\n    this.counterzippeddisplay = document.getElementById(this.options.display.counterzipped);\n    this.sizedisplay = document.getElementById(this.options.display.size);\n    this.sizezippeddisplay = document.getElementById(this.options.display.sizezipped);\n    this.ziptrigger = container.querySelector(this.options.selector.makezip);\n    this.displaylist = document.getElementById(this.options.display.dirlist);\n    const droptarget = this.container.querySelector(this.options.selector.droptarget);\n    droptarget.addEventListener('dragover', (e) => {\n      this.handleDragOver(e);\n    });\n    droptarget.addEventListener('drop', async (e) => {\n      this.handleDrop(e);\n\n    });\n    container.querySelector(this.options.selector.trigger).addEventListener('click', (e) => {\n      let datatransfer = e;\n      this.openDirDialog(accept, (e) => {\n        console.log('edrop', datatransfer)\n      });\n    });\n  }\n  attachDropzone(target) {\n    console.log('attch', target);\n    this.targetdir = (target.parentElement.dataset.name) ? target.parentElement.dataset.name : '';\n    console.log('targetdir', this.targetdir)\n    this.dropzone.classList.add(this.options.css.enabled);\n    console.log('att', this.dropzone);\n    target.append(this.dropzone);\n  }\n  detachDropzone() {\n    this.targetdir = null;\n    this.container.classList.remove(this.options.css.enabled);\n\n  }\n  openDirDialog(accept, callback) {\n    const input = document.createElement(\"input\");\n    input.type = \"file\";\n    input.directory = true;\n    input.multiple = true;\n    input.webkitdirectory = true;\n    input.allowdirs = true;\n    input.accept = accept;\n    input.addEventListener(\"change\", callback);\n    input.dispatchEvent(new MouseEvent(\"click\"));\n  }\n  handleDragOver(e) {\n    e.preventDefault();\n    e.dataTransfer.dropEffect = \"move\";\n  }\n\n  async handleDrop(e) {\n    let dataTransfer;\n    if (e.dataTransfer) {\n      e.preventDefault();\n      dataTransfer = e.dataTransfer;\n    } else dataTransfer = e;\n    this.timer = new Date();\n    console.log('dataTransfer ', dataTransfer.items)\n\n    const items = [...((dataTransfer.items) ? dataTransfer.items : dataTransfer.files)];\n    if (items.length) {\n      this.enableDropzone(false);\n      this.zipname = '_upload.zip';\n      this.zip = new fflate__WEBPACK_IMPORTED_MODULE_4__.Zip();\n\n      this.zipReadableStream = await this.fflToStream();\n      const on_error = (err) => {\n        console.log('err_read_dir', err);\n      }\n      const on_complete = async () => {\n        this.timer = (new Date() - this.timer) / 1000;\n        console.log('item-------------------------------------' + parseInt(this.timer / 60) + ' --- ' + (\n          this.timer - (parseInt(this.timer / 60) * 60)), this.zip);\n        this.enableDropzone();\n        this.zip.end();\n        this.ziptrigger.classList.remove(_modules_modules_config_js__WEBPACK_IMPORTED_MODULE_3__.css.hide);\n        this.ziptrigger.addEventListener('click', async (e) => {\n          this.ziptrigger.disabled = true;\n          console.log('upload click')\n          this.enableDropzone(false, true);\n\n          return await this.sendZip();\n        });\n      }\n      //this.pathname.pop();\n      for (let i = 0; i < items.length; i++) {\n        let item = items[i].webkitGetAsEntry();\n        if (item.isDirectory === true) {\n          this.zipname = item.name + this.zipname;\n          await this.readDirectory(item, this.root, on_complete);\n        } else if (item.isFile === true) {\n          // put directly in input file\n\n        }\n\n      }\n    }\n  }\n  stopOnError(err) {\n    console.log('err', err);\n  }\n\n  enableDropzone(enable = true, destroy = false) {\n    if (destroy) this.dropzone.classList.add(_modules_modules_config_js__WEBPACK_IMPORTED_MODULE_3__.css.hide);\n    if (enable) this.dropzone.classList.add(this.options.css.enabled);\n    else this.dropzone.classList.remove(this.options.css.enabled);\n\n  }\n  async supportsRequestStreams() {\n    let duplexAccessed = false;\n    const hasContentType = new Request(this.options.url, {\n      body: new ReadableStream(),\n      method: 'POST',\n      get duplex() {\n        duplexAccessed = true;\n        return 'half';\n      },\n    }).headers.has('Content-Type');\n\n    return duplexAccessed && !hasContentType;\n  }\n\n  fileType(data) {\n    const mime_type = (signature) => {\n      switch (signature) {\n        case '89504E47':\n          return 'image/png';\n        case '47494638':\n          return 'image/gif';\n        case '25504446':\n          return 'application/pdf';\n        case 'FFD8FFDB':\n        case 'FFD8FFE0':\n        case 'FFD8FFE1':\n          return 'image/jpeg';\n        case '504B0304':\n          return 'application/zip';\n        case 'EFBBBF22':\n          return 'text/tsv'; //'text/tab-separated-values';\n        default:\n          console.log('unknownsign', signature)\n          return 'unknown';\n      }\n    }\n    const uint = new Uint8Array(data);\n    let bytes = []\n    for (let i = 0; i < 4; i++) {\n      bytes.push(uint[i].toString(16))\n    }\n    data = bytes.join('').toUpperCase();\n    return {\n      input: uint,\n      mimetype: mime_type(data)\n    };\n  }\n\n  async fflToStream() {\n    const fflateStream = this.zip;\n    const transform = new TransformStream();\n    const writer = transform.writable.getWriter();\n    return new TransformStream({\n      start(controller) {\n        fflateStream.ondata = (error, data, final) => {\n          if (error) {\n            console.log('error', error);\n            return false;\n          } else {\n            controller.enqueue(data);\n            if (final) {\n              console.log('final', final);\n              //  controller.terminate();\n            }\n\n          }\n        }\n      },\n      flush(controller) {\n        console.log('terminate ffstrem')\n        controller.terminate();\n      }\n    })\n\n  }\n  //\n\n\n  async readDirectory(dir, parent, oncomplete, onerror = null) {\n    console.log('read', dir.name)\n    const self = this;\n    let errored = false;\n    let direntries = [],\n      handlers = [],\n      files = [];\n\n    const on_error = onerror ? onerror : (err) => {\n      console.log('on_error', err)\n      if (!errored) {\n        errored = true;\n\n      }\n    };\n\n    const readfile = async function(file, zippedstream) {\n      const reader = file.stream().getReader();\n      while (true) {\n        const {\n          done,\n          value\n        } = await reader.read();\n        if (done) {\n          await zippedstream.push(new Uint8Array(0), true);\n          return done;\n        }\n        await zippedstream.push(value);\n      }\n\n    };\n\n    //\n    const process_file = async function() {\n      const entry = files.shift();\n      const filepath = entry.fullPath.slice(1);\n      //  console.log('fileadd=' + self.numfiles, entry.name)\n      const ext = filepath.slice(filepath.lastIndexOf('.') + 1);\n      const zip_file = async (filetozip) => {\n        const iscompressed = already_compressed.has(ext);\n        const zippedstream = iscompressed ?\n          new fflate__WEBPACK_IMPORTED_MODULE_4__.ZipPassThrough(filepath) :\n          filetozip.size > largefile ?\n          new fflate__WEBPACK_IMPORTED_MODULE_4__.AsyncZipDeflate(filepath, {\n            level: 9\n          }) : new fflate__WEBPACK_IMPORTED_MODULE_4__.ZipDeflate(filepath, {\n            level: 6\n          });\n        //  console.log('zipstr', zippedstream)\n        zippedstream.ondata = async function(err, dat, final) {\n          if (err) console.log('err add chunk to zipfile' + dat, err);\n          else if (final) {\n\n            if (files.length) {\n              console.log('files', files.length);\n              await process_file();\n            } else {\n              console.log('lastfile', dir.name);\n              await on_complete();\n            }\n          }\n        };\n        await self.zip.add(zippedstream);\n        return await readfile(filetozip, zippedstream);\n      };\n      self.numfiles++;\n      if (self.numfiles === 1) {\n        fetch(self.options.url.replace('my_files', 'stream_my_files'), {\n          mode: 'cors',\n          method: \"POST\",\n          credentials: \"include\",\n          headers: {\n            \"Content-Type\": \"application/zip\",\n          },\n          body: self.zipReadableStream.readable,\n          duplex: 'half',\n        }).then((response) => {\n          console.log('response', response);\n        });\n      }\n      await entry.file(zip_file);\n\n    };\n    //\n\n    const process_entries = function() {\n      const entry = direntries.shift();\n      if (entry.isFile) {\n        //console.log('fileleft ***---' + dir.name, entry.name);\n        self.counter++;\n        self.counterdisplay.textContent = self.counter;\n        //const f = entry.getAsFile();\n        files.push(entry);\n        //  await process_file(entry, entry.fullPath.slice(1));\n        self.counter--;\n        self.counterdisplay.textContent = self.counter;\n      } else if (entry.isDirectory) {\n        console.log('entry is dir', entry)\n        handlers.push(entry);\n      }\n      if (direntries.length) process_entries();\n\n    }\n    const on_complete = async function() {\n      for (const handler of handlers) {\n        console.log(handler);\n        await self.readDirectory(handler, dir, async function() {\n          console.log('idir', handler.name);\n          if (files.length) await process_file();\n        });\n      }\n\n    }\n    const reader = dir.createReader();\n    const on_read = async function(ents) {\n      if (ents.length && !errored) {\n        direntries = [...direntries, ...ents];\n        await reader.readEntries(on_read, on_error);\n      } else if (!errored) {\n        process_entries();\n        console.log('theend------------------- ' + dir.name, direntries.length)\n        await on_complete();\n\n\n      } else {\n        console.log('treat error readdir');\n      }\n    }\n\n    await reader.readEntries(on_read, on_error);\n\n    console.log('enddir' + dir.name, direntries.length)\n\n  }\n\n  compressionLevel(name) {\n    if (!name) {\n\n      return -1;\n    }\n    let ext = name.split('.');\n    ext = (ext.length > 1) ? ext[ext.length - 1] : ext[0];\n    return (already_compressed.find(ex => (ex === ext))) ? 2 : this.options.level;\n  }\n\n  async sendZip() {\n    //  const filestream = new WritableStream();\n    //  const writer = filestream.getWriter();\n    //\n\n    //\n\n\n    /*  fetch(this.options.url.replace('my_files', 'stream_my_files'), {\n        mode: 'cors',\n        method: \"POST\",\n        credentials: \"include\",\n        headers: {\n          \"Content-Type\": \"text/plain\",\n        },\n        body: this.zipReadableStream,\n        duplex: 'half',\n      });*/\n    /**********************************/\n    /*webtransport\n      const transport = new WebTransport(this.options.url);\n\n      // Optionally, set up functions to respond to\n      // the connection closing:\n      transport.closed.then(() => {\n        console.log(`The HTTP/3 connection to ${url} closed gracefully.`);\n      }).catch((error) => {\n        console.error(`The HTTP/3 connection to ${url} closed due to ${error}.`);\n      });\n\n      // Once .ready fulfills, the connection can be used.\n      await transport.ready;\n      const streamsend = await transport.createUnidirectionalStream();\n      const writer = streamsend.writable.getWriter();\n      const streamtest = new ReadableStream({\n        async start(controller) {\n          await wait(1000);\n          controller.enqueue('This ');\n          await wait(1000);\n          controller.enqueue('is ');\n          await wait(1000);\n          controller.enqueue('a ');\n          await wait(1000);\n          controller.enqueue('slow ');\n          await wait(1000);\n          controller.enqueue('request.');\n          controller.close();\n        },\n      }).pipeTo(writer);\n\n    */\n\n\n\n\n  }\n\n\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87O0FBRVA7Ozs7O0FBS0E7OztBQUdBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vc3JjL21vZHVsZXMvanMtdXBsb2FkLmpzPzdjNDgiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IERPTVB1cmlmeSBmcm9tICdkb21wdXJpZnknO1xuaW1wb3J0IHtcbiAgWmlwLFxuICBBc3luY1ppcERlZmxhdGUsXG4gIFppcFBhc3NUaHJvdWdoLFxuICBaaXBEZWZsYXRlLFxufSBmcm9tICdmZmxhdGUnO1xuaW1wb3J0IHtcbiAgRm9ybVN1Ym1pdFxufSBmcm9tICcuLi9tb2R1bGVzL2Zvcm0tc3VibWl0LmpzJztcblxuaW1wb3J0IHtcbiAgZG93bmxvYWRfYmxvYixcbiAgZmV0Y2hTZXR0aW5ncyxcbn0gZnJvbSAnLi4vbW9kdWxlcy91dGlscy5qcyc7XG5pbXBvcnQge1xuICBjc3Ncbn0gZnJvbSAnLi4vbW9kdWxlcy9tb2R1bGVzLWNvbmZpZy5qcyc7XG5jb25zdCBhbHJlYWR5X2NvbXByZXNzZWQgPSBuZXcgU2V0KFtcbiAgJ3ppcCcsICdneicsICdwbmcnLCAnanBnJywgJ2pwZWcnLCAncGRmJywgJ2RvYycsICdkb2N4JywgJ3BwdCcsICdwcHR4JyxcbiAgJ3hscycsICd4bHN4JywgJ2hlaWMnLCAnaGVpZicsICc3eicsICdiejInLCAncmFyJywgJ2dpZicsICd3ZWJwJywgJ3dlYm0nLFxuICAnbXA0JywgJ21vdicsICdtcDMnLCAnYWlmYydcbl0pO1xuY29uc3QgYWNjZXB0ID0gJy50c3YsLnBuZywuanBnLCAuanBlZywuemlwLC5neiwuN3osLmJ6Mic7XG5jb25zdCBsYXJnZWZpbGUgPSA1MDAwMDtcbmNvbnN0IGNodW5rc2l6ZSA9IDIwMDAwMDA7XG5sZXQgaW5zdGFuY2UgPSBudWxsO1xuY29uc3QgZGVmZGlyID0gXCJlY290YXhhX2ltcG9ydFwiO1xuXG5leHBvcnQgY2xhc3MgSnNVcGxvYWQge1xuICB6aXBzdHJlYW07XG4gIHppcHNpemUgPSAwO1xuICBwYXRobmFtZTtcbiAgemlwbmFtZTtcbiAgbnVtZmlsZXMgPSAwO1xuICBzaXplZmlsZXMgPSAwO1xuICB6aXBwYXJ0cyA9IFtdO1xuICBjb3VudGVyID0gMDtcbiAgY291bnRlcmRpc3BsYXkgPSBudWxsO1xuICB6aXB0cmlnZ2VyID0gbnVsbDtcbiAgZGlzcGxheWxpc3QgPSBudWxsO1xuICB0aW1lciA9IDA7XG4gIHRhcmdldGRpciA9ICcnO1xuICBzZW50ID0gZmFsc2U7XG4gIGRyb3B6b25lO1xuICByb290ID0gJy4nO1xuICBjb25zdHJ1Y3Rvcihjb250YWluZXIsIGNhbGxiYWNrID0gbnVsbCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgaWYgKGluc3RhbmNlKSByZXR1cm4gaW5zdGFuY2U7XG4gICAgY29udGFpbmVyID0gKGNvbnRhaW5lciBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KSA/IGNvbnRhaW5lciA6IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoY29udGFpbmVyKTtcbiAgICBpZiAoIWNvbnRhaW5lcikgcmV0dXJuO1xuICAgIHRoaXMuY29udGFpbmVyID0gY29udGFpbmVyO1xuICAgIHRoaXMuY2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICBjb25zdCBkZWZhdWx0T3B0aW9ucyA9IHtcbiAgICAgIGxldmVsOiAwLFxuICAgICAgLy8gIHVybDogXCJodHRwOi8vbG9jYWxob3N0OjUwMDEvZ3VpL2ZpbGVzL3VwbG9hZFwiLFxuICAgICAgdXJsOiBcImh0dHBzOi8vbG9jYWxob3N0OjgwMDAvbXlfZmlsZXMvXCIsXG4gICAgICBmaWxlZmllbGQ6ICdmaWxlJyxcbiAgICAgIHNlbGVjdG9yOiB7XG4gICAgICAgIG1ha2V6aXA6ICcubWFrZXppcCcsXG4gICAgICAgIGRyb3B0YXJnZXQ6ICcuZHJvcHRhcmdldCcsXG4gICAgICAgIHRyaWdnZXI6ICcudHJpZ2dlcicsXG4gICAgICAgIHVwbG9hZGZpbGU6ICd1cGxvYWRmaWxlJyxcbiAgICAgICAgZm9ybXU6ICdmb3JtdXBsb2FkJyxcbiAgICAgICAgc3RlcHBlcjogJ3N0ZXBwZXInLFxuICAgICAgICBzdGVwaXRlbTogJ3N0ZXBwZXItaXRlbScsXG4gICAgICAgIGZpbGV0b2xvYWQ6ICdmaWxlX3RvX2xvYWQnLFxuICAgICAgICBwcm9ncmVzczogXCJwcm9ncmVzcy11cGxvYWRcIlxuICAgICAgfSxcbiAgICAgIGRpc3BsYXk6IHtcbiAgICAgICAgZHJvcHpvbmU6ICdkcm9wem9uZScsXG4gICAgICAgIGNvdW50ZXI6ICdjb3VudGVyJyxcbiAgICAgICAgc2l6ZTogJ3NpemV0b3ppcCcsXG4gICAgICAgIGNvdW50ZXJ6aXBwZWQ6ICdjb3VudGVyemlwcGVkJyxcbiAgICAgICAgc2l6ZXppcHBlZDogJ3NpemV6aXBwZWQnLFxuICAgICAgICBkaXJsaXN0OiAnZGlybGlzdCcsXG4gICAgICAgIGJveHRpdGxlOiAnYm94dGl0bGUnLFxuICAgICAgICB0aW1lcjogJ3RpbWVyJ1xuICAgICAgfSxcbiAgICAgIGNzczoge1xuICAgICAgICBlbmFibGVkOiAnZW5hYmxlZCdcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdGhpcy5vcHRpb25zID0gT2JqZWN0LmFzc2lnbihkZWZhdWx0T3B0aW9ucywgb3B0aW9ucyk7XG5cbiAgICB0aGlzLmluaXQoY29udGFpbmVyKTtcbiAgICBpbnN0YW5jZSA9IHRoaXM7XG4gICAgcmV0dXJuIGluc3RhbmNlO1xuICB9XG5cbiAgaW5pdChjb250YWluZXIpIHtcbiAgICAvLyBjcmVhdGUgYSBmaWxlcGlja2VyIGRlcGVuZHMgb24gYnJvd3NlclxuICAgIHRoaXMuZHJvcHpvbmUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICB0aGlzLmRyb3B6b25lLmlkID0gdGhpcy5vcHRpb25zLmRpc3BsYXkuZHJvcHpvbmU7XG4gICAgdGhpcy5kcm9wem9uZS5pbm5lckhUTUwgPSBgPGlucHV0IHR5cGU9XCJmaWxlXCIgY2xhc3M9XCJoaWRkZW5cIiAgbmFtZT1cIiR7dGhpcy5vcHRpb25zLnNlbGVjdG9yLnVwbG9hZGZpbGV9XCIgaWQ9XCIke3RoaXMub3B0aW9ucy5zZWxlY3Rvci51cGxvYWRmaWxlfVwiPlxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cIiR7dGhpcy5vcHRpb25zLnNlbGVjdG9yLmRyb3B0YXJnZXQuc2xpY2UoMSl9XCI+XG4gICAgICAgICAgICA8ZGl2IGlkPVwiJHt0aGlzLm9wdGlvbnMuZGlzcGxheS5ib3h0aXRsZX1cIj48c3BhbiBjbGFzcz1cIiR7dGhpcy5vcHRpb25zLnNlbGVjdG9yLnRyaWdnZXIuc2xpY2UoMSl9XCI+JHt0aGlzLmNvbnRhaW5lci5kYXRhc2V0LnRleHRicm93c2V9PC9zcGFuPiAgJHt0aGlzLmNvbnRhaW5lci5kYXRhc2V0LnRleHRkcm9wfTwvZGl2PlxuICAgICAgICAgIDwvZGl2PjxkaXYgY2xhc3M9XCJncmlkIGdyaWQtY29scy0yIGdyaWQtZ2FwLTRcIj48ZGl2PkZpbGVzPC9kaXY+PGRpdj5Db21wcmVzc2VzZDwvZGl2PjwvZGl2PjxkaXYgY2xhc3M9XCJncmlkIGdyaWQtY29scy0yIGdyaWQtZ2FwLTRcIj48ZGl2IGlkPVwiJHt0aGlzLm9wdGlvbnMuZGlzcGxheS5jb3VudGVyfVwiPjwvZGl2PjxkaXYgaWQ9XCIke3RoaXMub3B0aW9ucy5kaXNwbGF5LmNvdW50ZXJ6aXBwZWR9XCI+PC9kaXY+XG4gICAgICAgICAgPGRpdiBjbGFzcz1cImdyaWQgZ3JpZC1jb2xzLTIgZ3JpZC1nYXAtNFwiIGlkPVwiJHt0aGlzLm9wdGlvbnMuZGlzcGxheS5zaXplfVwiPjwvZGl2PjxkaXYgaWQ9XCIke3RoaXMub3B0aW9ucy5kaXNwbGF5LnNpemV6aXBwZWR9XCI+PC9kaXY+PGRpdiBpZD1cIiR7dGhpcy5vcHRpb25zLmRpc3BsYXkudGltZXJ9XCI+PC9kaXY+XG4gICAgICAgICAgPGRpdiBpZD1cIiR7dGhpcy5vcHRpb25zLnNlbGVjdG9yLm1ha2V6aXAuc2xpY2UoMSl9XCIgY2xhc3M9XCJidXR0b24gJHt0aGlzLm9wdGlvbnMuc2VsZWN0b3IubWFrZXppcC5zbGljZSgxKX0gJHtjc3MuaGlkZX0gXCI+PGRpdiBpZD1cIiR7dGhpcy5vcHRpb25zLnNlbGVjdG9yLnByb2dyZXNzfVwiPjwvZGl2PiR7Y29udGFpbmVyLmRhdGFzZXQuZW5kZWR9PC9kaXY+YDtcbiAgICBjb250YWluZXIuYXBwZW5kKHRoaXMuZHJvcHpvbmUpO1xuICAgIHRoaXMuY291bnRlcmRpc3BsYXkgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCh0aGlzLm9wdGlvbnMuZGlzcGxheS5jb3VudGVyKTtcbiAgICB0aGlzLmNvdW50ZXJ6aXBwZWRkaXNwbGF5ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQodGhpcy5vcHRpb25zLmRpc3BsYXkuY291bnRlcnppcHBlZCk7XG4gICAgdGhpcy5zaXplZGlzcGxheSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHRoaXMub3B0aW9ucy5kaXNwbGF5LnNpemUpO1xuICAgIHRoaXMuc2l6ZXppcHBlZGRpc3BsYXkgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCh0aGlzLm9wdGlvbnMuZGlzcGxheS5zaXplemlwcGVkKTtcbiAgICB0aGlzLnppcHRyaWdnZXIgPSBjb250YWluZXIucXVlcnlTZWxlY3Rvcih0aGlzLm9wdGlvbnMuc2VsZWN0b3IubWFrZXppcCk7XG4gICAgdGhpcy5kaXNwbGF5bGlzdCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHRoaXMub3B0aW9ucy5kaXNwbGF5LmRpcmxpc3QpO1xuICAgIGNvbnN0IGRyb3B0YXJnZXQgPSB0aGlzLmNvbnRhaW5lci5xdWVyeVNlbGVjdG9yKHRoaXMub3B0aW9ucy5zZWxlY3Rvci5kcm9wdGFyZ2V0KTtcbiAgICBkcm9wdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoJ2RyYWdvdmVyJywgKGUpID0+IHtcbiAgICAgIHRoaXMuaGFuZGxlRHJhZ092ZXIoZSk7XG4gICAgfSk7XG4gICAgZHJvcHRhcmdldC5hZGRFdmVudExpc3RlbmVyKCdkcm9wJywgYXN5bmMgKGUpID0+IHtcbiAgICAgIHRoaXMuaGFuZGxlRHJvcChlKTtcblxuICAgIH0pO1xuICAgIGNvbnRhaW5lci5xdWVyeVNlbGVjdG9yKHRoaXMub3B0aW9ucy5zZWxlY3Rvci50cmlnZ2VyKS5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIChlKSA9PiB7XG4gICAgICBsZXQgZGF0YXRyYW5zZmVyID0gZTtcbiAgICAgIHRoaXMub3BlbkRpckRpYWxvZyhhY2NlcHQsIChlKSA9PiB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdlZHJvcCcsIGRhdGF0cmFuc2ZlcilcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG4gIGF0dGFjaERyb3B6b25lKHRhcmdldCkge1xuICAgIGNvbnNvbGUubG9nKCdhdHRjaCcsIHRhcmdldCk7XG4gICAgdGhpcy50YXJnZXRkaXIgPSAodGFyZ2V0LnBhcmVudEVsZW1lbnQuZGF0YXNldC5uYW1lKSA/IHRhcmdldC5wYXJlbnRFbGVtZW50LmRhdGFzZXQubmFtZSA6ICcnO1xuICAgIGNvbnNvbGUubG9nKCd0YXJnZXRkaXInLCB0aGlzLnRhcmdldGRpcilcbiAgICB0aGlzLmRyb3B6b25lLmNsYXNzTGlzdC5hZGQodGhpcy5vcHRpb25zLmNzcy5lbmFibGVkKTtcbiAgICBjb25zb2xlLmxvZygnYXR0JywgdGhpcy5kcm9wem9uZSk7XG4gICAgdGFyZ2V0LmFwcGVuZCh0aGlzLmRyb3B6b25lKTtcbiAgfVxuICBkZXRhY2hEcm9wem9uZSgpIHtcbiAgICB0aGlzLnRhcmdldGRpciA9IG51bGw7XG4gICAgdGhpcy5jb250YWluZXIuY2xhc3NMaXN0LnJlbW92ZSh0aGlzLm9wdGlvbnMuY3NzLmVuYWJsZWQpO1xuXG4gIH1cbiAgb3BlbkRpckRpYWxvZyhhY2NlcHQsIGNhbGxiYWNrKSB7XG4gICAgY29uc3QgaW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaW5wdXRcIik7XG4gICAgaW5wdXQudHlwZSA9IFwiZmlsZVwiO1xuICAgIGlucHV0LmRpcmVjdG9yeSA9IHRydWU7XG4gICAgaW5wdXQubXVsdGlwbGUgPSB0cnVlO1xuICAgIGlucHV0LndlYmtpdGRpcmVjdG9yeSA9IHRydWU7XG4gICAgaW5wdXQuYWxsb3dkaXJzID0gdHJ1ZTtcbiAgICBpbnB1dC5hY2NlcHQgPSBhY2NlcHQ7XG4gICAgaW5wdXQuYWRkRXZlbnRMaXN0ZW5lcihcImNoYW5nZVwiLCBjYWxsYmFjayk7XG4gICAgaW5wdXQuZGlzcGF0Y2hFdmVudChuZXcgTW91c2VFdmVudChcImNsaWNrXCIpKTtcbiAgfVxuICBoYW5kbGVEcmFnT3ZlcihlKSB7XG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIGUuZGF0YVRyYW5zZmVyLmRyb3BFZmZlY3QgPSBcIm1vdmVcIjtcbiAgfVxuXG4gIGFzeW5jIGhhbmRsZURyb3AoZSkge1xuICAgIGxldCBkYXRhVHJhbnNmZXI7XG4gICAgaWYgKGUuZGF0YVRyYW5zZmVyKSB7XG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICBkYXRhVHJhbnNmZXIgPSBlLmRhdGFUcmFuc2ZlcjtcbiAgICB9IGVsc2UgZGF0YVRyYW5zZmVyID0gZTtcbiAgICB0aGlzLnRpbWVyID0gbmV3IERhdGUoKTtcbiAgICBjb25zb2xlLmxvZygnZGF0YVRyYW5zZmVyICcsIGRhdGFUcmFuc2Zlci5pdGVtcylcblxuICAgIGNvbnN0IGl0ZW1zID0gWy4uLigoZGF0YVRyYW5zZmVyLml0ZW1zKSA/IGRhdGFUcmFuc2Zlci5pdGVtcyA6IGRhdGFUcmFuc2Zlci5maWxlcyldO1xuICAgIGlmIChpdGVtcy5sZW5ndGgpIHtcbiAgICAgIHRoaXMuZW5hYmxlRHJvcHpvbmUoZmFsc2UpO1xuICAgICAgdGhpcy56aXBuYW1lID0gJ191cGxvYWQuemlwJztcbiAgICAgIHRoaXMuemlwID0gbmV3IFppcCgpO1xuXG4gICAgICB0aGlzLnppcFJlYWRhYmxlU3RyZWFtID0gYXdhaXQgdGhpcy5mZmxUb1N0cmVhbSgpO1xuICAgICAgY29uc3Qgb25fZXJyb3IgPSAoZXJyKSA9PiB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdlcnJfcmVhZF9kaXInLCBlcnIpO1xuICAgICAgfVxuICAgICAgY29uc3Qgb25fY29tcGxldGUgPSBhc3luYyAoKSA9PiB7XG4gICAgICAgIHRoaXMudGltZXIgPSAobmV3IERhdGUoKSAtIHRoaXMudGltZXIpIC8gMTAwMDtcbiAgICAgICAgY29uc29sZS5sb2coJ2l0ZW0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tJyArIHBhcnNlSW50KHRoaXMudGltZXIgLyA2MCkgKyAnIC0tLSAnICsgKFxuICAgICAgICAgIHRoaXMudGltZXIgLSAocGFyc2VJbnQodGhpcy50aW1lciAvIDYwKSAqIDYwKSksIHRoaXMuemlwKTtcbiAgICAgICAgdGhpcy5lbmFibGVEcm9wem9uZSgpO1xuICAgICAgICB0aGlzLnppcC5lbmQoKTtcbiAgICAgICAgdGhpcy56aXB0cmlnZ2VyLmNsYXNzTGlzdC5yZW1vdmUoY3NzLmhpZGUpO1xuICAgICAgICB0aGlzLnppcHRyaWdnZXIuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBhc3luYyAoZSkgPT4ge1xuICAgICAgICAgIHRoaXMuemlwdHJpZ2dlci5kaXNhYmxlZCA9IHRydWU7XG4gICAgICAgICAgY29uc29sZS5sb2coJ3VwbG9hZCBjbGljaycpXG4gICAgICAgICAgdGhpcy5lbmFibGVEcm9wem9uZShmYWxzZSwgdHJ1ZSk7XG5cbiAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5zZW5kWmlwKCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgLy90aGlzLnBhdGhuYW1lLnBvcCgpO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpdGVtcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBsZXQgaXRlbSA9IGl0ZW1zW2ldLndlYmtpdEdldEFzRW50cnkoKTtcbiAgICAgICAgaWYgKGl0ZW0uaXNEaXJlY3RvcnkgPT09IHRydWUpIHtcbiAgICAgICAgICB0aGlzLnppcG5hbWUgPSBpdGVtLm5hbWUgKyB0aGlzLnppcG5hbWU7XG4gICAgICAgICAgYXdhaXQgdGhpcy5yZWFkRGlyZWN0b3J5KGl0ZW0sIHRoaXMucm9vdCwgb25fY29tcGxldGUpO1xuICAgICAgICB9IGVsc2UgaWYgKGl0ZW0uaXNGaWxlID09PSB0cnVlKSB7XG4gICAgICAgICAgLy8gcHV0IGRpcmVjdGx5IGluIGlucHV0IGZpbGVcblxuICAgICAgICB9XG5cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgc3RvcE9uRXJyb3IoZXJyKSB7XG4gICAgY29uc29sZS5sb2coJ2VycicsIGVycik7XG4gIH1cblxuICBlbmFibGVEcm9wem9uZShlbmFibGUgPSB0cnVlLCBkZXN0cm95ID0gZmFsc2UpIHtcbiAgICBpZiAoZGVzdHJveSkgdGhpcy5kcm9wem9uZS5jbGFzc0xpc3QuYWRkKGNzcy5oaWRlKTtcbiAgICBpZiAoZW5hYmxlKSB0aGlzLmRyb3B6b25lLmNsYXNzTGlzdC5hZGQodGhpcy5vcHRpb25zLmNzcy5lbmFibGVkKTtcbiAgICBlbHNlIHRoaXMuZHJvcHpvbmUuY2xhc3NMaXN0LnJlbW92ZSh0aGlzLm9wdGlvbnMuY3NzLmVuYWJsZWQpO1xuXG4gIH1cbiAgYXN5bmMgc3VwcG9ydHNSZXF1ZXN0U3RyZWFtcygpIHtcbiAgICBsZXQgZHVwbGV4QWNjZXNzZWQgPSBmYWxzZTtcbiAgICBjb25zdCBoYXNDb250ZW50VHlwZSA9IG5ldyBSZXF1ZXN0KHRoaXMub3B0aW9ucy51cmwsIHtcbiAgICAgIGJvZHk6IG5ldyBSZWFkYWJsZVN0cmVhbSgpLFxuICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICBnZXQgZHVwbGV4KCkge1xuICAgICAgICBkdXBsZXhBY2Nlc3NlZCA9IHRydWU7XG4gICAgICAgIHJldHVybiAnaGFsZic7XG4gICAgICB9LFxuICAgIH0pLmhlYWRlcnMuaGFzKCdDb250ZW50LVR5cGUnKTtcblxuICAgIHJldHVybiBkdXBsZXhBY2Nlc3NlZCAmJiAhaGFzQ29udGVudFR5cGU7XG4gIH1cblxuICBmaWxlVHlwZShkYXRhKSB7XG4gICAgY29uc3QgbWltZV90eXBlID0gKHNpZ25hdHVyZSkgPT4ge1xuICAgICAgc3dpdGNoIChzaWduYXR1cmUpIHtcbiAgICAgICAgY2FzZSAnODk1MDRFNDcnOlxuICAgICAgICAgIHJldHVybiAnaW1hZ2UvcG5nJztcbiAgICAgICAgY2FzZSAnNDc0OTQ2MzgnOlxuICAgICAgICAgIHJldHVybiAnaW1hZ2UvZ2lmJztcbiAgICAgICAgY2FzZSAnMjU1MDQ0NDYnOlxuICAgICAgICAgIHJldHVybiAnYXBwbGljYXRpb24vcGRmJztcbiAgICAgICAgY2FzZSAnRkZEOEZGREInOlxuICAgICAgICBjYXNlICdGRkQ4RkZFMCc6XG4gICAgICAgIGNhc2UgJ0ZGRDhGRkUxJzpcbiAgICAgICAgICByZXR1cm4gJ2ltYWdlL2pwZWcnO1xuICAgICAgICBjYXNlICc1MDRCMDMwNCc6XG4gICAgICAgICAgcmV0dXJuICdhcHBsaWNhdGlvbi96aXAnO1xuICAgICAgICBjYXNlICdFRkJCQkYyMic6XG4gICAgICAgICAgcmV0dXJuICd0ZXh0L3Rzdic7IC8vJ3RleHQvdGFiLXNlcGFyYXRlZC12YWx1ZXMnO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGNvbnNvbGUubG9nKCd1bmtub3duc2lnbicsIHNpZ25hdHVyZSlcbiAgICAgICAgICByZXR1cm4gJ3Vua25vd24nO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCB1aW50ID0gbmV3IFVpbnQ4QXJyYXkoZGF0YSk7XG4gICAgbGV0IGJ5dGVzID0gW11cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDQ7IGkrKykge1xuICAgICAgYnl0ZXMucHVzaCh1aW50W2ldLnRvU3RyaW5nKDE2KSlcbiAgICB9XG4gICAgZGF0YSA9IGJ5dGVzLmpvaW4oJycpLnRvVXBwZXJDYXNlKCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGlucHV0OiB1aW50LFxuICAgICAgbWltZXR5cGU6IG1pbWVfdHlwZShkYXRhKVxuICAgIH07XG4gIH1cblxuICBhc3luYyBmZmxUb1N0cmVhbSgpIHtcbiAgICBjb25zdCBmZmxhdGVTdHJlYW0gPSB0aGlzLnppcDtcbiAgICBjb25zdCB0cmFuc2Zvcm0gPSBuZXcgVHJhbnNmb3JtU3RyZWFtKCk7XG4gICAgY29uc3Qgd3JpdGVyID0gdHJhbnNmb3JtLndyaXRhYmxlLmdldFdyaXRlcigpO1xuICAgIHJldHVybiBuZXcgVHJhbnNmb3JtU3RyZWFtKHtcbiAgICAgIHN0YXJ0KGNvbnRyb2xsZXIpIHtcbiAgICAgICAgZmZsYXRlU3RyZWFtLm9uZGF0YSA9IChlcnJvciwgZGF0YSwgZmluYWwpID0+IHtcbiAgICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdlcnJvcicsIGVycm9yKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKGRhdGEpO1xuICAgICAgICAgICAgaWYgKGZpbmFsKSB7XG4gICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdmaW5hbCcsIGZpbmFsKTtcbiAgICAgICAgICAgICAgLy8gIGNvbnRyb2xsZXIudGVybWluYXRlKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBmbHVzaChjb250cm9sbGVyKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCd0ZXJtaW5hdGUgZmZzdHJlbScpXG4gICAgICAgIGNvbnRyb2xsZXIudGVybWluYXRlKCk7XG4gICAgICB9XG4gICAgfSlcblxuICB9XG4gIC8vXG5cblxuICBhc3luYyByZWFkRGlyZWN0b3J5KGRpciwgcGFyZW50LCBvbmNvbXBsZXRlLCBvbmVycm9yID0gbnVsbCkge1xuICAgIGNvbnNvbGUubG9nKCdyZWFkJywgZGlyLm5hbWUpXG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgbGV0IGVycm9yZWQgPSBmYWxzZTtcbiAgICBsZXQgZGlyZW50cmllcyA9IFtdLFxuICAgICAgaGFuZGxlcnMgPSBbXSxcbiAgICAgIGZpbGVzID0gW107XG5cbiAgICBjb25zdCBvbl9lcnJvciA9IG9uZXJyb3IgPyBvbmVycm9yIDogKGVycikgPT4ge1xuICAgICAgY29uc29sZS5sb2coJ29uX2Vycm9yJywgZXJyKVxuICAgICAgaWYgKCFlcnJvcmVkKSB7XG4gICAgICAgIGVycm9yZWQgPSB0cnVlO1xuXG4gICAgICB9XG4gICAgfTtcblxuICAgIGNvbnN0IHJlYWRmaWxlID0gYXN5bmMgZnVuY3Rpb24oZmlsZSwgemlwcGVkc3RyZWFtKSB7XG4gICAgICBjb25zdCByZWFkZXIgPSBmaWxlLnN0cmVhbSgpLmdldFJlYWRlcigpO1xuICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIGRvbmUsXG4gICAgICAgICAgdmFsdWVcbiAgICAgICAgfSA9IGF3YWl0IHJlYWRlci5yZWFkKCk7XG4gICAgICAgIGlmIChkb25lKSB7XG4gICAgICAgICAgYXdhaXQgemlwcGVkc3RyZWFtLnB1c2gobmV3IFVpbnQ4QXJyYXkoMCksIHRydWUpO1xuICAgICAgICAgIHJldHVybiBkb25lO1xuICAgICAgICB9XG4gICAgICAgIGF3YWl0IHppcHBlZHN0cmVhbS5wdXNoKHZhbHVlKTtcbiAgICAgIH1cblxuICAgIH07XG5cbiAgICAvL1xuICAgIGNvbnN0IHByb2Nlc3NfZmlsZSA9IGFzeW5jIGZ1bmN0aW9uKCkge1xuICAgICAgY29uc3QgZW50cnkgPSBmaWxlcy5zaGlmdCgpO1xuICAgICAgY29uc3QgZmlsZXBhdGggPSBlbnRyeS5mdWxsUGF0aC5zbGljZSgxKTtcbiAgICAgIC8vICBjb25zb2xlLmxvZygnZmlsZWFkZD0nICsgc2VsZi5udW1maWxlcywgZW50cnkubmFtZSlcbiAgICAgIGNvbnN0IGV4dCA9IGZpbGVwYXRoLnNsaWNlKGZpbGVwYXRoLmxhc3RJbmRleE9mKCcuJykgKyAxKTtcbiAgICAgIGNvbnN0IHppcF9maWxlID0gYXN5bmMgKGZpbGV0b3ppcCkgPT4ge1xuICAgICAgICBjb25zdCBpc2NvbXByZXNzZWQgPSBhbHJlYWR5X2NvbXByZXNzZWQuaGFzKGV4dCk7XG4gICAgICAgIGNvbnN0IHppcHBlZHN0cmVhbSA9IGlzY29tcHJlc3NlZCA/XG4gICAgICAgICAgbmV3IFppcFBhc3NUaHJvdWdoKGZpbGVwYXRoKSA6XG4gICAgICAgICAgZmlsZXRvemlwLnNpemUgPiBsYXJnZWZpbGUgP1xuICAgICAgICAgIG5ldyBBc3luY1ppcERlZmxhdGUoZmlsZXBhdGgsIHtcbiAgICAgICAgICAgIGxldmVsOiA5XG4gICAgICAgICAgfSkgOiBuZXcgWmlwRGVmbGF0ZShmaWxlcGF0aCwge1xuICAgICAgICAgICAgbGV2ZWw6IDZcbiAgICAgICAgICB9KTtcbiAgICAgICAgLy8gIGNvbnNvbGUubG9nKCd6aXBzdHInLCB6aXBwZWRzdHJlYW0pXG4gICAgICAgIHppcHBlZHN0cmVhbS5vbmRhdGEgPSBhc3luYyBmdW5jdGlvbihlcnIsIGRhdCwgZmluYWwpIHtcbiAgICAgICAgICBpZiAoZXJyKSBjb25zb2xlLmxvZygnZXJyIGFkZCBjaHVuayB0byB6aXBmaWxlJyArIGRhdCwgZXJyKTtcbiAgICAgICAgICBlbHNlIGlmIChmaW5hbCkge1xuXG4gICAgICAgICAgICBpZiAoZmlsZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdmaWxlcycsIGZpbGVzLmxlbmd0aCk7XG4gICAgICAgICAgICAgIGF3YWl0IHByb2Nlc3NfZmlsZSgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgY29uc29sZS5sb2coJ2xhc3RmaWxlJywgZGlyLm5hbWUpO1xuICAgICAgICAgICAgICBhd2FpdCBvbl9jb21wbGV0ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgYXdhaXQgc2VsZi56aXAuYWRkKHppcHBlZHN0cmVhbSk7XG4gICAgICAgIHJldHVybiBhd2FpdCByZWFkZmlsZShmaWxldG96aXAsIHppcHBlZHN0cmVhbSk7XG4gICAgICB9O1xuICAgICAgc2VsZi5udW1maWxlcysrO1xuICAgICAgaWYgKHNlbGYubnVtZmlsZXMgPT09IDEpIHtcbiAgICAgICAgZmV0Y2goc2VsZi5vcHRpb25zLnVybC5yZXBsYWNlKCdteV9maWxlcycsICdzdHJlYW1fbXlfZmlsZXMnKSwge1xuICAgICAgICAgIG1vZGU6ICdjb3JzJyxcbiAgICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICAgIGNyZWRlbnRpYWxzOiBcImluY2x1ZGVcIixcbiAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL3ppcFwiLFxuICAgICAgICAgIH0sXG4gICAgICAgICAgYm9keTogc2VsZi56aXBSZWFkYWJsZVN0cmVhbS5yZWFkYWJsZSxcbiAgICAgICAgICBkdXBsZXg6ICdoYWxmJyxcbiAgICAgICAgfSkudGhlbigocmVzcG9uc2UpID0+IHtcbiAgICAgICAgICBjb25zb2xlLmxvZygncmVzcG9uc2UnLCByZXNwb25zZSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgYXdhaXQgZW50cnkuZmlsZSh6aXBfZmlsZSk7XG5cbiAgICB9O1xuICAgIC8vXG5cbiAgICBjb25zdCBwcm9jZXNzX2VudHJpZXMgPSBmdW5jdGlvbigpIHtcbiAgICAgIGNvbnN0IGVudHJ5ID0gZGlyZW50cmllcy5zaGlmdCgpO1xuICAgICAgaWYgKGVudHJ5LmlzRmlsZSkge1xuICAgICAgICAvL2NvbnNvbGUubG9nKCdmaWxlbGVmdCAqKiotLS0nICsgZGlyLm5hbWUsIGVudHJ5Lm5hbWUpO1xuICAgICAgICBzZWxmLmNvdW50ZXIrKztcbiAgICAgICAgc2VsZi5jb3VudGVyZGlzcGxheS50ZXh0Q29udGVudCA9IHNlbGYuY291bnRlcjtcbiAgICAgICAgLy9jb25zdCBmID0gZW50cnkuZ2V0QXNGaWxlKCk7XG4gICAgICAgIGZpbGVzLnB1c2goZW50cnkpO1xuICAgICAgICAvLyAgYXdhaXQgcHJvY2Vzc19maWxlKGVudHJ5LCBlbnRyeS5mdWxsUGF0aC5zbGljZSgxKSk7XG4gICAgICAgIHNlbGYuY291bnRlci0tO1xuICAgICAgICBzZWxmLmNvdW50ZXJkaXNwbGF5LnRleHRDb250ZW50ID0gc2VsZi5jb3VudGVyO1xuICAgICAgfSBlbHNlIGlmIChlbnRyeS5pc0RpcmVjdG9yeSkge1xuICAgICAgICBjb25zb2xlLmxvZygnZW50cnkgaXMgZGlyJywgZW50cnkpXG4gICAgICAgIGhhbmRsZXJzLnB1c2goZW50cnkpO1xuICAgICAgfVxuICAgICAgaWYgKGRpcmVudHJpZXMubGVuZ3RoKSBwcm9jZXNzX2VudHJpZXMoKTtcblxuICAgIH1cbiAgICBjb25zdCBvbl9jb21wbGV0ZSA9IGFzeW5jIGZ1bmN0aW9uKCkge1xuICAgICAgZm9yIChjb25zdCBoYW5kbGVyIG9mIGhhbmRsZXJzKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKGhhbmRsZXIpO1xuICAgICAgICBhd2FpdCBzZWxmLnJlYWREaXJlY3RvcnkoaGFuZGxlciwgZGlyLCBhc3luYyBmdW5jdGlvbigpIHtcbiAgICAgICAgICBjb25zb2xlLmxvZygnaWRpcicsIGhhbmRsZXIubmFtZSk7XG4gICAgICAgICAgaWYgKGZpbGVzLmxlbmd0aCkgYXdhaXQgcHJvY2Vzc19maWxlKCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgfVxuICAgIGNvbnN0IHJlYWRlciA9IGRpci5jcmVhdGVSZWFkZXIoKTtcbiAgICBjb25zdCBvbl9yZWFkID0gYXN5bmMgZnVuY3Rpb24oZW50cykge1xuICAgICAgaWYgKGVudHMubGVuZ3RoICYmICFlcnJvcmVkKSB7XG4gICAgICAgIGRpcmVudHJpZXMgPSBbLi4uZGlyZW50cmllcywgLi4uZW50c107XG4gICAgICAgIGF3YWl0IHJlYWRlci5yZWFkRW50cmllcyhvbl9yZWFkLCBvbl9lcnJvcik7XG4gICAgICB9IGVsc2UgaWYgKCFlcnJvcmVkKSB7XG4gICAgICAgIHByb2Nlc3NfZW50cmllcygpO1xuICAgICAgICBjb25zb2xlLmxvZygndGhlZW5kLS0tLS0tLS0tLS0tLS0tLS0tLSAnICsgZGlyLm5hbWUsIGRpcmVudHJpZXMubGVuZ3RoKVxuICAgICAgICBhd2FpdCBvbl9jb21wbGV0ZSgpO1xuXG5cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCd0cmVhdCBlcnJvciByZWFkZGlyJyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgYXdhaXQgcmVhZGVyLnJlYWRFbnRyaWVzKG9uX3JlYWQsIG9uX2Vycm9yKTtcblxuICAgIGNvbnNvbGUubG9nKCdlbmRkaXInICsgZGlyLm5hbWUsIGRpcmVudHJpZXMubGVuZ3RoKVxuXG4gIH1cblxuICBjb21wcmVzc2lvbkxldmVsKG5hbWUpIHtcbiAgICBpZiAoIW5hbWUpIHtcblxuICAgICAgcmV0dXJuIC0xO1xuICAgIH1cbiAgICBsZXQgZXh0ID0gbmFtZS5zcGxpdCgnLicpO1xuICAgIGV4dCA9IChleHQubGVuZ3RoID4gMSkgPyBleHRbZXh0Lmxlbmd0aCAtIDFdIDogZXh0WzBdO1xuICAgIHJldHVybiAoYWxyZWFkeV9jb21wcmVzc2VkLmZpbmQoZXggPT4gKGV4ID09PSBleHQpKSkgPyAyIDogdGhpcy5vcHRpb25zLmxldmVsO1xuICB9XG5cbiAgYXN5bmMgc2VuZFppcCgpIHtcbiAgICAvLyAgY29uc3QgZmlsZXN0cmVhbSA9IG5ldyBXcml0YWJsZVN0cmVhbSgpO1xuICAgIC8vICBjb25zdCB3cml0ZXIgPSBmaWxlc3RyZWFtLmdldFdyaXRlcigpO1xuICAgIC8vXG5cbiAgICAvL1xuXG5cbiAgICAvKiAgZmV0Y2godGhpcy5vcHRpb25zLnVybC5yZXBsYWNlKCdteV9maWxlcycsICdzdHJlYW1fbXlfZmlsZXMnKSwge1xuICAgICAgICBtb2RlOiAnY29ycycsXG4gICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAgIGNyZWRlbnRpYWxzOiBcImluY2x1ZGVcIixcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwidGV4dC9wbGFpblwiLFxuICAgICAgICB9LFxuICAgICAgICBib2R5OiB0aGlzLnppcFJlYWRhYmxlU3RyZWFtLFxuICAgICAgICBkdXBsZXg6ICdoYWxmJyxcbiAgICAgIH0pOyovXG4gICAgLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4gICAgLyp3ZWJ0cmFuc3BvcnRcbiAgICAgIGNvbnN0IHRyYW5zcG9ydCA9IG5ldyBXZWJUcmFuc3BvcnQodGhpcy5vcHRpb25zLnVybCk7XG5cbiAgICAgIC8vIE9wdGlvbmFsbHksIHNldCB1cCBmdW5jdGlvbnMgdG8gcmVzcG9uZCB0b1xuICAgICAgLy8gdGhlIGNvbm5lY3Rpb24gY2xvc2luZzpcbiAgICAgIHRyYW5zcG9ydC5jbG9zZWQudGhlbigoKSA9PiB7XG4gICAgICAgIGNvbnNvbGUubG9nKGBUaGUgSFRUUC8zIGNvbm5lY3Rpb24gdG8gJHt1cmx9IGNsb3NlZCBncmFjZWZ1bGx5LmApO1xuICAgICAgfSkuY2F0Y2goKGVycm9yKSA9PiB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoYFRoZSBIVFRQLzMgY29ubmVjdGlvbiB0byAke3VybH0gY2xvc2VkIGR1ZSB0byAke2Vycm9yfS5gKTtcbiAgICAgIH0pO1xuXG4gICAgICAvLyBPbmNlIC5yZWFkeSBmdWxmaWxscywgdGhlIGNvbm5lY3Rpb24gY2FuIGJlIHVzZWQuXG4gICAgICBhd2FpdCB0cmFuc3BvcnQucmVhZHk7XG4gICAgICBjb25zdCBzdHJlYW1zZW5kID0gYXdhaXQgdHJhbnNwb3J0LmNyZWF0ZVVuaWRpcmVjdGlvbmFsU3RyZWFtKCk7XG4gICAgICBjb25zdCB3cml0ZXIgPSBzdHJlYW1zZW5kLndyaXRhYmxlLmdldFdyaXRlcigpO1xuICAgICAgY29uc3Qgc3RyZWFtdGVzdCA9IG5ldyBSZWFkYWJsZVN0cmVhbSh7XG4gICAgICAgIGFzeW5jIHN0YXJ0KGNvbnRyb2xsZXIpIHtcbiAgICAgICAgICBhd2FpdCB3YWl0KDEwMDApO1xuICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSgnVGhpcyAnKTtcbiAgICAgICAgICBhd2FpdCB3YWl0KDEwMDApO1xuICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSgnaXMgJyk7XG4gICAgICAgICAgYXdhaXQgd2FpdCgxMDAwKTtcbiAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoJ2EgJyk7XG4gICAgICAgICAgYXdhaXQgd2FpdCgxMDAwKTtcbiAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoJ3Nsb3cgJyk7XG4gICAgICAgICAgYXdhaXQgd2FpdCgxMDAwKTtcbiAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoJ3JlcXVlc3QuJyk7XG4gICAgICAgICAgY29udHJvbGxlci5jbG9zZSgpO1xuICAgICAgICB9LFxuICAgICAgfSkucGlwZVRvKHdyaXRlcik7XG5cbiAgICAqL1xuXG5cblxuXG4gIH1cblxuXG59Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/modules/js-upload.js\n")}}]);