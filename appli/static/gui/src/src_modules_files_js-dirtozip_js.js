"use strict";(self.webpackChunk=self.webpackChunk||[]).push([["src_modules_files_js-dirtozip_js"],{"./src/modules/files/js-dirtozip.js"(module,__webpack_exports__,__webpack_require__){eval("{__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   JsDirToZip: () => (/* binding */ JsDirToZip)\n/* harmony export */ });\n/* harmony import */ var _modules_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../modules/utils.js */ \"./src/modules/utils.js\");\n/* harmony import */ var fflate__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! fflate */ \"./node_modules/fflate/esm/browser.js\");\n/* harmony import */ var _modules_module_event_emitter_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../modules/module-event-emitter.js */ \"./src/modules/module-event-emitter.js\");\n/* harmony import */ var detect_browser__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! detect-browser */ \"./node_modules/detect-browser/es/index.js\");\n/* harmony import */ var _modules_alert_box_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../modules/alert-box.js */ \"./src/modules/alert-box.js\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_modules_module_event_emitter_js__WEBPACK_IMPORTED_MODULE_2__, _modules_alert_box_js__WEBPACK_IMPORTED_MODULE_4__]);\n([_modules_module_event_emitter_js__WEBPACK_IMPORTED_MODULE_2__, _modules_alert_box_js__WEBPACK_IMPORTED_MODULE_4__] = __webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__);\n\n\n\n\n\n\n\nconst already_compressed = new Set([\n  'zip', 'gz', 'png', 'jpg', 'jpeg', 'pdf', 'doc', 'docx', 'ppt', 'pptx',\n  'xls', 'xlsx', 'heic', 'heif', '7z', 'bz2', 'rar', 'gif', 'webp', 'webm',\n  'mp4', 'mov', 'mp3', 'aifc'\n]);\nconst can_be_compressed = new Set(['tsv','txt','log','csv']);\nconst accept = '.tsv,.png,.jpg, .jpeg,.zip,.gz,.7z,.bz2';\n\nfunction JsDirToZip(options = {}) {\n  const MAXSIZE = (document.querySelector('[data-max_upload_size]'))?parseInt(document.querySelector('[data-max_upload_size]').dataset['max_upload_size']):1073741824;//681574400;//681574400; // 650M //1073741824; //4294967296; //// 3221225472; // 2147483648;\n  const UPLOADINPARTS = (document.querySelector('[data-uploadinparts]'))?true:false;\n  const eventnames = {\n    ready: 'ready',\n    follow: 'follow',\n    complete: 'complete',\n    endreaddir: 'endreaddir',\n    gzip: 'gzip',\n    endzip: 'endzip',\n    sendfile: 'sendfile',\n    bigfile: 'bigfile',\n    terminate: 'terminate',\n    pending: 'pending',\n    errorfile: 'errorfile',\n    counter: 'counter',\n    reject: 'reject',\n    message: 'message',\n    error: 'error',\n    init: 'init',\n    setuploadpath:'setuploadpath'\n  };\n  let jsScanDir, properties,uploadpath;\n  let trydelete=0;\n  const defaultOptions = {\n    uploadurl: '/gui/files/upload',\n    largefile: MAXSIZE,\n    accept: accept.split(',')\n  }\n  // uses https://developer.mozilla.org/en-US/docs/Web/API/File_System_API/Origin_private_file_system\n  //# alternative (not supported in Safari) for .createWritable\n  options = { ...defaultOptions,\n    ...options\n  };\n  // other module receiving events\n  const _listener = (options.listener) ? options.listener : uuid;\n  Object.freeze(options);\n  const uuid = (0,_modules_utils_js__WEBPACK_IMPORTED_MODULE_0__.generate_uuid)();\n  initStorage();\n  init();\n\nfunction browserRequired() {\nconst browser = (0,detect_browser__WEBPACK_IMPORTED_MODULE_3__.detect)();\n     const accepted={android:{chrome:109,opera:74,firefox:111,samsungbrowser:21,webview:109}, ios:false,other:{chrome:86,edge:86,opera:72,firefox:111}};\n        let os =browser.os.toLowerCase();\n        os=(os in ['android','ios'])?os:'other';\n     const name=browser.name.toLowerCase();\n     const version = parseInt(browser.version.split('.')[0]);\n     if (Object.keys(accepted).indexOf(os)<0 || Object.keys(accepted[os]).indexOf(name)<0 || parseInt(accepted[os][name])>parseInt(version))  {\n     _modules_module_event_emitter_js__WEBPACK_IMPORTED_MODULE_2__.ModuleEventEmitter.emit(eventnames.message, {\n          id: \"browser\",\n          name: \"browser\",\n          message: \"your browser does not have a required functionnality. Please upgrade or use a valid browser and version :\"+  JSON.stringify(accepted).replaceAll('\"',''),\n        }, _listener);\n     }\n     }\n  function init() {\n    properties = initProps();\n     _modules_module_event_emitter_js__WEBPACK_IMPORTED_MODULE_2__.ModuleEventEmitter.on(eventnames.setuploadpath, async(e) => {\n    uploadpath=e.path;},uuid);\n    _modules_module_event_emitter_js__WEBPACK_IMPORTED_MODULE_2__.ModuleEventEmitter.on(eventnames.init, async (e) => {\n      if (!isActive()) {\n        await reset();\n        _modules_module_event_emitter_js__WEBPACK_IMPORTED_MODULE_2__.ModuleEventEmitter.emit(eventnames.complete, {\n          name: eventnames.ready\n        }, _listener);\n          _modules_module_event_emitter_js__WEBPACK_IMPORTED_MODULE_2__.ModuleEventEmitter.emit(eventnames.message, {\n          name: _modules_alert_box_js__WEBPACK_IMPORTED_MODULE_4__.AlertBox.alertconfig.types.success,\n          message: \"Upload of \"+ e.path +\" is done\",\n        }, _listener);\n        properties.endreaddir = false;\n      } else console.log('partly finished '+properties.hashandlers+ 'follow='+properties.follow, e);\n    }, uuid);\n    _modules_module_event_emitter_js__WEBPACK_IMPORTED_MODULE_2__.ModuleEventEmitter.on(eventnames.endzip, async(e) => {\n      if (!e.bigfile && properties.zip) properties.zip.end();\n      const evtsend=async function() {\n      const zipclosed = await listStorage(null,properties.zipname);\n      if (zipclosed === true) {\n      const message = buildMessage(e, {\n        name: eventnames.sendfile,      });\n\n      _modules_module_event_emitter_js__WEBPACK_IMPORTED_MODULE_2__.ModuleEventEmitter.emit(eventnames.complete, message, _listener);}\n      else setTimeout(async function() {await evtsend();},2000);}\n      evtsend();\n    }, uuid);\n    _modules_module_event_emitter_js__WEBPACK_IMPORTED_MODULE_2__.ModuleEventEmitter.on(eventnames.sendfile, async (e) => {\n      if (properties.hashandlers) {\n        const message = buildMessage(e, {\n            name: eventnames.follow,\n        });\n        _modules_module_event_emitter_js__WEBPACK_IMPORTED_MODULE_2__.ModuleEventEmitter.emit(eventnames.follow, message, _listener);\n        await execHandler();\n      } else { const message = buildMessage(e, {\n        name: eventnames.pending,\n      });\n\n        _modules_module_event_emitter_js__WEBPACK_IMPORTED_MODULE_2__.ModuleEventEmitter.emit(eventnames.complete, message, _listener);\n      }\n\n      const file = await getFile();\n      sendZipFile(file, (e.path ? e.path : uploadpath), null);\n    }, uuid);\n    _modules_module_event_emitter_js__WEBPACK_IMPORTED_MODULE_2__.ModuleEventEmitter.on(eventnames.endreaddir, (e) => {\n      properties.endreaddir = true;\n      checkProcessed(e);\n    }, uuid);\n    _modules_module_event_emitter_js__WEBPACK_IMPORTED_MODULE_2__.ModuleEventEmitter.on(eventnames.counter, async (e) => {\n      properties.endcounter = false;\n      properties.counter[e.name] += 1;\n      _modules_module_event_emitter_js__WEBPACK_IMPORTED_MODULE_2__.ModuleEventEmitter.emit(eventnames.counter, e, _listener);\n      if (e.name === 'zip' && properties.counter.scan === properties.counter.zip) {\n        properties.endcounter = true;\n        checkProcessed(e);\n      }\n      if (e.name === 'zip' && properties.callback) await properties.callback();\n    }, uuid);\n    _modules_module_event_emitter_js__WEBPACK_IMPORTED_MODULE_2__.ModuleEventEmitter.on(eventnames.error,  (e) => {});\n  }\n\n  function initProps() {\n    return {\n      zip: null,\n      zipname: null,\n      filestream: null,\n      streamhandle: null,\n      gzipped: null,\n      sizetozip: 0,\n      part: 0,\n      follow: null,\n      endcounter: false,\n      endreaddir: false,\n      callback: null,\n      pos: 0,\n      counter: {\n        scan: 0,\n        zip: 0,\n        reject: 0,\n        error:0,\n      },\n      handlers: [],\n      hashandlers:false,\n     }\n  }\n  async function reset() {\n    properties = initProps();\n    await initStorage();\n  }\n\n  function isActive() {\n    return (properties.zip !== null || properties.follow !== null || properties.hashandlers || properties.endreaddir !== true);\n  }\n\n  async function initZip() {\n    properties.pos = 0;\n    properties.sizetozip = 0;\n    properties.zip = new fflate__WEBPACK_IMPORTED_MODULE_1__.Zip((error, chunk, final) => {\n      if (error) {\n        onError(eventnames.errorfile, {\n                message: error}, _listener);\n        return false;\n      } else {\n        properties.streamhandle.write(chunk, {\n          at: self.pos\n        });\n        properties.pos += chunk.length;\n        if (final) {\n          properties.streamhandle.close();\n        }\n      }\n    });\n    // hack for memory usage\n    zipOnData();\n    if (properties.follow) await properties.follow();\n  }\n\n  function checkProcessed(e) {\n    if (properties.endreaddir === true) {\n    if(properties.endcounter === true) {\n      const message = buildMessage(e, {\n       name: eventnames.endzip\n      });\n      _modules_module_event_emitter_js__WEBPACK_IMPORTED_MODULE_2__.ModuleEventEmitter.emit(eventnames.complete, message, _listener);\n    }  else if (properties.counter.error>0) endProcess();}\n  }\n\n  function zipOnData(zip = null) {\n    zip = (zip === null) ? properties.zip : zip;\n    const ondata = zip.ondata;\n    zip.ondata = (error, data, final) => {\n      ondata(error, data, final);\n      if (final) {\n        zip.d = null;\n        if (zip.u && zip.u.at(-1)) zip.u.at(-1).d = null; // Object created in `zip.add()`\n      }\n    }\n  }\n\n  function buildMessage(e, message = {}) {\n    if (e.hasOwnProperty(\"part\")) {\n      message.part = e.part;\n    } else properties.part = 0;\n    if (e.hasOwnProperty(\"bigfile\")) message.bigfile = e.bigfile;\n    if (e.hasOwnProperty(\"path\")) message.path = e.path;\n    return message;\n  }\n\n  async function quotaEstimate() {\n    if (navigator && navigator.storage && navigator.storage.estimate) {\n      navigator.storage.estimate().then((quota) => {\n        const percentageUsed = ((quota.usage / quota.quota) * 100).toFixed(2);\n        const remaining = (0,_modules_utils_js__WEBPACK_IMPORTED_MODULE_0__.format_bytes)(quota.quota - quota.usage);\n        _modules_module_event_emitter_js__WEBPACK_IMPORTED_MODULE_2__.ModuleEventEmitter.emit(eventnames.message, {\n          id: \"quota\",\n          name: \"console\",\n          message: \"you've used \" + percentageUsed + \"% of the available browser storage necessary to locally compress files (\" + remaining + \").\",\n        }, _listener);\n      });\n    }\n  }\n\n  async function initStorage() {\n    if (navigator && navigator.storage && navigator.storage.estimate) {\n      await cleanStorage();\n      quotaEstimate();\n    } else _modules_module_event_emitter_js__WEBPACK_IMPORTED_MODULE_2__.ModuleEventEmitter.emit(eventnames.message, {\n      name: \"error\",\n      message: \"no navigator storage\"\n    }, uuid);\n  }\n\n  async function createLocalStream(name, accept = {\n    'application/zip': ['.zip'],\n  }) {\n    const root = await navigator.storage.getDirectory();\n    const opts = {\n      types: [{\n        description: 'Temp file',\n        accept: accept,\n      }, ],\n      create: true\n    };\n    const filestream = await root.getFileHandle(name, opts);\n    const streamhandle = await filestream.createWritable({mode:\"exclusive\"});\n    return {\n      filestream,\n      streamhandle\n    };\n  }\n  async function scanCommon(zipname, options = {}) {\n    properties.endreaddir = false;\n    if (properties.zip === null) {\n      zipname = zipname.split(_modules_utils_js__WEBPACK_IMPORTED_MODULE_0__.dirseparator)[0];\n      zipname = (zipname.trim() === ``) ? 'temp' : zipname;\n      const type = (options && options.type) ? options.type : '.zip';\n      properties.zipname = ((options.zipname) ? options.zipname : zipname) + type; //\n      const zipinstorage = await searchStorage(properties.zipname);\n      if (zipinstorage) properties.zipname = '1_' + properties.zipname;\n      const {\n        filestream,\n        streamhandle\n      } = await createLocalStream(properties.zipname);\n      properties.filestream = filestream;\n      properties.streamhandle = streamhandle;\n      let size = 0;\n      properties.part = 0;\n      await initZip();\n      if (!jsScanDir) {\n        const {\n          JsScanDir\n        } = await __webpack_require__.e(/*! import() */ \"src_modules_files_js-scandir_js\").then(__webpack_require__.bind(__webpack_require__, /*! ../files/js-scandir.js */ \"./src/modules/files/js-scandir.js\"));\n        const process_file = async (entry, callback) => {\n          if (acceptFile(entry)) {\n            properties.callback = callback;\n            await processFile(entry);\n          } else rejectFile(entry, callback);\n        }\n        jsScanDir = JsScanDir(process_file);\n      }\n    }\n  }\n\n  async function scanBrowse(pick, options = {}) {\n    const entries = (pick instanceof FileList) ? Array.from(pick) : (pick.kind === \"directory\") ? await Array.fromAsync(pick.values()): (Array.isArray(pick)) ? pick : [pick];\n    const name = entries[0].name;\n    let relpath = (pick instanceof FileList) ? entries[0].webkitRelativePath : null;\n    relpath = (relpath) ? relpath.split(_modules_utils_js__WEBPACK_IMPORTED_MODULE_0__.dirseparator) : [``];\n    if (relpath.length) relpath.pop();\n    relpath = relpath.join(_modules_utils_js__WEBPACK_IMPORTED_MODULE_0__.dirseparator);\n    const path = (pick instanceof FileList) ? relpath : (pick.kind === \"directory\") ? pick.name : ``;\n    await scanCommon(path, options);\n    await jsScanDir.processEntries(entries, path, () => {\n      dirComplete();\n    });\n  }\n\n  async function scanHandle(dropped, options = {}) {\n    await scanCommon(dropped.name, options);\n    if (dropped.isDirectory === true) {\n      await jsScanDir.readDirectory(dropped, () => {\n        dirComplete();\n      });\n    } else if (dropped.isFile === true) {\n      await jsScanDir.processFile(dropped, () => {\n        dirComplete();\n      });\n    }\n  }\n\n  function dirComplete() {\n    _modules_module_event_emitter_js__WEBPACK_IMPORTED_MODULE_2__.ModuleEventEmitter.emit(eventnames.endreaddir, {\n      name: eventnames.endreaddir\n    }, uuid);\n  }\n\n  function addHandler(handler) {\n    properties.handlers.push(handler);\n    properties.hashandlers= (properties.handlers.length>0)\n  }\n\n  async function execHandler() {\n    // serie\n    if (properties.hashandlers) {\n      const handler = properties.handlers.shift();\n      await handler();\n     properties.hashandlers = (properties.handlers.length>0)\n    }\n    return;\n  }\n    async function gzipBigFile(file, filepath) {\n    let dt = Date.now();\n    filepath = (filepath.indexOf(_modules_utils_js__WEBPACK_IMPORTED_MODULE_0__.dirseparator) === 0) ? filepath.substr(1) : filepath;\n    const parts = filepath.split(_modules_utils_js__WEBPACK_IMPORTED_MODULE_0__.dirseparator);\n    parts.pop();\n    const sendpath = uploadpath + _modules_utils_js__WEBPACK_IMPORTED_MODULE_0__.dirseparator +parts.join(_modules_utils_js__WEBPACK_IMPORTED_MODULE_0__.dirseparator);\n    const ext = file.name.slice(file.name.lastIndexOf('.') + 1);\n    if (already_compressed.has(ext)) {\n       _modules_module_event_emitter_js__WEBPACK_IMPORTED_MODULE_2__.ModuleEventEmitter.emit(eventnames.counter, {\n        name: 'zip',\n        path: filepath,\n        bigfile:file.name,\n        size: file.size\n      }, uuid);\n      addHandler(async () => {\n        await sendChunk(sendpath,file);\n      });\n    } else {\n      let zipname = file.name + '.gz';\n      const {\n        filestream,\n        streamhandle\n      } = await createLocalStream(zipname, {\n        'application/gzip': ['.gz'],\n      });\n      let pos = 0;\n\n      const gzipped = new fflate__WEBPACK_IMPORTED_MODULE_1__.AsyncGzip({\n        level: 6,\n        filename: filepath\n      });\n      gzipped.ondata = (err, data, final) => {\n       if(pos > MAXSIZE)  {\n                properties.counter.error+=1;\n              onError(_modules_alert_box_js__WEBPACK_IMPORTED_MODULE_4__.AlertBox.alertconfig.types.error, {\n\n                name:_modules_alert_box_js__WEBPACK_IMPORTED_MODULE_4__.AlertBox.alertconfig.types.error,\n                bigfile:file.name,\n                path:filepath,\n                message:'File '+file.name+' size exceeds maxsize. Cannot be sent in chunks for the moment.'}, _listener);\n          streamhandle.close();gzipped.ondata= (err, data, final) => {}; return endProcess();\n          }\n        if (err) {\n            properties.counter.error+=1;\n          onError(_modules_alert_box_js__WEBPACK_IMPORTED_MODULE_4__.AlertBox.alertconfig.types.error, {\n            name:_modules_alert_box_js__WEBPACK_IMPORTED_MODULE_4__.AlertBox.alertconfig.types.error,\n            bigfile: file.name,\n            path: filepath,\n            size: file.size,\n            message: 'Error compressing file '+ file.name +' '+err\n          });\n        } else {\n          streamhandle.write(data, {\n            at: pos\n          });\n          pos += data.length;\n          if (final) {\n            streamhandle.close();\n                 filepath+='.gz';\n                _modules_module_event_emitter_js__WEBPACK_IMPORTED_MODULE_2__.ModuleEventEmitter.emit(eventnames.counter, {\n              name: 'zip',\n              path: filepath,\n              size: file.size,\n              bigfile:file.name\n            }, uuid);\n\n         addHandler(async () => {\n         await sendChunk(sendpath,filestream);\n            });\n          }\n        }\n      };\n      const count = false;\n      await readFile(file, filepath, gzipped, count);\n    }\n  }\n  async function partZip() {\n    properties.part += 1;\n    _modules_module_event_emitter_js__WEBPACK_IMPORTED_MODULE_2__.ModuleEventEmitter.emit(eventnames.complete, {\n     name: eventnames.endzip,\n      part: properties.part\n    }, _listener);\n  }\n  async function readFile(file, filepath, zippedstream, count = true) {\n    const reader = file.stream().getReader();\n    let pause = false;\n    /*  onBackpressure(zippedstream, this.streamhandle, should_apply_backpressure => {\n        if (should_apply_backpressure) pause = true;\n        else if (pause) pause = false;\n      });*/\n    while (true) {\n      const {\n        done,\n        value\n      } = await reader.read();\n      if (done) {\n        zippedstream.push(new Uint8Array(0), true);\n        if (count === true) _modules_module_event_emitter_js__WEBPACK_IMPORTED_MODULE_2__.ModuleEventEmitter.emit(eventnames.counter, {\n          name: 'zip',\n          path: filepath,\n          size: (zippedstream.size) ? zippedstream.size : file.size\n        }, uuid);\n        break;\n      }\n      zippedstream.push(value);\n    }\n  }\n\n  async function zipStream(file, filepath) {\n    const ext = filepath.slice(filepath.lastIndexOf('.') + 1);\n    const iscompressed = already_compressed.has(ext);\n    const zippedstream = (iscompressed) ? new fflate__WEBPACK_IMPORTED_MODULE_1__.ZipPassThrough(filepath) : file.size > options.largefile ?\n      new fflate__WEBPACK_IMPORTED_MODULE_1__.AsyncZipDeflate(filepath, {\n        level: 6,\n      }) : new fflate__WEBPACK_IMPORTED_MODULE_1__.ZipDeflate(filepath, {\n        level: 6\n      });\n      properties.zip.add(zippedstream);\n    await readFile(file, filepath, zippedstream);\n  }\n  function compressed_estimate(file) {\n    const ext = file.name.slice(file.name.lastIndexOf('.') + 1);\n    if (can_be_compressed.has(ext)) return Math.floor(file.size/2);\n    return file.size;\n  }\n  async function addFileToZipStream(file, filepath, count = true) {\n    if (count === true) _modules_module_event_emitter_js__WEBPACK_IMPORTED_MODULE_2__.ModuleEventEmitter.emit(eventnames.counter, {\n      name: 'scan',\n      path: filepath,\n      size: file.size\n    }, uuid);\n    properties.follow = null;\n\n    // check file size > max post size\n    const compressed_size = compressed_estimate(file);\n    if (compressed_size >= MAXSIZE ) {\n    // to prevent errors and uncomplete zip send error\n      properties.counter.error+=1;\n      if(UPLOADINPARTS) gzipBigFile(file, filepath);\n      else endProcess();\n    } else {\n      // check zip file size > total zip size\n      properties.sizetozip += compressed_size;\n      if (properties.sizetozip > MAXSIZE) {\n      if(UPLOADINPARTS) {\n      properties.follow = async () => {\n          await zipStream(file, filepath);\n        }\n        partZip();\n        } else endProcess();\n      } else {\n        await zipStream(file, filepath);\n      }\n    }\n  }\n\n  function acceptFile(entry) {\n    const filepath = entry.name;\n    const ext = filepath.slice(filepath.lastIndexOf('.') + 1);\n    return accept.includes(ext);\n  }\n\n  function rejectFile(file, callback = null) {\n    const path = (file.fullPath) ? file.fullPath : file.webkitRelativePath;\n    properties.counter.reject += 1;\n    _modules_module_event_emitter_js__WEBPACK_IMPORTED_MODULE_2__.ModuleEventEmitter.emit(eventnames.reject, {\n      name: eventnames.reject,\n      path: path,\n    }, _listener);\n    if (callback !== null) callback();\n  }\n  async function processFile(entry) {\n    const entrypath = (entry.fullPath) ? entry.fullPath : entry.webkitRelativePath;\n    entry.file(async file => {\n      await addFileToZipStream(file, entrypath);\n    });\n  }\n\n  function onError(action, message = null) {\n    message = (message) ? message : {};\n    switch (action) {\n      case eventnames.init:\n      case eventnames.errorfile:\n        message.name=action;\n        break;\n      default:\n        //message.name = eventnames.error;\n        break;\n    }\n    _modules_module_event_emitter_js__WEBPACK_IMPORTED_MODULE_2__.ModuleEventEmitter.emit(eventnames.message, message, _listener);\n  }\n  async function searchStorage(search) {\n    const entry = await navigator.storage.getDirectory();\n    for await (const [key, value] of entry.entries()) {\n      if (search === key) {\n        return true;\n        // removed by dead control flow\n\n      }\n    }\n    return false;\n  }\n  async function cleanStorage(entry = null) {\n    entry = (entry) ? entry : await navigator.storage.getDirectory();\n     for await (const [key, value] of entry.entries()) {\n      try {\n        await entry.removeEntry(key);\n        console.log(' Success remove storage ', key);\n      } catch (error) {\n        console.log(' error remove storage ' + key, error);\n        }\n      }\n    }\nasync function listStorage(entry = null,name=null) {\n    entry = (entry) ? entry : await navigator.storage.getDirectory();\n    let rep=true;\n     for await (const [key, value] of entry.entries()) {\n        if (name!==null) {\n            const parts = key.split('.');\n            if (parts.pop()==='crswap' && parts.join('.') ===name) {\n            rep=false;\n            break;\n            }\n        }\n        }\n      return rep;\n    }\n  async function endFetch(message, clean = false) {\n    if (properties.follow) {\n      properties.streamhandle = await properties.filestream.createWritable({mode:\"exclusive\"});\n      message.name = eventnames.follow;\n      _modules_module_event_emitter_js__WEBPACK_IMPORTED_MODULE_2__.ModuleEventEmitter.emit(eventnames.follow, message, _listener);\n      await initZip();\n      return;\n    } else properties.zip = null;\n    if (!properties.hashandlers) {message.name = eventnames.terminate;_modules_module_event_emitter_js__WEBPACK_IMPORTED_MODULE_2__.ModuleEventEmitter.emit(eventnames.complete, message, _listener);}\n  }\n\n  async function sendChunk(path,gzipped, start = 0, chunknum = 0, chunksize = MAXSIZE) {\n    const ext = gzipped.name.slice(gzipped.name.lastIndexOf('.') + 1);\n    const file = (already_compressed.has(ext))?gzipped:await gzipped.getFile();\n    const end = Math.min(start + chunksize, file.size);\n    if (end === file.size) {\n    path=path.replace(file.name,'');\n     sendZipFile(file, path, null, true);\n    } else {\n        properties.counter.error+=1;\n    onError(eventnames.errorfile, {\n          name: eventnames.error,\n          message:'File '+path+_modules_utils_js__WEBPACK_IMPORTED_MODULE_0__.dirseparator+file.name+' size exceeds capacity. Chunk functionality not supported for the moment.'\n        }, _listener);\n    return endProcess() ;\n    // for the moment ecotaxaback does not support chunks\n      // removed by dead control flow\n\n      // removed by dead control flow\n\n      // removed by dead control flow\n\n    }\n    return chunknum;\n  }\n  async function getFile(filestream = null) {\n    filestream = (filestream === null) ? properties.filestream : filestream;\n    const file = await filestream.getFile();\n    return file;\n  }\n  async function sendZipFile(file, path, callbackchunk = null, bigfile = false) {\n  if(properties.counter.error>0) return endProcess();\n    const message = {\n      name: eventnames.pending,\n      bigfile:bigfile,\n      path: path\n    }\n    const formdata = new FormData();\n    path = path + ((path.slice(-1) === _modules_utils_js__WEBPACK_IMPORTED_MODULE_0__.dirseparator) ? `` : _modules_utils_js__WEBPACK_IMPORTED_MODULE_0__.dirseparator) + file.name;\n    formdata.append('path', path);\n    formdata.append('file', file, file.name);\n    if (properties.part) formdata.append('part', properties.part);\n    else if (callbackchunk !== null) formdata.append('ischunk', true);\n    message.path = path;\n    const response = await fetch(options.uploadurl, {\n      //  mode: 'cors',\n      method: \"POST\",\n      credentials: \"include\",\n      body: formdata,\n    });\n    const body=await response.text();\n      if (response.ok) {\n      if (callbackchunk) {\n        await callbackchunk();\n      } else { if(!bigfile || !properties.hashandlers)  await endFetch(message);\n       if (bigfile) {message.name=eventnames.follow;\n      _modules_module_event_emitter_js__WEBPACK_IMPORTED_MODULE_2__.ModuleEventEmitter.emit(eventnames.follow, message, _listener);\n      } }\n      } else {\n        properties.follow=null;\n        await endFetch(message);\n         properties.counter.error+=1;\n        onError(eventnames.errorfile, message); if(bigfile || properties.hashandlers) endProcess();    }\n  }\n  function endProcess() {\n    properties.follow=null;\n    onError(eventnames.errorfile,{\n            name: _modules_alert_box_js__WEBPACK_IMPORTED_MODULE_4__.AlertBox.alertconfig.types.error,\n            message: \"Upload not done. one or more files exceeds max upload size\",\n            path:uploadpath,\n            });\n    reset().then(() => {\n        _modules_module_event_emitter_js__WEBPACK_IMPORTED_MODULE_2__.ModuleEventEmitter.emit(eventnames.complete, {\n          name: eventnames.ready\n        }, _listener);\n        properties.endreaddir = false;  });\n    return false;\n    }\n  return {\n    uuid,\n    eventnames,\n    scanBrowse,\n    scanHandle,\n    quotaEstimate,\n    browserRequired\n  }\n}\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUFDQSxrQkFBa0IsMkRBQVE7QUFDMUI7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFFBQVEsZ0ZBQWtCO0FBQzFCO0FBQ0EsU0FBUztBQUNULHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvbW9kdWxlcy9maWxlcy9qcy1kaXJ0b3ppcC5qcz84NTM4Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcbmltcG9ydCB7XG4gIGZldGNoU2V0dGluZ3MsXG4gIGZvcm1hdF9ieXRlcyxcbiAgZGlyc2VwYXJhdG9yLFxuICBnZW5lcmF0ZV91dWlkXG59IGZyb20gJy4uLy4uL21vZHVsZXMvdXRpbHMuanMnO1xuXG5pbXBvcnQge1xuICBBc3luY0d6aXAsXG4gIFppcCxcbiAgQXN5bmNaaXBEZWZsYXRlLFxuICBaaXBQYXNzVGhyb3VnaCxcbiAgWmlwRGVmbGF0ZSxcbn0gZnJvbSAnZmZsYXRlJztcbmltcG9ydCB7XG4gIE1vZHVsZUV2ZW50RW1pdHRlclxufSBmcm9tICcuLi8uLi9tb2R1bGVzL21vZHVsZS1ldmVudC1lbWl0dGVyLmpzJztcbmltcG9ydCB7IGRldGVjdCB9IGZyb20gJ2RldGVjdC1icm93c2VyJztcbmltcG9ydCB7QWxlcnRCb3h9IGZyb20gJy4uLy4uL21vZHVsZXMvYWxlcnQtYm94LmpzJztcbmNvbnN0IGFscmVhZHlfY29tcHJlc3NlZCA9IG5ldyBTZXQoW1xuICAnemlwJywgJ2d6JywgJ3BuZycsICdqcGcnLCAnanBlZycsICdwZGYnLCAnZG9jJywgJ2RvY3gnLCAncHB0JywgJ3BwdHgnLFxuICAneGxzJywgJ3hsc3gnLCAnaGVpYycsICdoZWlmJywgJzd6JywgJ2J6MicsICdyYXInLCAnZ2lmJywgJ3dlYnAnLCAnd2VibScsXG4gICdtcDQnLCAnbW92JywgJ21wMycsICdhaWZjJ1xuXSk7XG5jb25zdCBjYW5fYmVfY29tcHJlc3NlZCA9IG5ldyBTZXQoWyd0c3YnLCd0eHQnLCdsb2cnLCdjc3YnXSk7XG5jb25zdCBhY2NlcHQgPSAnLnRzdiwucG5nLC5qcGcsIC5qcGVnLC56aXAsLmd6LC43eiwuYnoyJztcblxuZXhwb3J0IGZ1bmN0aW9uIEpzRGlyVG9aaXAob3B0aW9ucyA9IHt9KSB7XG4gIGNvbnN0IE1BWFNJWkUgPSAoZG9jdW1lbnQucXVlcnlTZWxlY3RvcignW2RhdGEtbWF4X3VwbG9hZF9zaXplXScpKT9wYXJzZUludChkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdbZGF0YS1tYXhfdXBsb2FkX3NpemVdJykuZGF0YXNldFsnbWF4X3VwbG9hZF9zaXplJ10pOjEwNzM3NDE4MjQ7Ly82ODE1NzQ0MDA7Ly82ODE1NzQ0MDA7IC8vIDY1ME0gLy8xMDczNzQxODI0OyAvLzQyOTQ5NjcyOTY7IC8vLy8gMzIyMTIyNTQ3MjsgLy8gMjE0NzQ4MzY0ODtcbiAgY29uc3QgVVBMT0FESU5QQVJUUyA9IChkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdbZGF0YS11cGxvYWRpbnBhcnRzXScpKT90cnVlOmZhbHNlO1xuICBjb25zdCBldmVudG5hbWVzID0ge1xuICAgIHJlYWR5OiAncmVhZHknLFxuICAgIGZvbGxvdzogJ2ZvbGxvdycsXG4gICAgY29tcGxldGU6ICdjb21wbGV0ZScsXG4gICAgZW5kcmVhZGRpcjogJ2VuZHJlYWRkaXInLFxuICAgIGd6aXA6ICdnemlwJyxcbiAgICBlbmR6aXA6ICdlbmR6aXAnLFxuICAgIHNlbmRmaWxlOiAnc2VuZGZpbGUnLFxuICAgIGJpZ2ZpbGU6ICdiaWdmaWxlJyxcbiAgICB0ZXJtaW5hdGU6ICd0ZXJtaW5hdGUnLFxuICAgIHBlbmRpbmc6ICdwZW5kaW5nJyxcbiAgICBlcnJvcmZpbGU6ICdlcnJvcmZpbGUnLFxuICAgIGNvdW50ZXI6ICdjb3VudGVyJyxcbiAgICByZWplY3Q6ICdyZWplY3QnLFxuICAgIG1lc3NhZ2U6ICdtZXNzYWdlJyxcbiAgICBlcnJvcjogJ2Vycm9yJyxcbiAgICBpbml0OiAnaW5pdCcsXG4gICAgc2V0dXBsb2FkcGF0aDonc2V0dXBsb2FkcGF0aCdcbiAgfTtcbiAgbGV0IGpzU2NhbkRpciwgcHJvcGVydGllcyx1cGxvYWRwYXRoO1xuICBsZXQgdHJ5ZGVsZXRlPTA7XG4gIGNvbnN0IGRlZmF1bHRPcHRpb25zID0ge1xuICAgIHVwbG9hZHVybDogJy9ndWkvZmlsZXMvdXBsb2FkJyxcbiAgICBsYXJnZWZpbGU6IE1BWFNJWkUsXG4gICAgYWNjZXB0OiBhY2NlcHQuc3BsaXQoJywnKVxuICB9XG4gIC8vIHVzZXMgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0ZpbGVfU3lzdGVtX0FQSS9PcmlnaW5fcHJpdmF0ZV9maWxlX3N5c3RlbVxuICAvLyMgYWx0ZXJuYXRpdmUgKG5vdCBzdXBwb3J0ZWQgaW4gU2FmYXJpKSBmb3IgLmNyZWF0ZVdyaXRhYmxlXG4gIG9wdGlvbnMgPSB7IC4uLmRlZmF1bHRPcHRpb25zLFxuICAgIC4uLm9wdGlvbnNcbiAgfTtcbiAgLy8gb3RoZXIgbW9kdWxlIHJlY2VpdmluZyBldmVudHNcbiAgY29uc3QgX2xpc3RlbmVyID0gKG9wdGlvbnMubGlzdGVuZXIpID8gb3B0aW9ucy5saXN0ZW5lciA6IHV1aWQ7XG4gIE9iamVjdC5mcmVlemUob3B0aW9ucyk7XG4gIGNvbnN0IHV1aWQgPSBnZW5lcmF0ZV91dWlkKCk7XG4gIGluaXRTdG9yYWdlKCk7XG4gIGluaXQoKTtcblxuZnVuY3Rpb24gYnJvd3NlclJlcXVpcmVkKCkge1xuY29uc3QgYnJvd3NlciA9IGRldGVjdCgpO1xuICAgICBjb25zdCBhY2NlcHRlZD17YW5kcm9pZDp7Y2hyb21lOjEwOSxvcGVyYTo3NCxmaXJlZm94OjExMSxzYW1zdW5nYnJvd3NlcjoyMSx3ZWJ2aWV3OjEwOX0sIGlvczpmYWxzZSxvdGhlcjp7Y2hyb21lOjg2LGVkZ2U6ODYsb3BlcmE6NzIsZmlyZWZveDoxMTF9fTtcbiAgICAgICAgbGV0IG9zID1icm93c2VyLm9zLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIG9zPShvcyBpbiBbJ2FuZHJvaWQnLCdpb3MnXSk/b3M6J290aGVyJztcbiAgICAgY29uc3QgbmFtZT1icm93c2VyLm5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgY29uc3QgdmVyc2lvbiA9IHBhcnNlSW50KGJyb3dzZXIudmVyc2lvbi5zcGxpdCgnLicpWzBdKTtcbiAgICAgaWYgKE9iamVjdC5rZXlzKGFjY2VwdGVkKS5pbmRleE9mKG9zKTwwIHx8IE9iamVjdC5rZXlzKGFjY2VwdGVkW29zXSkuaW5kZXhPZihuYW1lKTwwIHx8IHBhcnNlSW50KGFjY2VwdGVkW29zXVtuYW1lXSk+cGFyc2VJbnQodmVyc2lvbikpICB7XG4gICAgIE1vZHVsZUV2ZW50RW1pdHRlci5lbWl0KGV2ZW50bmFtZXMubWVzc2FnZSwge1xuICAgICAgICAgIGlkOiBcImJyb3dzZXJcIixcbiAgICAgICAgICBuYW1lOiBcImJyb3dzZXJcIixcbiAgICAgICAgICBtZXNzYWdlOiBcInlvdXIgYnJvd3NlciBkb2VzIG5vdCBoYXZlIGEgcmVxdWlyZWQgZnVuY3Rpb25uYWxpdHkuIFBsZWFzZSB1cGdyYWRlIG9yIHVzZSBhIHZhbGlkIGJyb3dzZXIgYW5kIHZlcnNpb24gOlwiKyAgSlNPTi5zdHJpbmdpZnkoYWNjZXB0ZWQpLnJlcGxhY2VBbGwoJ1wiJywnJyksXG4gICAgICAgIH0sIF9saXN0ZW5lcik7XG4gICAgIH1cbiAgICAgfVxuICBmdW5jdGlvbiBpbml0KCkge1xuICAgIHByb3BlcnRpZXMgPSBpbml0UHJvcHMoKTtcbiAgICAgTW9kdWxlRXZlbnRFbWl0dGVyLm9uKGV2ZW50bmFtZXMuc2V0dXBsb2FkcGF0aCwgYXN5bmMoZSkgPT4ge1xuICAgIHVwbG9hZHBhdGg9ZS5wYXRoO30sdXVpZCk7XG4gICAgTW9kdWxlRXZlbnRFbWl0dGVyLm9uKGV2ZW50bmFtZXMuaW5pdCwgYXN5bmMgKGUpID0+IHtcbiAgICAgIGlmICghaXNBY3RpdmUoKSkge1xuICAgICAgICBhd2FpdCByZXNldCgpO1xuICAgICAgICBNb2R1bGVFdmVudEVtaXR0ZXIuZW1pdChldmVudG5hbWVzLmNvbXBsZXRlLCB7XG4gICAgICAgICAgbmFtZTogZXZlbnRuYW1lcy5yZWFkeVxuICAgICAgICB9LCBfbGlzdGVuZXIpO1xuICAgICAgICAgIE1vZHVsZUV2ZW50RW1pdHRlci5lbWl0KGV2ZW50bmFtZXMubWVzc2FnZSwge1xuICAgICAgICAgIG5hbWU6IEFsZXJ0Qm94LmFsZXJ0Y29uZmlnLnR5cGVzLnN1Y2Nlc3MsXG4gICAgICAgICAgbWVzc2FnZTogXCJVcGxvYWQgb2YgXCIrIGUucGF0aCArXCIgaXMgZG9uZVwiLFxuICAgICAgICB9LCBfbGlzdGVuZXIpO1xuICAgICAgICBwcm9wZXJ0aWVzLmVuZHJlYWRkaXIgPSBmYWxzZTtcbiAgICAgIH0gZWxzZSBjb25zb2xlLmxvZygncGFydGx5IGZpbmlzaGVkICcrcHJvcGVydGllcy5oYXNoYW5kbGVycysgJ2ZvbGxvdz0nK3Byb3BlcnRpZXMuZm9sbG93LCBlKTtcbiAgICB9LCB1dWlkKTtcbiAgICBNb2R1bGVFdmVudEVtaXR0ZXIub24oZXZlbnRuYW1lcy5lbmR6aXAsIGFzeW5jKGUpID0+IHtcbiAgICAgIGlmICghZS5iaWdmaWxlICYmIHByb3BlcnRpZXMuemlwKSBwcm9wZXJ0aWVzLnppcC5lbmQoKTtcbiAgICAgIGNvbnN0IGV2dHNlbmQ9YXN5bmMgZnVuY3Rpb24oKSB7XG4gICAgICBjb25zdCB6aXBjbG9zZWQgPSBhd2FpdCBsaXN0U3RvcmFnZShudWxsLHByb3BlcnRpZXMuemlwbmFtZSk7XG4gICAgICBpZiAoemlwY2xvc2VkID09PSB0cnVlKSB7XG4gICAgICBjb25zdCBtZXNzYWdlID0gYnVpbGRNZXNzYWdlKGUsIHtcbiAgICAgICAgbmFtZTogZXZlbnRuYW1lcy5zZW5kZmlsZSwgICAgICB9KTtcblxuICAgICAgTW9kdWxlRXZlbnRFbWl0dGVyLmVtaXQoZXZlbnRuYW1lcy5jb21wbGV0ZSwgbWVzc2FnZSwgX2xpc3RlbmVyKTt9XG4gICAgICBlbHNlIHNldFRpbWVvdXQoYXN5bmMgZnVuY3Rpb24oKSB7YXdhaXQgZXZ0c2VuZCgpO30sMjAwMCk7fVxuICAgICAgZXZ0c2VuZCgpO1xuICAgIH0sIHV1aWQpO1xuICAgIE1vZHVsZUV2ZW50RW1pdHRlci5vbihldmVudG5hbWVzLnNlbmRmaWxlLCBhc3luYyAoZSkgPT4ge1xuICAgICAgaWYgKHByb3BlcnRpZXMuaGFzaGFuZGxlcnMpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGJ1aWxkTWVzc2FnZShlLCB7XG4gICAgICAgICAgICBuYW1lOiBldmVudG5hbWVzLmZvbGxvdyxcbiAgICAgICAgfSk7XG4gICAgICAgIE1vZHVsZUV2ZW50RW1pdHRlci5lbWl0KGV2ZW50bmFtZXMuZm9sbG93LCBtZXNzYWdlLCBfbGlzdGVuZXIpO1xuICAgICAgICBhd2FpdCBleGVjSGFuZGxlcigpO1xuICAgICAgfSBlbHNlIHsgY29uc3QgbWVzc2FnZSA9IGJ1aWxkTWVzc2FnZShlLCB7XG4gICAgICAgIG5hbWU6IGV2ZW50bmFtZXMucGVuZGluZyxcbiAgICAgIH0pO1xuXG4gICAgICAgIE1vZHVsZUV2ZW50RW1pdHRlci5lbWl0KGV2ZW50bmFtZXMuY29tcGxldGUsIG1lc3NhZ2UsIF9saXN0ZW5lcik7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGZpbGUgPSBhd2FpdCBnZXRGaWxlKCk7XG4gICAgICBzZW5kWmlwRmlsZShmaWxlLCAoZS5wYXRoID8gZS5wYXRoIDogdXBsb2FkcGF0aCksIG51bGwpO1xuICAgIH0sIHV1aWQpO1xuICAgIE1vZHVsZUV2ZW50RW1pdHRlci5vbihldmVudG5hbWVzLmVuZHJlYWRkaXIsIChlKSA9PiB7XG4gICAgICBwcm9wZXJ0aWVzLmVuZHJlYWRkaXIgPSB0cnVlO1xuICAgICAgY2hlY2tQcm9jZXNzZWQoZSk7XG4gICAgfSwgdXVpZCk7XG4gICAgTW9kdWxlRXZlbnRFbWl0dGVyLm9uKGV2ZW50bmFtZXMuY291bnRlciwgYXN5bmMgKGUpID0+IHtcbiAgICAgIHByb3BlcnRpZXMuZW5kY291bnRlciA9IGZhbHNlO1xuICAgICAgcHJvcGVydGllcy5jb3VudGVyW2UubmFtZV0gKz0gMTtcbiAgICAgIE1vZHVsZUV2ZW50RW1pdHRlci5lbWl0KGV2ZW50bmFtZXMuY291bnRlciwgZSwgX2xpc3RlbmVyKTtcbiAgICAgIGlmIChlLm5hbWUgPT09ICd6aXAnICYmIHByb3BlcnRpZXMuY291bnRlci5zY2FuID09PSBwcm9wZXJ0aWVzLmNvdW50ZXIuemlwKSB7XG4gICAgICAgIHByb3BlcnRpZXMuZW5kY291bnRlciA9IHRydWU7XG4gICAgICAgIGNoZWNrUHJvY2Vzc2VkKGUpO1xuICAgICAgfVxuICAgICAgaWYgKGUubmFtZSA9PT0gJ3ppcCcgJiYgcHJvcGVydGllcy5jYWxsYmFjaykgYXdhaXQgcHJvcGVydGllcy5jYWxsYmFjaygpO1xuICAgIH0sIHV1aWQpO1xuICAgIE1vZHVsZUV2ZW50RW1pdHRlci5vbihldmVudG5hbWVzLmVycm9yLCAgKGUpID0+IHt9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGluaXRQcm9wcygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgemlwOiBudWxsLFxuICAgICAgemlwbmFtZTogbnVsbCxcbiAgICAgIGZpbGVzdHJlYW06IG51bGwsXG4gICAgICBzdHJlYW1oYW5kbGU6IG51bGwsXG4gICAgICBnemlwcGVkOiBudWxsLFxuICAgICAgc2l6ZXRvemlwOiAwLFxuICAgICAgcGFydDogMCxcbiAgICAgIGZvbGxvdzogbnVsbCxcbiAgICAgIGVuZGNvdW50ZXI6IGZhbHNlLFxuICAgICAgZW5kcmVhZGRpcjogZmFsc2UsXG4gICAgICBjYWxsYmFjazogbnVsbCxcbiAgICAgIHBvczogMCxcbiAgICAgIGNvdW50ZXI6IHtcbiAgICAgICAgc2NhbjogMCxcbiAgICAgICAgemlwOiAwLFxuICAgICAgICByZWplY3Q6IDAsXG4gICAgICAgIGVycm9yOjAsXG4gICAgICB9LFxuICAgICAgaGFuZGxlcnM6IFtdLFxuICAgICAgaGFzaGFuZGxlcnM6ZmFsc2UsXG4gICAgIH1cbiAgfVxuICBhc3luYyBmdW5jdGlvbiByZXNldCgpIHtcbiAgICBwcm9wZXJ0aWVzID0gaW5pdFByb3BzKCk7XG4gICAgYXdhaXQgaW5pdFN0b3JhZ2UoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzQWN0aXZlKCkge1xuICAgIHJldHVybiAocHJvcGVydGllcy56aXAgIT09IG51bGwgfHwgcHJvcGVydGllcy5mb2xsb3cgIT09IG51bGwgfHwgcHJvcGVydGllcy5oYXNoYW5kbGVycyB8fCBwcm9wZXJ0aWVzLmVuZHJlYWRkaXIgIT09IHRydWUpO1xuICB9XG5cbiAgYXN5bmMgZnVuY3Rpb24gaW5pdFppcCgpIHtcbiAgICBwcm9wZXJ0aWVzLnBvcyA9IDA7XG4gICAgcHJvcGVydGllcy5zaXpldG96aXAgPSAwO1xuICAgIHByb3BlcnRpZXMuemlwID0gbmV3IFppcCgoZXJyb3IsIGNodW5rLCBmaW5hbCkgPT4ge1xuICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgIG9uRXJyb3IoZXZlbnRuYW1lcy5lcnJvcmZpbGUsIHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiBlcnJvcn0sIF9saXN0ZW5lcik7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHByb3BlcnRpZXMuc3RyZWFtaGFuZGxlLndyaXRlKGNodW5rLCB7XG4gICAgICAgICAgYXQ6IHNlbGYucG9zXG4gICAgICAgIH0pO1xuICAgICAgICBwcm9wZXJ0aWVzLnBvcyArPSBjaHVuay5sZW5ndGg7XG4gICAgICAgIGlmIChmaW5hbCkge1xuICAgICAgICAgIHByb3BlcnRpZXMuc3RyZWFtaGFuZGxlLmNsb3NlKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgICAvLyBoYWNrIGZvciBtZW1vcnkgdXNhZ2VcbiAgICB6aXBPbkRhdGEoKTtcbiAgICBpZiAocHJvcGVydGllcy5mb2xsb3cpIGF3YWl0IHByb3BlcnRpZXMuZm9sbG93KCk7XG4gIH1cblxuICBmdW5jdGlvbiBjaGVja1Byb2Nlc3NlZChlKSB7XG4gICAgaWYgKHByb3BlcnRpZXMuZW5kcmVhZGRpciA9PT0gdHJ1ZSkge1xuICAgIGlmKHByb3BlcnRpZXMuZW5kY291bnRlciA9PT0gdHJ1ZSkge1xuICAgICAgY29uc3QgbWVzc2FnZSA9IGJ1aWxkTWVzc2FnZShlLCB7XG4gICAgICAgbmFtZTogZXZlbnRuYW1lcy5lbmR6aXBcbiAgICAgIH0pO1xuICAgICAgTW9kdWxlRXZlbnRFbWl0dGVyLmVtaXQoZXZlbnRuYW1lcy5jb21wbGV0ZSwgbWVzc2FnZSwgX2xpc3RlbmVyKTtcbiAgICB9ICBlbHNlIGlmIChwcm9wZXJ0aWVzLmNvdW50ZXIuZXJyb3I+MCkgZW5kUHJvY2VzcygpO31cbiAgfVxuXG4gIGZ1bmN0aW9uIHppcE9uRGF0YSh6aXAgPSBudWxsKSB7XG4gICAgemlwID0gKHppcCA9PT0gbnVsbCkgPyBwcm9wZXJ0aWVzLnppcCA6IHppcDtcbiAgICBjb25zdCBvbmRhdGEgPSB6aXAub25kYXRhO1xuICAgIHppcC5vbmRhdGEgPSAoZXJyb3IsIGRhdGEsIGZpbmFsKSA9PiB7XG4gICAgICBvbmRhdGEoZXJyb3IsIGRhdGEsIGZpbmFsKTtcbiAgICAgIGlmIChmaW5hbCkge1xuICAgICAgICB6aXAuZCA9IG51bGw7XG4gICAgICAgIGlmICh6aXAudSAmJiB6aXAudS5hdCgtMSkpIHppcC51LmF0KC0xKS5kID0gbnVsbDsgLy8gT2JqZWN0IGNyZWF0ZWQgaW4gYHppcC5hZGQoKWBcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBidWlsZE1lc3NhZ2UoZSwgbWVzc2FnZSA9IHt9KSB7XG4gICAgaWYgKGUuaGFzT3duUHJvcGVydHkoXCJwYXJ0XCIpKSB7XG4gICAgICBtZXNzYWdlLnBhcnQgPSBlLnBhcnQ7XG4gICAgfSBlbHNlIHByb3BlcnRpZXMucGFydCA9IDA7XG4gICAgaWYgKGUuaGFzT3duUHJvcGVydHkoXCJiaWdmaWxlXCIpKSBtZXNzYWdlLmJpZ2ZpbGUgPSBlLmJpZ2ZpbGU7XG4gICAgaWYgKGUuaGFzT3duUHJvcGVydHkoXCJwYXRoXCIpKSBtZXNzYWdlLnBhdGggPSBlLnBhdGg7XG4gICAgcmV0dXJuIG1lc3NhZ2U7XG4gIH1cblxuICBhc3luYyBmdW5jdGlvbiBxdW90YUVzdGltYXRlKCkge1xuICAgIGlmIChuYXZpZ2F0b3IgJiYgbmF2aWdhdG9yLnN0b3JhZ2UgJiYgbmF2aWdhdG9yLnN0b3JhZ2UuZXN0aW1hdGUpIHtcbiAgICAgIG5hdmlnYXRvci5zdG9yYWdlLmVzdGltYXRlKCkudGhlbigocXVvdGEpID0+IHtcbiAgICAgICAgY29uc3QgcGVyY2VudGFnZVVzZWQgPSAoKHF1b3RhLnVzYWdlIC8gcXVvdGEucXVvdGEpICogMTAwKS50b0ZpeGVkKDIpO1xuICAgICAgICBjb25zdCByZW1haW5pbmcgPSBmb3JtYXRfYnl0ZXMocXVvdGEucXVvdGEgLSBxdW90YS51c2FnZSk7XG4gICAgICAgIE1vZHVsZUV2ZW50RW1pdHRlci5lbWl0KGV2ZW50bmFtZXMubWVzc2FnZSwge1xuICAgICAgICAgIGlkOiBcInF1b3RhXCIsXG4gICAgICAgICAgbmFtZTogXCJjb25zb2xlXCIsXG4gICAgICAgICAgbWVzc2FnZTogXCJ5b3UndmUgdXNlZCBcIiArIHBlcmNlbnRhZ2VVc2VkICsgXCIlIG9mIHRoZSBhdmFpbGFibGUgYnJvd3NlciBzdG9yYWdlIG5lY2Vzc2FyeSB0byBsb2NhbGx5IGNvbXByZXNzIGZpbGVzIChcIiArIHJlbWFpbmluZyArIFwiKS5cIixcbiAgICAgICAgfSwgX2xpc3RlbmVyKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIGFzeW5jIGZ1bmN0aW9uIGluaXRTdG9yYWdlKCkge1xuICAgIGlmIChuYXZpZ2F0b3IgJiYgbmF2aWdhdG9yLnN0b3JhZ2UgJiYgbmF2aWdhdG9yLnN0b3JhZ2UuZXN0aW1hdGUpIHtcbiAgICAgIGF3YWl0IGNsZWFuU3RvcmFnZSgpO1xuICAgICAgcXVvdGFFc3RpbWF0ZSgpO1xuICAgIH0gZWxzZSBNb2R1bGVFdmVudEVtaXR0ZXIuZW1pdChldmVudG5hbWVzLm1lc3NhZ2UsIHtcbiAgICAgIG5hbWU6IFwiZXJyb3JcIixcbiAgICAgIG1lc3NhZ2U6IFwibm8gbmF2aWdhdG9yIHN0b3JhZ2VcIlxuICAgIH0sIHV1aWQpO1xuICB9XG5cbiAgYXN5bmMgZnVuY3Rpb24gY3JlYXRlTG9jYWxTdHJlYW0obmFtZSwgYWNjZXB0ID0ge1xuICAgICdhcHBsaWNhdGlvbi96aXAnOiBbJy56aXAnXSxcbiAgfSkge1xuICAgIGNvbnN0IHJvb3QgPSBhd2FpdCBuYXZpZ2F0b3Iuc3RvcmFnZS5nZXREaXJlY3RvcnkoKTtcbiAgICBjb25zdCBvcHRzID0ge1xuICAgICAgdHlwZXM6IFt7XG4gICAgICAgIGRlc2NyaXB0aW9uOiAnVGVtcCBmaWxlJyxcbiAgICAgICAgYWNjZXB0OiBhY2NlcHQsXG4gICAgICB9LCBdLFxuICAgICAgY3JlYXRlOiB0cnVlXG4gICAgfTtcbiAgICBjb25zdCBmaWxlc3RyZWFtID0gYXdhaXQgcm9vdC5nZXRGaWxlSGFuZGxlKG5hbWUsIG9wdHMpO1xuICAgIGNvbnN0IHN0cmVhbWhhbmRsZSA9IGF3YWl0IGZpbGVzdHJlYW0uY3JlYXRlV3JpdGFibGUoe21vZGU6XCJleGNsdXNpdmVcIn0pO1xuICAgIHJldHVybiB7XG4gICAgICBmaWxlc3RyZWFtLFxuICAgICAgc3RyZWFtaGFuZGxlXG4gICAgfTtcbiAgfVxuICBhc3luYyBmdW5jdGlvbiBzY2FuQ29tbW9uKHppcG5hbWUsIG9wdGlvbnMgPSB7fSkge1xuICAgIHByb3BlcnRpZXMuZW5kcmVhZGRpciA9IGZhbHNlO1xuICAgIGlmIChwcm9wZXJ0aWVzLnppcCA9PT0gbnVsbCkge1xuICAgICAgemlwbmFtZSA9IHppcG5hbWUuc3BsaXQoZGlyc2VwYXJhdG9yKVswXTtcbiAgICAgIHppcG5hbWUgPSAoemlwbmFtZS50cmltKCkgPT09IGBgKSA/ICd0ZW1wJyA6IHppcG5hbWU7XG4gICAgICBjb25zdCB0eXBlID0gKG9wdGlvbnMgJiYgb3B0aW9ucy50eXBlKSA/IG9wdGlvbnMudHlwZSA6ICcuemlwJztcbiAgICAgIHByb3BlcnRpZXMuemlwbmFtZSA9ICgob3B0aW9ucy56aXBuYW1lKSA/IG9wdGlvbnMuemlwbmFtZSA6IHppcG5hbWUpICsgdHlwZTsgLy9cbiAgICAgIGNvbnN0IHppcGluc3RvcmFnZSA9IGF3YWl0IHNlYXJjaFN0b3JhZ2UocHJvcGVydGllcy56aXBuYW1lKTtcbiAgICAgIGlmICh6aXBpbnN0b3JhZ2UpIHByb3BlcnRpZXMuemlwbmFtZSA9ICcxXycgKyBwcm9wZXJ0aWVzLnppcG5hbWU7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGZpbGVzdHJlYW0sXG4gICAgICAgIHN0cmVhbWhhbmRsZVxuICAgICAgfSA9IGF3YWl0IGNyZWF0ZUxvY2FsU3RyZWFtKHByb3BlcnRpZXMuemlwbmFtZSk7XG4gICAgICBwcm9wZXJ0aWVzLmZpbGVzdHJlYW0gPSBmaWxlc3RyZWFtO1xuICAgICAgcHJvcGVydGllcy5zdHJlYW1oYW5kbGUgPSBzdHJlYW1oYW5kbGU7XG4gICAgICBsZXQgc2l6ZSA9IDA7XG4gICAgICBwcm9wZXJ0aWVzLnBhcnQgPSAwO1xuICAgICAgYXdhaXQgaW5pdFppcCgpO1xuICAgICAgaWYgKCFqc1NjYW5EaXIpIHtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIEpzU2NhbkRpclxuICAgICAgICB9ID0gYXdhaXQgaW1wb3J0KCcuLi9maWxlcy9qcy1zY2FuZGlyLmpzJyk7XG4gICAgICAgIGNvbnN0IHByb2Nlc3NfZmlsZSA9IGFzeW5jIChlbnRyeSwgY2FsbGJhY2spID0+IHtcbiAgICAgICAgICBpZiAoYWNjZXB0RmlsZShlbnRyeSkpIHtcbiAgICAgICAgICAgIHByb3BlcnRpZXMuY2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICAgICAgICAgIGF3YWl0IHByb2Nlc3NGaWxlKGVudHJ5KTtcbiAgICAgICAgICB9IGVsc2UgcmVqZWN0RmlsZShlbnRyeSwgY2FsbGJhY2spO1xuICAgICAgICB9XG4gICAgICAgIGpzU2NhbkRpciA9IEpzU2NhbkRpcihwcm9jZXNzX2ZpbGUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGFzeW5jIGZ1bmN0aW9uIHNjYW5Ccm93c2UocGljaywgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgZW50cmllcyA9IChwaWNrIGluc3RhbmNlb2YgRmlsZUxpc3QpID8gQXJyYXkuZnJvbShwaWNrKSA6IChwaWNrLmtpbmQgPT09IFwiZGlyZWN0b3J5XCIpID8gYXdhaXQgQXJyYXkuZnJvbUFzeW5jKHBpY2sudmFsdWVzKCkpOiAoQXJyYXkuaXNBcnJheShwaWNrKSkgPyBwaWNrIDogW3BpY2tdO1xuICAgIGNvbnN0IG5hbWUgPSBlbnRyaWVzWzBdLm5hbWU7XG4gICAgbGV0IHJlbHBhdGggPSAocGljayBpbnN0YW5jZW9mIEZpbGVMaXN0KSA/IGVudHJpZXNbMF0ud2Via2l0UmVsYXRpdmVQYXRoIDogbnVsbDtcbiAgICByZWxwYXRoID0gKHJlbHBhdGgpID8gcmVscGF0aC5zcGxpdChkaXJzZXBhcmF0b3IpIDogW2BgXTtcbiAgICBpZiAocmVscGF0aC5sZW5ndGgpIHJlbHBhdGgucG9wKCk7XG4gICAgcmVscGF0aCA9IHJlbHBhdGguam9pbihkaXJzZXBhcmF0b3IpO1xuICAgIGNvbnN0IHBhdGggPSAocGljayBpbnN0YW5jZW9mIEZpbGVMaXN0KSA/IHJlbHBhdGggOiAocGljay5raW5kID09PSBcImRpcmVjdG9yeVwiKSA/IHBpY2submFtZSA6IGBgO1xuICAgIGF3YWl0IHNjYW5Db21tb24ocGF0aCwgb3B0aW9ucyk7XG4gICAgYXdhaXQganNTY2FuRGlyLnByb2Nlc3NFbnRyaWVzKGVudHJpZXMsIHBhdGgsICgpID0+IHtcbiAgICAgIGRpckNvbXBsZXRlKCk7XG4gICAgfSk7XG4gIH1cblxuICBhc3luYyBmdW5jdGlvbiBzY2FuSGFuZGxlKGRyb3BwZWQsIG9wdGlvbnMgPSB7fSkge1xuICAgIGF3YWl0IHNjYW5Db21tb24oZHJvcHBlZC5uYW1lLCBvcHRpb25zKTtcbiAgICBpZiAoZHJvcHBlZC5pc0RpcmVjdG9yeSA9PT0gdHJ1ZSkge1xuICAgICAgYXdhaXQganNTY2FuRGlyLnJlYWREaXJlY3RvcnkoZHJvcHBlZCwgKCkgPT4ge1xuICAgICAgICBkaXJDb21wbGV0ZSgpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChkcm9wcGVkLmlzRmlsZSA9PT0gdHJ1ZSkge1xuICAgICAgYXdhaXQganNTY2FuRGlyLnByb2Nlc3NGaWxlKGRyb3BwZWQsICgpID0+IHtcbiAgICAgICAgZGlyQ29tcGxldGUoKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGRpckNvbXBsZXRlKCkge1xuICAgIE1vZHVsZUV2ZW50RW1pdHRlci5lbWl0KGV2ZW50bmFtZXMuZW5kcmVhZGRpciwge1xuICAgICAgbmFtZTogZXZlbnRuYW1lcy5lbmRyZWFkZGlyXG4gICAgfSwgdXVpZCk7XG4gIH1cblxuICBmdW5jdGlvbiBhZGRIYW5kbGVyKGhhbmRsZXIpIHtcbiAgICBwcm9wZXJ0aWVzLmhhbmRsZXJzLnB1c2goaGFuZGxlcik7XG4gICAgcHJvcGVydGllcy5oYXNoYW5kbGVycz0gKHByb3BlcnRpZXMuaGFuZGxlcnMubGVuZ3RoPjApXG4gIH1cblxuICBhc3luYyBmdW5jdGlvbiBleGVjSGFuZGxlcigpIHtcbiAgICAvLyBzZXJpZVxuICAgIGlmIChwcm9wZXJ0aWVzLmhhc2hhbmRsZXJzKSB7XG4gICAgICBjb25zdCBoYW5kbGVyID0gcHJvcGVydGllcy5oYW5kbGVycy5zaGlmdCgpO1xuICAgICAgYXdhaXQgaGFuZGxlcigpO1xuICAgICBwcm9wZXJ0aWVzLmhhc2hhbmRsZXJzID0gKHByb3BlcnRpZXMuaGFuZGxlcnMubGVuZ3RoPjApXG4gICAgfVxuICAgIHJldHVybjtcbiAgfVxuICAgIGFzeW5jIGZ1bmN0aW9uIGd6aXBCaWdGaWxlKGZpbGUsIGZpbGVwYXRoKSB7XG4gICAgbGV0IGR0ID0gRGF0ZS5ub3coKTtcbiAgICBmaWxlcGF0aCA9IChmaWxlcGF0aC5pbmRleE9mKGRpcnNlcGFyYXRvcikgPT09IDApID8gZmlsZXBhdGguc3Vic3RyKDEpIDogZmlsZXBhdGg7XG4gICAgY29uc3QgcGFydHMgPSBmaWxlcGF0aC5zcGxpdChkaXJzZXBhcmF0b3IpO1xuICAgIHBhcnRzLnBvcCgpO1xuICAgIGNvbnN0IHNlbmRwYXRoID0gdXBsb2FkcGF0aCArIGRpcnNlcGFyYXRvciArcGFydHMuam9pbihkaXJzZXBhcmF0b3IpO1xuICAgIGNvbnN0IGV4dCA9IGZpbGUubmFtZS5zbGljZShmaWxlLm5hbWUubGFzdEluZGV4T2YoJy4nKSArIDEpO1xuICAgIGlmIChhbHJlYWR5X2NvbXByZXNzZWQuaGFzKGV4dCkpIHtcbiAgICAgICBNb2R1bGVFdmVudEVtaXR0ZXIuZW1pdChldmVudG5hbWVzLmNvdW50ZXIsIHtcbiAgICAgICAgbmFtZTogJ3ppcCcsXG4gICAgICAgIHBhdGg6IGZpbGVwYXRoLFxuICAgICAgICBiaWdmaWxlOmZpbGUubmFtZSxcbiAgICAgICAgc2l6ZTogZmlsZS5zaXplXG4gICAgICB9LCB1dWlkKTtcbiAgICAgIGFkZEhhbmRsZXIoYXN5bmMgKCkgPT4ge1xuICAgICAgICBhd2FpdCBzZW5kQ2h1bmsoc2VuZHBhdGgsZmlsZSk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IHppcG5hbWUgPSBmaWxlLm5hbWUgKyAnLmd6JztcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgZmlsZXN0cmVhbSxcbiAgICAgICAgc3RyZWFtaGFuZGxlXG4gICAgICB9ID0gYXdhaXQgY3JlYXRlTG9jYWxTdHJlYW0oemlwbmFtZSwge1xuICAgICAgICAnYXBwbGljYXRpb24vZ3ppcCc6IFsnLmd6J10sXG4gICAgICB9KTtcbiAgICAgIGxldCBwb3MgPSAwO1xuXG4gICAgICBjb25zdCBnemlwcGVkID0gbmV3IEFzeW5jR3ppcCh7XG4gICAgICAgIGxldmVsOiA2LFxuICAgICAgICBmaWxlbmFtZTogZmlsZXBhdGhcbiAgICAgIH0pO1xuICAgICAgZ3ppcHBlZC5vbmRhdGEgPSAoZXJyLCBkYXRhLCBmaW5hbCkgPT4ge1xuICAgICAgIGlmKHBvcyA+IE1BWFNJWkUpICB7XG4gICAgICAgICAgICAgICAgcHJvcGVydGllcy5jb3VudGVyLmVycm9yKz0xO1xuICAgICAgICAgICAgICBvbkVycm9yKEFsZXJ0Qm94LmFsZXJ0Y29uZmlnLnR5cGVzLmVycm9yLCB7XG5cbiAgICAgICAgICAgICAgICBuYW1lOkFsZXJ0Qm94LmFsZXJ0Y29uZmlnLnR5cGVzLmVycm9yLFxuICAgICAgICAgICAgICAgIGJpZ2ZpbGU6ZmlsZS5uYW1lLFxuICAgICAgICAgICAgICAgIHBhdGg6ZmlsZXBhdGgsXG4gICAgICAgICAgICAgICAgbWVzc2FnZTonRmlsZSAnK2ZpbGUubmFtZSsnIHNpemUgZXhjZWVkcyBtYXhzaXplLiBDYW5ub3QgYmUgc2VudCBpbiBjaHVua3MgZm9yIHRoZSBtb21lbnQuJ30sIF9saXN0ZW5lcik7XG4gICAgICAgICAgc3RyZWFtaGFuZGxlLmNsb3NlKCk7Z3ppcHBlZC5vbmRhdGE9IChlcnIsIGRhdGEsIGZpbmFsKSA9PiB7fTsgcmV0dXJuIGVuZFByb2Nlc3MoKTtcbiAgICAgICAgICB9XG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgIHByb3BlcnRpZXMuY291bnRlci5lcnJvcis9MTtcbiAgICAgICAgICBvbkVycm9yKEFsZXJ0Qm94LmFsZXJ0Y29uZmlnLnR5cGVzLmVycm9yLCB7XG4gICAgICAgICAgICBuYW1lOkFsZXJ0Qm94LmFsZXJ0Y29uZmlnLnR5cGVzLmVycm9yLFxuICAgICAgICAgICAgYmlnZmlsZTogZmlsZS5uYW1lLFxuICAgICAgICAgICAgcGF0aDogZmlsZXBhdGgsXG4gICAgICAgICAgICBzaXplOiBmaWxlLnNpemUsXG4gICAgICAgICAgICBtZXNzYWdlOiAnRXJyb3IgY29tcHJlc3NpbmcgZmlsZSAnKyBmaWxlLm5hbWUgKycgJytlcnJcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdHJlYW1oYW5kbGUud3JpdGUoZGF0YSwge1xuICAgICAgICAgICAgYXQ6IHBvc1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHBvcyArPSBkYXRhLmxlbmd0aDtcbiAgICAgICAgICBpZiAoZmluYWwpIHtcbiAgICAgICAgICAgIHN0cmVhbWhhbmRsZS5jbG9zZSgpO1xuICAgICAgICAgICAgICAgICBmaWxlcGF0aCs9Jy5neic7XG4gICAgICAgICAgICAgICAgTW9kdWxlRXZlbnRFbWl0dGVyLmVtaXQoZXZlbnRuYW1lcy5jb3VudGVyLCB7XG4gICAgICAgICAgICAgIG5hbWU6ICd6aXAnLFxuICAgICAgICAgICAgICBwYXRoOiBmaWxlcGF0aCxcbiAgICAgICAgICAgICAgc2l6ZTogZmlsZS5zaXplLFxuICAgICAgICAgICAgICBiaWdmaWxlOmZpbGUubmFtZVxuICAgICAgICAgICAgfSwgdXVpZCk7XG5cbiAgICAgICAgIGFkZEhhbmRsZXIoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgYXdhaXQgc2VuZENodW5rKHNlbmRwYXRoLGZpbGVzdHJlYW0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgY29uc3QgY291bnQgPSBmYWxzZTtcbiAgICAgIGF3YWl0IHJlYWRGaWxlKGZpbGUsIGZpbGVwYXRoLCBnemlwcGVkLCBjb3VudCk7XG4gICAgfVxuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIHBhcnRaaXAoKSB7XG4gICAgcHJvcGVydGllcy5wYXJ0ICs9IDE7XG4gICAgTW9kdWxlRXZlbnRFbWl0dGVyLmVtaXQoZXZlbnRuYW1lcy5jb21wbGV0ZSwge1xuICAgICBuYW1lOiBldmVudG5hbWVzLmVuZHppcCxcbiAgICAgIHBhcnQ6IHByb3BlcnRpZXMucGFydFxuICAgIH0sIF9saXN0ZW5lcik7XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gcmVhZEZpbGUoZmlsZSwgZmlsZXBhdGgsIHppcHBlZHN0cmVhbSwgY291bnQgPSB0cnVlKSB7XG4gICAgY29uc3QgcmVhZGVyID0gZmlsZS5zdHJlYW0oKS5nZXRSZWFkZXIoKTtcbiAgICBsZXQgcGF1c2UgPSBmYWxzZTtcbiAgICAvKiAgb25CYWNrcHJlc3N1cmUoemlwcGVkc3RyZWFtLCB0aGlzLnN0cmVhbWhhbmRsZSwgc2hvdWxkX2FwcGx5X2JhY2twcmVzc3VyZSA9PiB7XG4gICAgICAgIGlmIChzaG91bGRfYXBwbHlfYmFja3ByZXNzdXJlKSBwYXVzZSA9IHRydWU7XG4gICAgICAgIGVsc2UgaWYgKHBhdXNlKSBwYXVzZSA9IGZhbHNlO1xuICAgICAgfSk7Ki9cbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgY29uc3Qge1xuICAgICAgICBkb25lLFxuICAgICAgICB2YWx1ZVxuICAgICAgfSA9IGF3YWl0IHJlYWRlci5yZWFkKCk7XG4gICAgICBpZiAoZG9uZSkge1xuICAgICAgICB6aXBwZWRzdHJlYW0ucHVzaChuZXcgVWludDhBcnJheSgwKSwgdHJ1ZSk7XG4gICAgICAgIGlmIChjb3VudCA9PT0gdHJ1ZSkgTW9kdWxlRXZlbnRFbWl0dGVyLmVtaXQoZXZlbnRuYW1lcy5jb3VudGVyLCB7XG4gICAgICAgICAgbmFtZTogJ3ppcCcsXG4gICAgICAgICAgcGF0aDogZmlsZXBhdGgsXG4gICAgICAgICAgc2l6ZTogKHppcHBlZHN0cmVhbS5zaXplKSA/IHppcHBlZHN0cmVhbS5zaXplIDogZmlsZS5zaXplXG4gICAgICAgIH0sIHV1aWQpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIHppcHBlZHN0cmVhbS5wdXNoKHZhbHVlKTtcbiAgICB9XG4gIH1cblxuICBhc3luYyBmdW5jdGlvbiB6aXBTdHJlYW0oZmlsZSwgZmlsZXBhdGgpIHtcbiAgICBjb25zdCBleHQgPSBmaWxlcGF0aC5zbGljZShmaWxlcGF0aC5sYXN0SW5kZXhPZignLicpICsgMSk7XG4gICAgY29uc3QgaXNjb21wcmVzc2VkID0gYWxyZWFkeV9jb21wcmVzc2VkLmhhcyhleHQpO1xuICAgIGNvbnN0IHppcHBlZHN0cmVhbSA9IChpc2NvbXByZXNzZWQpID8gbmV3IFppcFBhc3NUaHJvdWdoKGZpbGVwYXRoKSA6IGZpbGUuc2l6ZSA+IG9wdGlvbnMubGFyZ2VmaWxlID9cbiAgICAgIG5ldyBBc3luY1ppcERlZmxhdGUoZmlsZXBhdGgsIHtcbiAgICAgICAgbGV2ZWw6IDYsXG4gICAgICB9KSA6IG5ldyBaaXBEZWZsYXRlKGZpbGVwYXRoLCB7XG4gICAgICAgIGxldmVsOiA2XG4gICAgICB9KTtcbiAgICAgIHByb3BlcnRpZXMuemlwLmFkZCh6aXBwZWRzdHJlYW0pO1xuICAgIGF3YWl0IHJlYWRGaWxlKGZpbGUsIGZpbGVwYXRoLCB6aXBwZWRzdHJlYW0pO1xuICB9XG4gIGZ1bmN0aW9uIGNvbXByZXNzZWRfZXN0aW1hdGUoZmlsZSkge1xuICAgIGNvbnN0IGV4dCA9IGZpbGUubmFtZS5zbGljZShmaWxlLm5hbWUubGFzdEluZGV4T2YoJy4nKSArIDEpO1xuICAgIGlmIChjYW5fYmVfY29tcHJlc3NlZC5oYXMoZXh0KSkgcmV0dXJuIE1hdGguZmxvb3IoZmlsZS5zaXplLzIpO1xuICAgIHJldHVybiBmaWxlLnNpemU7XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gYWRkRmlsZVRvWmlwU3RyZWFtKGZpbGUsIGZpbGVwYXRoLCBjb3VudCA9IHRydWUpIHtcbiAgICBpZiAoY291bnQgPT09IHRydWUpIE1vZHVsZUV2ZW50RW1pdHRlci5lbWl0KGV2ZW50bmFtZXMuY291bnRlciwge1xuICAgICAgbmFtZTogJ3NjYW4nLFxuICAgICAgcGF0aDogZmlsZXBhdGgsXG4gICAgICBzaXplOiBmaWxlLnNpemVcbiAgICB9LCB1dWlkKTtcbiAgICBwcm9wZXJ0aWVzLmZvbGxvdyA9IG51bGw7XG5cbiAgICAvLyBjaGVjayBmaWxlIHNpemUgPiBtYXggcG9zdCBzaXplXG4gICAgY29uc3QgY29tcHJlc3NlZF9zaXplID0gY29tcHJlc3NlZF9lc3RpbWF0ZShmaWxlKTtcbiAgICBpZiAoY29tcHJlc3NlZF9zaXplID49IE1BWFNJWkUgKSB7XG4gICAgLy8gdG8gcHJldmVudCBlcnJvcnMgYW5kIHVuY29tcGxldGUgemlwIHNlbmQgZXJyb3JcbiAgICAgIHByb3BlcnRpZXMuY291bnRlci5lcnJvcis9MTtcbiAgICAgIGlmKFVQTE9BRElOUEFSVFMpIGd6aXBCaWdGaWxlKGZpbGUsIGZpbGVwYXRoKTtcbiAgICAgIGVsc2UgZW5kUHJvY2VzcygpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBjaGVjayB6aXAgZmlsZSBzaXplID4gdG90YWwgemlwIHNpemVcbiAgICAgIHByb3BlcnRpZXMuc2l6ZXRvemlwICs9IGNvbXByZXNzZWRfc2l6ZTtcbiAgICAgIGlmIChwcm9wZXJ0aWVzLnNpemV0b3ppcCA+IE1BWFNJWkUpIHtcbiAgICAgIGlmKFVQTE9BRElOUEFSVFMpIHtcbiAgICAgIHByb3BlcnRpZXMuZm9sbG93ID0gYXN5bmMgKCkgPT4ge1xuICAgICAgICAgIGF3YWl0IHppcFN0cmVhbShmaWxlLCBmaWxlcGF0aCk7XG4gICAgICAgIH1cbiAgICAgICAgcGFydFppcCgpO1xuICAgICAgICB9IGVsc2UgZW5kUHJvY2VzcygpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYXdhaXQgemlwU3RyZWFtKGZpbGUsIGZpbGVwYXRoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBhY2NlcHRGaWxlKGVudHJ5KSB7XG4gICAgY29uc3QgZmlsZXBhdGggPSBlbnRyeS5uYW1lO1xuICAgIGNvbnN0IGV4dCA9IGZpbGVwYXRoLnNsaWNlKGZpbGVwYXRoLmxhc3RJbmRleE9mKCcuJykgKyAxKTtcbiAgICByZXR1cm4gYWNjZXB0LmluY2x1ZGVzKGV4dCk7XG4gIH1cblxuICBmdW5jdGlvbiByZWplY3RGaWxlKGZpbGUsIGNhbGxiYWNrID0gbnVsbCkge1xuICAgIGNvbnN0IHBhdGggPSAoZmlsZS5mdWxsUGF0aCkgPyBmaWxlLmZ1bGxQYXRoIDogZmlsZS53ZWJraXRSZWxhdGl2ZVBhdGg7XG4gICAgcHJvcGVydGllcy5jb3VudGVyLnJlamVjdCArPSAxO1xuICAgIE1vZHVsZUV2ZW50RW1pdHRlci5lbWl0KGV2ZW50bmFtZXMucmVqZWN0LCB7XG4gICAgICBuYW1lOiBldmVudG5hbWVzLnJlamVjdCxcbiAgICAgIHBhdGg6IHBhdGgsXG4gICAgfSwgX2xpc3RlbmVyKTtcbiAgICBpZiAoY2FsbGJhY2sgIT09IG51bGwpIGNhbGxiYWNrKCk7XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gcHJvY2Vzc0ZpbGUoZW50cnkpIHtcbiAgICBjb25zdCBlbnRyeXBhdGggPSAoZW50cnkuZnVsbFBhdGgpID8gZW50cnkuZnVsbFBhdGggOiBlbnRyeS53ZWJraXRSZWxhdGl2ZVBhdGg7XG4gICAgZW50cnkuZmlsZShhc3luYyBmaWxlID0+IHtcbiAgICAgIGF3YWl0IGFkZEZpbGVUb1ppcFN0cmVhbShmaWxlLCBlbnRyeXBhdGgpO1xuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gb25FcnJvcihhY3Rpb24sIG1lc3NhZ2UgPSBudWxsKSB7XG4gICAgbWVzc2FnZSA9IChtZXNzYWdlKSA/IG1lc3NhZ2UgOiB7fTtcbiAgICBzd2l0Y2ggKGFjdGlvbikge1xuICAgICAgY2FzZSBldmVudG5hbWVzLmluaXQ6XG4gICAgICBjYXNlIGV2ZW50bmFtZXMuZXJyb3JmaWxlOlxuICAgICAgICBtZXNzYWdlLm5hbWU9YWN0aW9uO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIC8vbWVzc2FnZS5uYW1lID0gZXZlbnRuYW1lcy5lcnJvcjtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIE1vZHVsZUV2ZW50RW1pdHRlci5lbWl0KGV2ZW50bmFtZXMubWVzc2FnZSwgbWVzc2FnZSwgX2xpc3RlbmVyKTtcbiAgfVxuICBhc3luYyBmdW5jdGlvbiBzZWFyY2hTdG9yYWdlKHNlYXJjaCkge1xuICAgIGNvbnN0IGVudHJ5ID0gYXdhaXQgbmF2aWdhdG9yLnN0b3JhZ2UuZ2V0RGlyZWN0b3J5KCk7XG4gICAgZm9yIGF3YWl0IChjb25zdCBba2V5LCB2YWx1ZV0gb2YgZW50cnkuZW50cmllcygpKSB7XG4gICAgICBpZiAoc2VhcmNoID09PSBrZXkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gY2xlYW5TdG9yYWdlKGVudHJ5ID0gbnVsbCkge1xuICAgIGVudHJ5ID0gKGVudHJ5KSA/IGVudHJ5IDogYXdhaXQgbmF2aWdhdG9yLnN0b3JhZ2UuZ2V0RGlyZWN0b3J5KCk7XG4gICAgIGZvciBhd2FpdCAoY29uc3QgW2tleSwgdmFsdWVdIG9mIGVudHJ5LmVudHJpZXMoKSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgYXdhaXQgZW50cnkucmVtb3ZlRW50cnkoa2V5KTtcbiAgICAgICAgY29uc29sZS5sb2coJyBTdWNjZXNzIHJlbW92ZSBzdG9yYWdlICcsIGtleSk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmxvZygnIGVycm9yIHJlbW92ZSBzdG9yYWdlICcgKyBrZXksIGVycm9yKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbmFzeW5jIGZ1bmN0aW9uIGxpc3RTdG9yYWdlKGVudHJ5ID0gbnVsbCxuYW1lPW51bGwpIHtcbiAgICBlbnRyeSA9IChlbnRyeSkgPyBlbnRyeSA6IGF3YWl0IG5hdmlnYXRvci5zdG9yYWdlLmdldERpcmVjdG9yeSgpO1xuICAgIGxldCByZXA9dHJ1ZTtcbiAgICAgZm9yIGF3YWl0IChjb25zdCBba2V5LCB2YWx1ZV0gb2YgZW50cnkuZW50cmllcygpKSB7XG4gICAgICAgIGlmIChuYW1lIT09bnVsbCkge1xuICAgICAgICAgICAgY29uc3QgcGFydHMgPSBrZXkuc3BsaXQoJy4nKTtcbiAgICAgICAgICAgIGlmIChwYXJ0cy5wb3AoKT09PSdjcnN3YXAnICYmIHBhcnRzLmpvaW4oJy4nKSA9PT1uYW1lKSB7XG4gICAgICAgICAgICByZXA9ZmFsc2U7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB9XG4gICAgICByZXR1cm4gcmVwO1xuICAgIH1cbiAgYXN5bmMgZnVuY3Rpb24gZW5kRmV0Y2gobWVzc2FnZSwgY2xlYW4gPSBmYWxzZSkge1xuICAgIGlmIChwcm9wZXJ0aWVzLmZvbGxvdykge1xuICAgICAgcHJvcGVydGllcy5zdHJlYW1oYW5kbGUgPSBhd2FpdCBwcm9wZXJ0aWVzLmZpbGVzdHJlYW0uY3JlYXRlV3JpdGFibGUoe21vZGU6XCJleGNsdXNpdmVcIn0pO1xuICAgICAgbWVzc2FnZS5uYW1lID0gZXZlbnRuYW1lcy5mb2xsb3c7XG4gICAgICBNb2R1bGVFdmVudEVtaXR0ZXIuZW1pdChldmVudG5hbWVzLmZvbGxvdywgbWVzc2FnZSwgX2xpc3RlbmVyKTtcbiAgICAgIGF3YWl0IGluaXRaaXAoKTtcbiAgICAgIHJldHVybjtcbiAgICB9IGVsc2UgcHJvcGVydGllcy56aXAgPSBudWxsO1xuICAgIGlmICghcHJvcGVydGllcy5oYXNoYW5kbGVycykge21lc3NhZ2UubmFtZSA9IGV2ZW50bmFtZXMudGVybWluYXRlO01vZHVsZUV2ZW50RW1pdHRlci5lbWl0KGV2ZW50bmFtZXMuY29tcGxldGUsIG1lc3NhZ2UsIF9saXN0ZW5lcik7fVxuICB9XG5cbiAgYXN5bmMgZnVuY3Rpb24gc2VuZENodW5rKHBhdGgsZ3ppcHBlZCwgc3RhcnQgPSAwLCBjaHVua251bSA9IDAsIGNodW5rc2l6ZSA9IE1BWFNJWkUpIHtcbiAgICBjb25zdCBleHQgPSBnemlwcGVkLm5hbWUuc2xpY2UoZ3ppcHBlZC5uYW1lLmxhc3RJbmRleE9mKCcuJykgKyAxKTtcbiAgICBjb25zdCBmaWxlID0gKGFscmVhZHlfY29tcHJlc3NlZC5oYXMoZXh0KSk/Z3ppcHBlZDphd2FpdCBnemlwcGVkLmdldEZpbGUoKTtcbiAgICBjb25zdCBlbmQgPSBNYXRoLm1pbihzdGFydCArIGNodW5rc2l6ZSwgZmlsZS5zaXplKTtcbiAgICBpZiAoZW5kID09PSBmaWxlLnNpemUpIHtcbiAgICBwYXRoPXBhdGgucmVwbGFjZShmaWxlLm5hbWUsJycpO1xuICAgICBzZW5kWmlwRmlsZShmaWxlLCBwYXRoLCBudWxsLCB0cnVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBwcm9wZXJ0aWVzLmNvdW50ZXIuZXJyb3IrPTE7XG4gICAgb25FcnJvcihldmVudG5hbWVzLmVycm9yZmlsZSwge1xuICAgICAgICAgIG5hbWU6IGV2ZW50bmFtZXMuZXJyb3IsXG4gICAgICAgICAgbWVzc2FnZTonRmlsZSAnK3BhdGgrZGlyc2VwYXJhdG9yK2ZpbGUubmFtZSsnIHNpemUgZXhjZWVkcyBjYXBhY2l0eS4gQ2h1bmsgZnVuY3Rpb25hbGl0eSBub3Qgc3VwcG9ydGVkIGZvciB0aGUgbW9tZW50LidcbiAgICAgICAgfSwgX2xpc3RlbmVyKTtcbiAgICByZXR1cm4gZW5kUHJvY2VzcygpIDtcbiAgICAvLyBmb3IgdGhlIG1vbWVudCBlY290YXhhYmFjayBkb2VzIG5vdCBzdXBwb3J0IGNodW5rc1xuICAgICAgY29uc3QgcGFydGZpbGUgPSBmaWxlLnNsaWNlKHN0YXJ0LCBlbmQpO1xuICAgICAgcGFydGZpbGUubmFtZSA9IGNodW5rbnVtICsgJ18nICsgZmlsZS5uYW1lO1xuICAgICAgYXdhaXQgc2VuZFppcEZpbGUocGFydGZpbGUsIHBhdGgsIGFzeW5jICgpID0+IHtcbiAgICAgICAgc3RhcnQgKz0gZW5kO1xuICAgICAgICBjaHVua251bSsrO1xuICAgICAgICBpZiAoc3RhcnQgPD0gZmlsZS5zaXplKSBhd2FpdCBzZW5kQ2h1bmsocGF0aCwgZ3ppcHBlZCxzdGFydCwgY2h1bmtudW0sIGNodW5rc2l6ZSk7XG4gICAgICB9LCB0cnVlKVxuICAgIH1cbiAgICByZXR1cm4gY2h1bmtudW07XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gZ2V0RmlsZShmaWxlc3RyZWFtID0gbnVsbCkge1xuICAgIGZpbGVzdHJlYW0gPSAoZmlsZXN0cmVhbSA9PT0gbnVsbCkgPyBwcm9wZXJ0aWVzLmZpbGVzdHJlYW0gOiBmaWxlc3RyZWFtO1xuICAgIGNvbnN0IGZpbGUgPSBhd2FpdCBmaWxlc3RyZWFtLmdldEZpbGUoKTtcbiAgICByZXR1cm4gZmlsZTtcbiAgfVxuICBhc3luYyBmdW5jdGlvbiBzZW5kWmlwRmlsZShmaWxlLCBwYXRoLCBjYWxsYmFja2NodW5rID0gbnVsbCwgYmlnZmlsZSA9IGZhbHNlKSB7XG4gIGlmKHByb3BlcnRpZXMuY291bnRlci5lcnJvcj4wKSByZXR1cm4gZW5kUHJvY2VzcygpO1xuICAgIGNvbnN0IG1lc3NhZ2UgPSB7XG4gICAgICBuYW1lOiBldmVudG5hbWVzLnBlbmRpbmcsXG4gICAgICBiaWdmaWxlOmJpZ2ZpbGUsXG4gICAgICBwYXRoOiBwYXRoXG4gICAgfVxuICAgIGNvbnN0IGZvcm1kYXRhID0gbmV3IEZvcm1EYXRhKCk7XG4gICAgcGF0aCA9IHBhdGggKyAoKHBhdGguc2xpY2UoLTEpID09PSBkaXJzZXBhcmF0b3IpID8gYGAgOiBkaXJzZXBhcmF0b3IpICsgZmlsZS5uYW1lO1xuICAgIGZvcm1kYXRhLmFwcGVuZCgncGF0aCcsIHBhdGgpO1xuICAgIGZvcm1kYXRhLmFwcGVuZCgnZmlsZScsIGZpbGUsIGZpbGUubmFtZSk7XG4gICAgaWYgKHByb3BlcnRpZXMucGFydCkgZm9ybWRhdGEuYXBwZW5kKCdwYXJ0JywgcHJvcGVydGllcy5wYXJ0KTtcbiAgICBlbHNlIGlmIChjYWxsYmFja2NodW5rICE9PSBudWxsKSBmb3JtZGF0YS5hcHBlbmQoJ2lzY2h1bmsnLCB0cnVlKTtcbiAgICBtZXNzYWdlLnBhdGggPSBwYXRoO1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2gob3B0aW9ucy51cGxvYWR1cmwsIHtcbiAgICAgIC8vICBtb2RlOiAnY29ycycsXG4gICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgY3JlZGVudGlhbHM6IFwiaW5jbHVkZVwiLFxuICAgICAgYm9keTogZm9ybWRhdGEsXG4gICAgfSk7XG4gICAgY29uc3QgYm9keT1hd2FpdCByZXNwb25zZS50ZXh0KCk7XG4gICAgICBpZiAocmVzcG9uc2Uub2spIHtcbiAgICAgIGlmIChjYWxsYmFja2NodW5rKSB7XG4gICAgICAgIGF3YWl0IGNhbGxiYWNrY2h1bmsoKTtcbiAgICAgIH0gZWxzZSB7IGlmKCFiaWdmaWxlIHx8ICFwcm9wZXJ0aWVzLmhhc2hhbmRsZXJzKSAgYXdhaXQgZW5kRmV0Y2gobWVzc2FnZSk7XG4gICAgICAgaWYgKGJpZ2ZpbGUpIHttZXNzYWdlLm5hbWU9ZXZlbnRuYW1lcy5mb2xsb3c7XG4gICAgICBNb2R1bGVFdmVudEVtaXR0ZXIuZW1pdChldmVudG5hbWVzLmZvbGxvdywgbWVzc2FnZSwgX2xpc3RlbmVyKTtcbiAgICAgIH0gfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcHJvcGVydGllcy5mb2xsb3c9bnVsbDtcbiAgICAgICAgYXdhaXQgZW5kRmV0Y2gobWVzc2FnZSk7XG4gICAgICAgICBwcm9wZXJ0aWVzLmNvdW50ZXIuZXJyb3IrPTE7XG4gICAgICAgIG9uRXJyb3IoZXZlbnRuYW1lcy5lcnJvcmZpbGUsIG1lc3NhZ2UpOyBpZihiaWdmaWxlIHx8IHByb3BlcnRpZXMuaGFzaGFuZGxlcnMpIGVuZFByb2Nlc3MoKTsgICAgfVxuICB9XG4gIGZ1bmN0aW9uIGVuZFByb2Nlc3MoKSB7XG4gICAgcHJvcGVydGllcy5mb2xsb3c9bnVsbDtcbiAgICBvbkVycm9yKGV2ZW50bmFtZXMuZXJyb3JmaWxlLHtcbiAgICAgICAgICAgIG5hbWU6IEFsZXJ0Qm94LmFsZXJ0Y29uZmlnLnR5cGVzLmVycm9yLFxuICAgICAgICAgICAgbWVzc2FnZTogXCJVcGxvYWQgbm90IGRvbmUuIG9uZSBvciBtb3JlIGZpbGVzIGV4Y2VlZHMgbWF4IHVwbG9hZCBzaXplXCIsXG4gICAgICAgICAgICBwYXRoOnVwbG9hZHBhdGgsXG4gICAgICAgICAgICB9KTtcbiAgICByZXNldCgpLnRoZW4oKCkgPT4ge1xuICAgICAgICBNb2R1bGVFdmVudEVtaXR0ZXIuZW1pdChldmVudG5hbWVzLmNvbXBsZXRlLCB7XG4gICAgICAgICAgbmFtZTogZXZlbnRuYW1lcy5yZWFkeVxuICAgICAgICB9LCBfbGlzdGVuZXIpO1xuICAgICAgICBwcm9wZXJ0aWVzLmVuZHJlYWRkaXIgPSBmYWxzZTsgIH0pO1xuICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIHJldHVybiB7XG4gICAgdXVpZCxcbiAgICBldmVudG5hbWVzLFxuICAgIHNjYW5Ccm93c2UsXG4gICAgc2NhbkhhbmRsZSxcbiAgICBxdW90YUVzdGltYXRlLFxuICAgIGJyb3dzZXJSZXF1aXJlZFxuICB9XG59Il0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/modules/files/js-dirtozip.js\n\n}")}}]);