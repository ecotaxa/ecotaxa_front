/*! For license information please see src_modules_files_js-dirtozip_js.js.LICENSE.txt */
"use strict";(self.webpackChunk=self.webpackChunk||[]).push([["src_modules_files_js-dirtozip_js"],{"./src/modules/files/js-dirtozip.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   JsDirToZip: () => (/* binding */ JsDirToZip)\n/* harmony export */ });\n/* harmony import */ var _modules_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../modules/utils.js */ \"./src/modules/utils.js\");\n/* harmony import */ var fflate__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! fflate */ \"./node_modules/fflate/esm/browser.js\");\n\n\n\n\nconst already_compressed = new Set([\n  'zip', 'gz', 'png', 'jpg', 'jpeg', 'pdf', 'doc', 'docx', 'ppt', 'pptx',\n  'xls', 'xlsx', 'heic', 'heif', '7z', 'bz2', 'rar', 'gif', 'webp', 'webm',\n  'mp4', 'mov', 'mp3', 'aifc'\n]);\nconst accept = '.tsv,.png,.jpg, .jpeg,.zip,.gz,.7z,.bz2';\nlet instance = null;\nconst MAXSIZE = 1073741824; ////maxfilesize: 1073741824,\nclass JsDirToZip {\n  _events = {};\n  eventnames = {\n    ready: 'ready',\n    endzip: 'endzip',\n    complete: 'complete',\n    endreaddir: 'endreaddir',\n    gzip: 'gzipfile',\n    sendfile: 'sendfile',\n    bigfile: 'bigfile',\n    terminate: 'terminate',\n    pending: 'pending',\n    getfile: 'getzipfile',\n    counter: 'counter',\n    message: 'message',\n    error: 'error'\n  }\n  zip = null;\n  zipname = null;\n  filestream = null;\n  streamhandle = null;\n  gzipped = null;\n  sizetozip = 0;\n  part = 0;\n  continue = null;\n  counter = {\n    scan: 0,\n    zip: 0\n  }\n  // uses https://developer.mozilla.org/en-US/docs/Web/API/File_System_API/Origin_private_file_system\n  //# alternative (not supported in Safari) for .createWritable\n  constructor(options = {}) {\n    if (instance) return instance;\n    const defaultOptions = {\n      uploadurl: '/gui/files/upload',\n      largefile: 4194304,\n      accept: accept.split(',')\n    }\n    this.options = { ...defaultOptions,\n      ...options\n    };\n    console.log('thisopts', this.options)\n\n    this.init();\n\n    instance = this;\n    return instance;\n  }\n  init() {\n    (0,_modules_utils_js__WEBPACK_IMPORTED_MODULE_0__.add_custom_events)(this);\n    this.initStorage();\n    this.on(this.eventnames.ready, () => {\n      console.log('ready')\n    });\n  }\n  reset() {\n    console.log('reset');\n    this.zip = null;\n    this.zipname = null;\n    this.filestream = null;\n    this.streamhandle = null;\n    this.gzipped = null;\n    this.sizetozip = 0;\n    this.part = 0;\n    this.continue = null;\n    this.initStorage();\n  }\n  async initZip() {\n    console.log('initzip')\n    const self = this;\n    this.pos = 0;\n    this.sizetozip = 0;\n\n    this.zip = new fflate__WEBPACK_IMPORTED_MODULE_1__.Zip((error, chunk, final) => {\n      if (error) {\n        console.log('error', error);\n        return false;\n      } else {\n        self.streamhandle.write(chunk, {\n          at: self.pos\n        });\n        self.pos += chunk.length;\n        if (final) {\n          self.streamhandle.close();\n          console.log('final-----------------------------*******************************-', self.pos);\n\n        }\n\n      }\n    });\n    /*  const fflToRS = fflateStream =>\n        new ReadableStream({\n          start(controller) {\n            // Push to the ReadableStream whenever the fflate\n            // stream gets data\n            fflateStream.ondata = (err, data, final) => {\n              if (err) controller.error(err);\n              else {\n                controller.enqueue(data);\n                // End the stream on the final chunk\n                if (final) {\n                  controller.close();\n                  console.log('final-----------------------------******************************-');\n                }\n              }\n            }\n          },\n          cancel() {\n            // We can stop working if the stream is cancelled\n            // This may happen if the user cancels the download\n            fflateStream.terminate();\n          }\n        });\n      const zipstream = fflToRS(this.zip);\n      zipstream.pipeTo(self.streamhandle);*/\n    if (this.continue) await this.continue();\n    else {\n      // events\n      this.on(this.eventnames.endzip, (e) => {\n        if (!e.bigfile && this.zip) {\n\n          this.zip.end();\n          console.log('zipend', this.zip)\n          console.log('fstrem', this.filestream)\n        } else if (e.bigfile && this.gzipped) console.log('-------------------------gzipped end ', this.gzipped)\n        const message = {\n          name: this.eventnames.sendfile\n        };\n        if (e.part) {\n          message[\"part\"] = e.part;\n        } else this.part = 0;\n        if (e.hasOwnProperty(\"bigfile\")) message[\"bigfile\"] = e.bigfile;\n        if (e.hasOwnProperty(\"path\")) message[\"path\"] = e.path;\n        console.log('endzip%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%', e)\n        this.emit(this.eventnames.complete, message);\n      });\n\n      this.on(this.eventnames.sendfile, async (e) => {\n        console.log('eventsendfile', e)\n        let file = (e.bigfile) ? await this.getFile(this.gzipped): await this.getFile();\n        console.log('sendfile', file)\n        /* if (e.bigfile) this.sendChunk((e.path ? e.path : ''));\n          else */\n        this.sendZipFile(file, (e.path ? e.path : ''), null, (e.bigfile ? e.bigfile : false));\n      });\n      this.on(this.eventnames.bigfile, (e) => {\n        console.log('onsendchunk', e)\n        this.sendChunk((e.path ? e.path : ''));\n      });\n      this.on(this.eventnames.endreaddir, (e) => {\n        this.endreaddir = true;\n        if (e.hasOwnProperty('name') && e.name === this.eventnames.endzip) {\n          this.emit(this.eventnames.complete, {\n            name: this.eventnames.endzip\n          });\n        }\n      });\n      this.on(this.eventnames.counter, async (e) => {\n        this.counter[e.name] += 1;\n        if (this.endreaddir && e.name === 'zip' && this.counter.scan === this.counter.zip) {\n          console.log('end', this.counter)\n          this.emit(this.eventnames.complete, {\n            name: this.eventnames.endzip\n          });\n        }\n        if (e.name === 'zip' && this.callback) await this.callback();\n      });\n    }\n  }\n\n  async quotaEstimate() {\n\n    if (navigator && navigator.storage && navigator.storage.estimate) {\n      navigator.storage.estimate().then((quota) => {\n        const percentageUsed = ((quota.usage / quota.quota) * 100).toFixed(2);\n        const remaining = (0,_modules_utils_js__WEBPACK_IMPORTED_MODULE_0__.format_bytes)(quota.quota - quota.usage);\n        this.emit(this.eventnames.message, {\n          id: \"quota\",\n          name: \"console\",\n          message: \"you've used \" + percentageUsed + \"% of the available storage (\" + remaining + \").\"\n        });\n      });\n    }\n  }\n\n  async initStorage() {\n    if (navigator && navigator.storage && navigator.storage.estimate) {\n      await this.cleanStorage();\n      this.emit(this.eventnames.ready);\n      this.quotaEstimate();\n    } else this.emit(this.eventnames.message, {\n      name: \"error\",\n      message: \"no navigator storage\"\n    });\n  }\n  async createLocalStream(name, accept = {\n    'application/zip': ['.zip'],\n  }) {\n    const root = await navigator.storage.getDirectory();\n    const opts = {\n      types: [{\n        description: 'Temp file',\n        accept: accept,\n      }, ],\n      create: true\n    };\n    const filestream = await root.getFileHandle(name, opts);\n    const streamhandle = await filestream.createWritable();\n    return {\n      filestream,\n      streamhandle\n    };\n  }\n  async scanCommon(is_dir, zipname, options = {}) {\n    this.endreaddir = false;\n    this.counter.scan = this.counter.zip = 0;\n    if (this.zip === null) {\n      const type = (options && options.type) ? options.type : '.zip';\n      this.zipname = ((options.zipname) ? options.zipname : zipname) + type; //\n      const zipinstorage = await this.searchStorage(this.zipname);\n      if (zipinstorage) this.zipname = '1_' + this.zipname;\n      const {\n        filestream,\n        streamhandle\n      } = await this.createLocalStream(this.zipname);\n\n      this.filestream = filestream;\n      this.streamhandle = streamhandle;\n      let size = 0;\n      this.part = 0;\n      await this.initZip();\n      if (!this.jsScanDir) {\n        const {\n          JsScanDir\n        } = await __webpack_require__.e(/*! import() */ \"src_modules_files_js-scandir_js\").then(__webpack_require__.bind(__webpack_require__, /*! ../files/js-scandir.js */ \"./src/modules/files/js-scandir.js\"));\n        this.jsScanDir = new JsScanDir();\n      }\n      this.jsScanDir.processFile = async (entry, callback) => {\n        this.callback = callback;\n        await this.processFile(entry);\n\n      };\n    }\n  }\n\n  async scanFiles(files, options = {}) {\n    if (files.length === 0) return;\n    const zipname = files[0].webkitRelativePath.split(\"/\")[0];\n    console.log(zipname, files[0]);\n    await this.scanCommon(false, zipname, options);\n    for (let n = 0; n < files.length; n++) {\n      if (n === files.length - 1) this.emit(this.eventnames.endreaddir, {});\n      await this.addFileToZipStream(files[n], files[n].webkitRelativePath);\n    }\n\n  }\n\n  async scanHandle(dir, options = {}) {\n    await this.scanCommon(true, dir.name, options);\n    await this.jsScanDir.readDirectory(dir, () => {\n      this.emit(this.eventnames.endreaddir, {\n        name: this.eventnames.endzip\n      });\n    });\n\n  }\n  async sendBigFile(file, filepath) {\n    console.log('sendbigfilepath', filepath)\n    this.dt = Date.now();\n    filepath = (filepath.indexOf('/') === 0) ? filepath.substr(1) : filepath;\n    /*let filepath = file.webkitRelativePath;\n    filepath = (filepath === '') ? dirname + '/' + file.name : filepath;*/\n    const ext = file.name.slice(file.name.lastIndexOf('.') + 1);\n    if (already_compressed.has(ext)) {\n      this.gzipped = file;\n      this.emit(this.eventnames.counter, {\n        name: 'zip',\n        filepath: filepath,\n        size: file.size\n      });\n      this.emit(this.eventnames.complete, {\n        name: this.eventnames.bigfile,\n        bigfile: filepath\n      });\n    } else {\n      this.emit(this.eventnames.gzip, {\n        name: this.eventnames.gzip,\n        bigfile: filepath,\n        size: file.size\n      });\n      let zipname = file.name.split(ext);\n      zipname.pop();\n      zipname = zipname.join(ext) + 'gz';\n      console.log('bigfile ext=' + ext, zipname)\n      const {\n        filestream,\n        streamhandle\n      } = await this.createLocalStream(zipname, {\n        'application/gzip': ['.gz'],\n      });\n      let pos = 0;\n      const selfi = this;\n      const gzipped = new fflate__WEBPACK_IMPORTED_MODULE_1__.Gzip({\n        level: 9,\n        filename: filepath\n      });\n      gzipped.ondata = (data, final) => {\n        if (final) {\n          console.log('final BIGFILE%%%%%%%%%%%%%%%%%%%%' + selfi.eventnames.bigfile, filepath)\n          selfi.emit(selfi.eventnames.complete, {\n            name: selfi.eventnames.bigfile,\n            bigfile: filepath\n\n          });\n\n          streamhandle.close();\n          console.log('timetozip', (Date.now() - this.dt) / 1000)\n          selfi.gzipped = filestream;\n          console.log('big file *******************' + filepath, selfi.gzipped);\n\n        } else {\n          streamhandle.write(data, {\n            at: pos\n          });\n          pos += data.length;\n        }\n      };\n      await this.readFile(file, filepath, gzipped);\n    }\n\n\n  }\n  async partZip() {\n    this.part += 1;\n    this.emit(this.eventnames.complete, {\n      name: this.eventnames.endzip,\n      part: this.part\n    });\n  }\n  async readFile(file, filepath, zippedstream) {\n    const self = this;\n    const reader = file.stream().getReader();\n    let pause = false;\n    /*  onBackpressure(zippedstream, this.streamhandle, should_apply_backpressure => {\n        if (should_apply_backpressure) pause = true;\n        else if (pause) pause = false;\n      });*/\n    while (true) {\n      const {\n        done,\n        value\n      } = await reader.read();\n      if (done) {\n        zippedstream.push(new Uint8Array(0), true);\n        self.emit(self.eventnames.counter, {\n          name: 'zip',\n          filepath: filepath,\n          size: (zippedstream.size) ? zippedstream.size : file.size\n        });\n        break;\n      }\n      zippedstream.push(value);\n    }\n  }\n  async zipStream(file, filepath) {\n    const self = this;\n    const ext = filepath.slice(filepath.lastIndexOf('.') + 1);\n    const iscompressed = already_compressed.has(ext);\n    const zippedstream = (iscompressed) ? new fflate__WEBPACK_IMPORTED_MODULE_1__.ZipPassThrough(filepath) : file.size > this.options.largefile ?\n      new fflate__WEBPACK_IMPORTED_MODULE_1__.AsyncZipDeflate(filepath, {\n        level: 6,\n      }) : new fflate__WEBPACK_IMPORTED_MODULE_1__.ZipDeflate(filepath, {\n        level: 6\n      });\n    this.zip.add(zippedstream);\n    await this.readFile(file, filepath, zippedstream);\n  }\n\n  async addFileToZipStream(file, filepath) {\n    console.log('emitscan', this.counter)\n    this.emit(this.eventnames.counter, {\n      name: 'scan',\n      filepath: filepath,\n      size: file.size\n    });\n    this.continue = null;\n    // check file size > max post size\n    if (file.size >= MAXSIZE) {\n      await this.sendBigFile(file, filepath);\n    } else {\n      // check zip file size > total zip size\n      this.sizetozip += file.size;\n      if (this.sizetozip >= MAXSIZE) {\n        this.continue = async () => {\n          await this.zipStream(file, filepath);\n        }\n        this.partZip();\n      } else {\n        await this.zipStream(file, filepath);\n      }\n    }\n  }\n\n  async processFile(entry) {\n    const self = this;\n    const filepath = entry.fullPath;\n    const ext = filepath.slice(filepath.lastIndexOf('.') + 1);\n    if (this.options.accept.includes(ext)) {\n      console.log('reject', filepath);\n      return;\n    }\n    if (entry.isDirectory) {\n      console.log('zipdir', this.callback)\n      if (this.callback !== null) await this.callback();\n    } else {\n      entry.file(async file => {\n        await this.addFileToZipStream(file, filepath);\n      });\n\n    }\n  }\n  onError() {\n    this.cleanStorage();\n    this.emit(this.eventnames.error, {\n      name: \"reload\"\n    });\n  }\n  async searchStorage(search) {\n    const entry = await navigator.storage.getDirectory();\n    for await (const [key, value] of entry.entries()) {\n      if (search === key) {\n        console.log('key', key);\n        return true;\n        false\n        break;\n      }\n    }\n    return false;\n  }\n  async cleanStorage(entry = null) {\n    return;\n    entry = (entry) ? entry : await navigator.storage.getDirectory();\n    for await (const [key, value] of entry.entries()) {\n      try {\n        await entry.removeEntry(key);\n      } catch (error) {\n        console.log(' remove storage ' + key, error);\n      }\n    }\n\n  }\n\n  async endFetch(message, clean = false) {\n    message.name = this.eventnames.terminate;\n    if (message.hasOwnProperty(\"bigfile\") && message.bigfile !== \"\" &&\n      message.bigfile !== false && message.bigfile !== null) {\n      message[\"bigfile\"] = this.gzipped.name;\n      this.gzipped = null;\n    } else {\n      if (this.continue) {\n        this.streamhandle = await this.filestream.createWritable();\n        await this.initZip();\n      } else this.reset();\n    }\n    this.emit(this.eventnames.complete, message);\n    console.log('continue', this.continue)\n  }\n\n  async sendChunk(path, start = 0, chunknum = 0, chunksize = MAXSIZE) {\n    console.log('send chunk ', this.gzipped)\n    console.log('chunkpath', path)\n    const file = (this.gzipped) ? await this.getFile(this.gzipped): await this.getFile();\n    console.log('file', file)\n    path = path.split('/');\n    path.pop();\n    path = path.join('/');\n    const end = Math.min(start + chunksize, file.size);\n    console.log('end---', end)\n    if (end === file.size) {\n\n      this.sendZipFile(file, path, null, true);\n    } else {\n      const partfile = file.slice(start, end);\n      partfile.name = chunknum + '_' + file.name;\n      this.sendZipfile(partfile, path, () => {\n        start += end;\n        chunknum++;\n\n        if (start <= file.size) this.sendChunk(path, start, chunknum, chunksize);\n      }, true)\n    }\n    return chunknum;\n  }\n  async getFile(filestream = null) {\n    filestream = (filestream === null) ? this.filestream : filestream;\n    const file = await filestream.getFile();\n    return file;\n  }\n  async sendZipFile(file, path, callbackchunk = null, isbigfile = false) {\n    console.log('sendzipfile------------_______________________' + isbigfile, file)\n    const message = (isbigfile) ? {\n      bigfile: file.name\n    } : {};\n    this.emit(this.eventnames.pending, message);\n    console.log('file', file)\n    console.log('path', path)\n    console.log('callbackchunk---sendzip', callbackchunk)\n    const formdata = new FormData();\n    formdata.append('path', path + file.name);\n    formdata.append('file', file, file.name);\n    if (this.part) formdata.append('part', this.part);\n    else if (callbackchunk !== null) formdata.append('ischunk', true);\n    fetch(this.options.uploadurl, {\n      //  mode: 'cors',\n      method: \"POST\",\n      credentials: \"include\",\n      body: formdata,\n    }).then(async (response) => {\n      console.log('response----------------------', response);\n      console.log('callbackchunk-------------------------------', callbackchunk)\n      if (callbackchunk !== null) {\n        await callbackchunk();\n      } else await this.endFetch(message);\n    });\n  }\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSwwQkFBMEIsd0NBQUk7QUFDOUI7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsV0FBVzs7QUFFWDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU8sRUFBRTtBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsa0RBQWM7QUFDNUQsVUFBVSxtREFBZTtBQUN6QjtBQUNBLE9BQU8sUUFBUSw4Q0FBVTtBQUN6QjtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUixLQUFLO0FBQ0w7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy9tb2R1bGVzL2ZpbGVzL2pzLWRpcnRvemlwLmpzPzg1MzgiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuaW1wb3J0IHtcbiAgYWRkX2N1c3RvbV9ldmVudHMsXG4gIGZldGNoU2V0dGluZ3MsXG4gIGZvcm1hdF9ieXRlc1xufSBmcm9tICcuLi8uLi9tb2R1bGVzL3V0aWxzLmpzJztcblxuaW1wb3J0IHtcbiAgR3ppcCxcbiAgWmlwLFxuICBBc3luY1ppcERlZmxhdGUsXG4gIFppcFBhc3NUaHJvdWdoLFxuICBaaXBEZWZsYXRlLFxufSBmcm9tICdmZmxhdGUnO1xuY29uc3QgYWxyZWFkeV9jb21wcmVzc2VkID0gbmV3IFNldChbXG4gICd6aXAnLCAnZ3onLCAncG5nJywgJ2pwZycsICdqcGVnJywgJ3BkZicsICdkb2MnLCAnZG9jeCcsICdwcHQnLCAncHB0eCcsXG4gICd4bHMnLCAneGxzeCcsICdoZWljJywgJ2hlaWYnLCAnN3onLCAnYnoyJywgJ3JhcicsICdnaWYnLCAnd2VicCcsICd3ZWJtJyxcbiAgJ21wNCcsICdtb3YnLCAnbXAzJywgJ2FpZmMnXG5dKTtcbmNvbnN0IGFjY2VwdCA9ICcudHN2LC5wbmcsLmpwZywgLmpwZWcsLnppcCwuZ3osLjd6LC5iejInO1xubGV0IGluc3RhbmNlID0gbnVsbDtcbmNvbnN0IE1BWFNJWkUgPSAxMDczNzQxODI0OyAvLy8vbWF4ZmlsZXNpemU6IDEwNzM3NDE4MjQsXG5leHBvcnQgY2xhc3MgSnNEaXJUb1ppcCB7XG4gIF9ldmVudHMgPSB7fTtcbiAgZXZlbnRuYW1lcyA9IHtcbiAgICByZWFkeTogJ3JlYWR5JyxcbiAgICBlbmR6aXA6ICdlbmR6aXAnLFxuICAgIGNvbXBsZXRlOiAnY29tcGxldGUnLFxuICAgIGVuZHJlYWRkaXI6ICdlbmRyZWFkZGlyJyxcbiAgICBnemlwOiAnZ3ppcGZpbGUnLFxuICAgIHNlbmRmaWxlOiAnc2VuZGZpbGUnLFxuICAgIGJpZ2ZpbGU6ICdiaWdmaWxlJyxcbiAgICB0ZXJtaW5hdGU6ICd0ZXJtaW5hdGUnLFxuICAgIHBlbmRpbmc6ICdwZW5kaW5nJyxcbiAgICBnZXRmaWxlOiAnZ2V0emlwZmlsZScsXG4gICAgY291bnRlcjogJ2NvdW50ZXInLFxuICAgIG1lc3NhZ2U6ICdtZXNzYWdlJyxcbiAgICBlcnJvcjogJ2Vycm9yJ1xuICB9XG4gIHppcCA9IG51bGw7XG4gIHppcG5hbWUgPSBudWxsO1xuICBmaWxlc3RyZWFtID0gbnVsbDtcbiAgc3RyZWFtaGFuZGxlID0gbnVsbDtcbiAgZ3ppcHBlZCA9IG51bGw7XG4gIHNpemV0b3ppcCA9IDA7XG4gIHBhcnQgPSAwO1xuICBjb250aW51ZSA9IG51bGw7XG4gIGNvdW50ZXIgPSB7XG4gICAgc2NhbjogMCxcbiAgICB6aXA6IDBcbiAgfVxuICAvLyB1c2VzIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9GaWxlX1N5c3RlbV9BUEkvT3JpZ2luX3ByaXZhdGVfZmlsZV9zeXN0ZW1cbiAgLy8jIGFsdGVybmF0aXZlIChub3Qgc3VwcG9ydGVkIGluIFNhZmFyaSkgZm9yIC5jcmVhdGVXcml0YWJsZVxuICBjb25zdHJ1Y3RvcihvcHRpb25zID0ge30pIHtcbiAgICBpZiAoaW5zdGFuY2UpIHJldHVybiBpbnN0YW5jZTtcbiAgICBjb25zdCBkZWZhdWx0T3B0aW9ucyA9IHtcbiAgICAgIHVwbG9hZHVybDogJy9ndWkvZmlsZXMvdXBsb2FkJyxcbiAgICAgIGxhcmdlZmlsZTogNDE5NDMwNCxcbiAgICAgIGFjY2VwdDogYWNjZXB0LnNwbGl0KCcsJylcbiAgICB9XG4gICAgdGhpcy5vcHRpb25zID0geyAuLi5kZWZhdWx0T3B0aW9ucyxcbiAgICAgIC4uLm9wdGlvbnNcbiAgICB9O1xuICAgIGNvbnNvbGUubG9nKCd0aGlzb3B0cycsIHRoaXMub3B0aW9ucylcblxuICAgIHRoaXMuaW5pdCgpO1xuXG4gICAgaW5zdGFuY2UgPSB0aGlzO1xuICAgIHJldHVybiBpbnN0YW5jZTtcbiAgfVxuICBpbml0KCkge1xuICAgIGFkZF9jdXN0b21fZXZlbnRzKHRoaXMpO1xuICAgIHRoaXMuaW5pdFN0b3JhZ2UoKTtcbiAgICB0aGlzLm9uKHRoaXMuZXZlbnRuYW1lcy5yZWFkeSwgKCkgPT4ge1xuICAgICAgY29uc29sZS5sb2coJ3JlYWR5JylcbiAgICB9KTtcbiAgfVxuICByZXNldCgpIHtcbiAgICBjb25zb2xlLmxvZygncmVzZXQnKTtcbiAgICB0aGlzLnppcCA9IG51bGw7XG4gICAgdGhpcy56aXBuYW1lID0gbnVsbDtcbiAgICB0aGlzLmZpbGVzdHJlYW0gPSBudWxsO1xuICAgIHRoaXMuc3RyZWFtaGFuZGxlID0gbnVsbDtcbiAgICB0aGlzLmd6aXBwZWQgPSBudWxsO1xuICAgIHRoaXMuc2l6ZXRvemlwID0gMDtcbiAgICB0aGlzLnBhcnQgPSAwO1xuICAgIHRoaXMuY29udGludWUgPSBudWxsO1xuICAgIHRoaXMuaW5pdFN0b3JhZ2UoKTtcbiAgfVxuICBhc3luYyBpbml0WmlwKCkge1xuICAgIGNvbnNvbGUubG9nKCdpbml0emlwJylcbiAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICB0aGlzLnBvcyA9IDA7XG4gICAgdGhpcy5zaXpldG96aXAgPSAwO1xuXG4gICAgdGhpcy56aXAgPSBuZXcgWmlwKChlcnJvciwgY2h1bmssIGZpbmFsKSA9PiB7XG4gICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5sb2coJ2Vycm9yJywgZXJyb3IpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZWxmLnN0cmVhbWhhbmRsZS53cml0ZShjaHVuaywge1xuICAgICAgICAgIGF0OiBzZWxmLnBvc1xuICAgICAgICB9KTtcbiAgICAgICAgc2VsZi5wb3MgKz0gY2h1bmsubGVuZ3RoO1xuICAgICAgICBpZiAoZmluYWwpIHtcbiAgICAgICAgICBzZWxmLnN0cmVhbWhhbmRsZS5jbG9zZSgpO1xuICAgICAgICAgIGNvbnNvbGUubG9nKCdmaW5hbC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi0nLCBzZWxmLnBvcyk7XG5cbiAgICAgICAgfVxuXG4gICAgICB9XG4gICAgfSk7XG4gICAgLyogIGNvbnN0IGZmbFRvUlMgPSBmZmxhdGVTdHJlYW0gPT5cbiAgICAgICAgbmV3IFJlYWRhYmxlU3RyZWFtKHtcbiAgICAgICAgICBzdGFydChjb250cm9sbGVyKSB7XG4gICAgICAgICAgICAvLyBQdXNoIHRvIHRoZSBSZWFkYWJsZVN0cmVhbSB3aGVuZXZlciB0aGUgZmZsYXRlXG4gICAgICAgICAgICAvLyBzdHJlYW0gZ2V0cyBkYXRhXG4gICAgICAgICAgICBmZmxhdGVTdHJlYW0ub25kYXRhID0gKGVyciwgZGF0YSwgZmluYWwpID0+IHtcbiAgICAgICAgICAgICAgaWYgKGVycikgY29udHJvbGxlci5lcnJvcihlcnIpO1xuICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoZGF0YSk7XG4gICAgICAgICAgICAgICAgLy8gRW5kIHRoZSBzdHJlYW0gb24gdGhlIGZpbmFsIGNodW5rXG4gICAgICAgICAgICAgICAgaWYgKGZpbmFsKSB7XG4gICAgICAgICAgICAgICAgICBjb250cm9sbGVyLmNsb3NlKCk7XG4gICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnZmluYWwtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi0nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIGNhbmNlbCgpIHtcbiAgICAgICAgICAgIC8vIFdlIGNhbiBzdG9wIHdvcmtpbmcgaWYgdGhlIHN0cmVhbSBpcyBjYW5jZWxsZWRcbiAgICAgICAgICAgIC8vIFRoaXMgbWF5IGhhcHBlbiBpZiB0aGUgdXNlciBjYW5jZWxzIHRoZSBkb3dubG9hZFxuICAgICAgICAgICAgZmZsYXRlU3RyZWFtLnRlcm1pbmF0ZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICBjb25zdCB6aXBzdHJlYW0gPSBmZmxUb1JTKHRoaXMuemlwKTtcbiAgICAgIHppcHN0cmVhbS5waXBlVG8oc2VsZi5zdHJlYW1oYW5kbGUpOyovXG4gICAgaWYgKHRoaXMuY29udGludWUpIGF3YWl0IHRoaXMuY29udGludWUoKTtcbiAgICBlbHNlIHtcbiAgICAgIC8vIGV2ZW50c1xuICAgICAgdGhpcy5vbih0aGlzLmV2ZW50bmFtZXMuZW5kemlwLCAoZSkgPT4ge1xuICAgICAgICBpZiAoIWUuYmlnZmlsZSAmJiB0aGlzLnppcCkge1xuXG4gICAgICAgICAgdGhpcy56aXAuZW5kKCk7XG4gICAgICAgICAgY29uc29sZS5sb2coJ3ppcGVuZCcsIHRoaXMuemlwKVxuICAgICAgICAgIGNvbnNvbGUubG9nKCdmc3RyZW0nLCB0aGlzLmZpbGVzdHJlYW0pXG4gICAgICAgIH0gZWxzZSBpZiAoZS5iaWdmaWxlICYmIHRoaXMuZ3ppcHBlZCkgY29uc29sZS5sb2coJy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1nemlwcGVkIGVuZCAnLCB0aGlzLmd6aXBwZWQpXG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSB7XG4gICAgICAgICAgbmFtZTogdGhpcy5ldmVudG5hbWVzLnNlbmRmaWxlXG4gICAgICAgIH07XG4gICAgICAgIGlmIChlLnBhcnQpIHtcbiAgICAgICAgICBtZXNzYWdlW1wicGFydFwiXSA9IGUucGFydDtcbiAgICAgICAgfSBlbHNlIHRoaXMucGFydCA9IDA7XG4gICAgICAgIGlmIChlLmhhc093blByb3BlcnR5KFwiYmlnZmlsZVwiKSkgbWVzc2FnZVtcImJpZ2ZpbGVcIl0gPSBlLmJpZ2ZpbGU7XG4gICAgICAgIGlmIChlLmhhc093blByb3BlcnR5KFwicGF0aFwiKSkgbWVzc2FnZVtcInBhdGhcIl0gPSBlLnBhdGg7XG4gICAgICAgIGNvbnNvbGUubG9nKCdlbmR6aXAlJSUlJSUlJSUlJSUlJSUlJSUlJSUlJSUlJSUlJSUlJSUlJywgZSlcbiAgICAgICAgdGhpcy5lbWl0KHRoaXMuZXZlbnRuYW1lcy5jb21wbGV0ZSwgbWVzc2FnZSk7XG4gICAgICB9KTtcblxuICAgICAgdGhpcy5vbih0aGlzLmV2ZW50bmFtZXMuc2VuZGZpbGUsIGFzeW5jIChlKSA9PiB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdldmVudHNlbmRmaWxlJywgZSlcbiAgICAgICAgbGV0IGZpbGUgPSAoZS5iaWdmaWxlKSA/IGF3YWl0IHRoaXMuZ2V0RmlsZSh0aGlzLmd6aXBwZWQpOiBhd2FpdCB0aGlzLmdldEZpbGUoKTtcbiAgICAgICAgY29uc29sZS5sb2coJ3NlbmRmaWxlJywgZmlsZSlcbiAgICAgICAgLyogaWYgKGUuYmlnZmlsZSkgdGhpcy5zZW5kQ2h1bmsoKGUucGF0aCA/IGUucGF0aCA6ICcnKSk7XG4gICAgICAgICAgZWxzZSAqL1xuICAgICAgICB0aGlzLnNlbmRaaXBGaWxlKGZpbGUsIChlLnBhdGggPyBlLnBhdGggOiAnJyksIG51bGwsIChlLmJpZ2ZpbGUgPyBlLmJpZ2ZpbGUgOiBmYWxzZSkpO1xuICAgICAgfSk7XG4gICAgICB0aGlzLm9uKHRoaXMuZXZlbnRuYW1lcy5iaWdmaWxlLCAoZSkgPT4ge1xuICAgICAgICBjb25zb2xlLmxvZygnb25zZW5kY2h1bmsnLCBlKVxuICAgICAgICB0aGlzLnNlbmRDaHVuaygoZS5wYXRoID8gZS5wYXRoIDogJycpKTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5vbih0aGlzLmV2ZW50bmFtZXMuZW5kcmVhZGRpciwgKGUpID0+IHtcbiAgICAgICAgdGhpcy5lbmRyZWFkZGlyID0gdHJ1ZTtcbiAgICAgICAgaWYgKGUuaGFzT3duUHJvcGVydHkoJ25hbWUnKSAmJiBlLm5hbWUgPT09IHRoaXMuZXZlbnRuYW1lcy5lbmR6aXApIHtcbiAgICAgICAgICB0aGlzLmVtaXQodGhpcy5ldmVudG5hbWVzLmNvbXBsZXRlLCB7XG4gICAgICAgICAgICBuYW1lOiB0aGlzLmV2ZW50bmFtZXMuZW5kemlwXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgdGhpcy5vbih0aGlzLmV2ZW50bmFtZXMuY291bnRlciwgYXN5bmMgKGUpID0+IHtcbiAgICAgICAgdGhpcy5jb3VudGVyW2UubmFtZV0gKz0gMTtcbiAgICAgICAgaWYgKHRoaXMuZW5kcmVhZGRpciAmJiBlLm5hbWUgPT09ICd6aXAnICYmIHRoaXMuY291bnRlci5zY2FuID09PSB0aGlzLmNvdW50ZXIuemlwKSB7XG4gICAgICAgICAgY29uc29sZS5sb2coJ2VuZCcsIHRoaXMuY291bnRlcilcbiAgICAgICAgICB0aGlzLmVtaXQodGhpcy5ldmVudG5hbWVzLmNvbXBsZXRlLCB7XG4gICAgICAgICAgICBuYW1lOiB0aGlzLmV2ZW50bmFtZXMuZW5kemlwXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGUubmFtZSA9PT0gJ3ppcCcgJiYgdGhpcy5jYWxsYmFjaykgYXdhaXQgdGhpcy5jYWxsYmFjaygpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgYXN5bmMgcXVvdGFFc3RpbWF0ZSgpIHtcblxuICAgIGlmIChuYXZpZ2F0b3IgJiYgbmF2aWdhdG9yLnN0b3JhZ2UgJiYgbmF2aWdhdG9yLnN0b3JhZ2UuZXN0aW1hdGUpIHtcbiAgICAgIG5hdmlnYXRvci5zdG9yYWdlLmVzdGltYXRlKCkudGhlbigocXVvdGEpID0+IHtcbiAgICAgICAgY29uc3QgcGVyY2VudGFnZVVzZWQgPSAoKHF1b3RhLnVzYWdlIC8gcXVvdGEucXVvdGEpICogMTAwKS50b0ZpeGVkKDIpO1xuICAgICAgICBjb25zdCByZW1haW5pbmcgPSBmb3JtYXRfYnl0ZXMocXVvdGEucXVvdGEgLSBxdW90YS51c2FnZSk7XG4gICAgICAgIHRoaXMuZW1pdCh0aGlzLmV2ZW50bmFtZXMubWVzc2FnZSwge1xuICAgICAgICAgIGlkOiBcInF1b3RhXCIsXG4gICAgICAgICAgbmFtZTogXCJjb25zb2xlXCIsXG4gICAgICAgICAgbWVzc2FnZTogXCJ5b3UndmUgdXNlZCBcIiArIHBlcmNlbnRhZ2VVc2VkICsgXCIlIG9mIHRoZSBhdmFpbGFibGUgc3RvcmFnZSAoXCIgKyByZW1haW5pbmcgKyBcIikuXCJcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICBhc3luYyBpbml0U3RvcmFnZSgpIHtcbiAgICBpZiAobmF2aWdhdG9yICYmIG5hdmlnYXRvci5zdG9yYWdlICYmIG5hdmlnYXRvci5zdG9yYWdlLmVzdGltYXRlKSB7XG4gICAgICBhd2FpdCB0aGlzLmNsZWFuU3RvcmFnZSgpO1xuICAgICAgdGhpcy5lbWl0KHRoaXMuZXZlbnRuYW1lcy5yZWFkeSk7XG4gICAgICB0aGlzLnF1b3RhRXN0aW1hdGUoKTtcbiAgICB9IGVsc2UgdGhpcy5lbWl0KHRoaXMuZXZlbnRuYW1lcy5tZXNzYWdlLCB7XG4gICAgICBuYW1lOiBcImVycm9yXCIsXG4gICAgICBtZXNzYWdlOiBcIm5vIG5hdmlnYXRvciBzdG9yYWdlXCJcbiAgICB9KTtcbiAgfVxuICBhc3luYyBjcmVhdGVMb2NhbFN0cmVhbShuYW1lLCBhY2NlcHQgPSB7XG4gICAgJ2FwcGxpY2F0aW9uL3ppcCc6IFsnLnppcCddLFxuICB9KSB7XG4gICAgY29uc3Qgcm9vdCA9IGF3YWl0IG5hdmlnYXRvci5zdG9yYWdlLmdldERpcmVjdG9yeSgpO1xuICAgIGNvbnN0IG9wdHMgPSB7XG4gICAgICB0eXBlczogW3tcbiAgICAgICAgZGVzY3JpcHRpb246ICdUZW1wIGZpbGUnLFxuICAgICAgICBhY2NlcHQ6IGFjY2VwdCxcbiAgICAgIH0sIF0sXG4gICAgICBjcmVhdGU6IHRydWVcbiAgICB9O1xuICAgIGNvbnN0IGZpbGVzdHJlYW0gPSBhd2FpdCByb290LmdldEZpbGVIYW5kbGUobmFtZSwgb3B0cyk7XG4gICAgY29uc3Qgc3RyZWFtaGFuZGxlID0gYXdhaXQgZmlsZXN0cmVhbS5jcmVhdGVXcml0YWJsZSgpO1xuICAgIHJldHVybiB7XG4gICAgICBmaWxlc3RyZWFtLFxuICAgICAgc3RyZWFtaGFuZGxlXG4gICAgfTtcbiAgfVxuICBhc3luYyBzY2FuQ29tbW9uKGlzX2RpciwgemlwbmFtZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgdGhpcy5lbmRyZWFkZGlyID0gZmFsc2U7XG4gICAgdGhpcy5jb3VudGVyLnNjYW4gPSB0aGlzLmNvdW50ZXIuemlwID0gMDtcbiAgICBpZiAodGhpcy56aXAgPT09IG51bGwpIHtcbiAgICAgIGNvbnN0IHR5cGUgPSAob3B0aW9ucyAmJiBvcHRpb25zLnR5cGUpID8gb3B0aW9ucy50eXBlIDogJy56aXAnO1xuICAgICAgdGhpcy56aXBuYW1lID0gKChvcHRpb25zLnppcG5hbWUpID8gb3B0aW9ucy56aXBuYW1lIDogemlwbmFtZSkgKyB0eXBlOyAvL1xuICAgICAgY29uc3QgemlwaW5zdG9yYWdlID0gYXdhaXQgdGhpcy5zZWFyY2hTdG9yYWdlKHRoaXMuemlwbmFtZSk7XG4gICAgICBpZiAoemlwaW5zdG9yYWdlKSB0aGlzLnppcG5hbWUgPSAnMV8nICsgdGhpcy56aXBuYW1lO1xuICAgICAgY29uc3Qge1xuICAgICAgICBmaWxlc3RyZWFtLFxuICAgICAgICBzdHJlYW1oYW5kbGVcbiAgICAgIH0gPSBhd2FpdCB0aGlzLmNyZWF0ZUxvY2FsU3RyZWFtKHRoaXMuemlwbmFtZSk7XG5cbiAgICAgIHRoaXMuZmlsZXN0cmVhbSA9IGZpbGVzdHJlYW07XG4gICAgICB0aGlzLnN0cmVhbWhhbmRsZSA9IHN0cmVhbWhhbmRsZTtcbiAgICAgIGxldCBzaXplID0gMDtcbiAgICAgIHRoaXMucGFydCA9IDA7XG4gICAgICBhd2FpdCB0aGlzLmluaXRaaXAoKTtcbiAgICAgIGlmICghdGhpcy5qc1NjYW5EaXIpIHtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIEpzU2NhbkRpclxuICAgICAgICB9ID0gYXdhaXQgaW1wb3J0KCcuLi9maWxlcy9qcy1zY2FuZGlyLmpzJyk7XG4gICAgICAgIHRoaXMuanNTY2FuRGlyID0gbmV3IEpzU2NhbkRpcigpO1xuICAgICAgfVxuICAgICAgdGhpcy5qc1NjYW5EaXIucHJvY2Vzc0ZpbGUgPSBhc3luYyAoZW50cnksIGNhbGxiYWNrKSA9PiB7XG4gICAgICAgIHRoaXMuY2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICAgICAgYXdhaXQgdGhpcy5wcm9jZXNzRmlsZShlbnRyeSk7XG5cbiAgICAgIH07XG4gICAgfVxuICB9XG5cbiAgYXN5bmMgc2NhbkZpbGVzKGZpbGVzLCBvcHRpb25zID0ge30pIHtcbiAgICBpZiAoZmlsZXMubGVuZ3RoID09PSAwKSByZXR1cm47XG4gICAgY29uc3QgemlwbmFtZSA9IGZpbGVzWzBdLndlYmtpdFJlbGF0aXZlUGF0aC5zcGxpdChcIi9cIilbMF07XG4gICAgY29uc29sZS5sb2coemlwbmFtZSwgZmlsZXNbMF0pO1xuICAgIGF3YWl0IHRoaXMuc2NhbkNvbW1vbihmYWxzZSwgemlwbmFtZSwgb3B0aW9ucyk7XG4gICAgZm9yIChsZXQgbiA9IDA7IG4gPCBmaWxlcy5sZW5ndGg7IG4rKykge1xuICAgICAgaWYgKG4gPT09IGZpbGVzLmxlbmd0aCAtIDEpIHRoaXMuZW1pdCh0aGlzLmV2ZW50bmFtZXMuZW5kcmVhZGRpciwge30pO1xuICAgICAgYXdhaXQgdGhpcy5hZGRGaWxlVG9aaXBTdHJlYW0oZmlsZXNbbl0sIGZpbGVzW25dLndlYmtpdFJlbGF0aXZlUGF0aCk7XG4gICAgfVxuXG4gIH1cblxuICBhc3luYyBzY2FuSGFuZGxlKGRpciwgb3B0aW9ucyA9IHt9KSB7XG4gICAgYXdhaXQgdGhpcy5zY2FuQ29tbW9uKHRydWUsIGRpci5uYW1lLCBvcHRpb25zKTtcbiAgICBhd2FpdCB0aGlzLmpzU2NhbkRpci5yZWFkRGlyZWN0b3J5KGRpciwgKCkgPT4ge1xuICAgICAgdGhpcy5lbWl0KHRoaXMuZXZlbnRuYW1lcy5lbmRyZWFkZGlyLCB7XG4gICAgICAgIG5hbWU6IHRoaXMuZXZlbnRuYW1lcy5lbmR6aXBcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gIH1cbiAgYXN5bmMgc2VuZEJpZ0ZpbGUoZmlsZSwgZmlsZXBhdGgpIHtcbiAgICBjb25zb2xlLmxvZygnc2VuZGJpZ2ZpbGVwYXRoJywgZmlsZXBhdGgpXG4gICAgdGhpcy5kdCA9IERhdGUubm93KCk7XG4gICAgZmlsZXBhdGggPSAoZmlsZXBhdGguaW5kZXhPZignLycpID09PSAwKSA/IGZpbGVwYXRoLnN1YnN0cigxKSA6IGZpbGVwYXRoO1xuICAgIC8qbGV0IGZpbGVwYXRoID0gZmlsZS53ZWJraXRSZWxhdGl2ZVBhdGg7XG4gICAgZmlsZXBhdGggPSAoZmlsZXBhdGggPT09ICcnKSA/IGRpcm5hbWUgKyAnLycgKyBmaWxlLm5hbWUgOiBmaWxlcGF0aDsqL1xuICAgIGNvbnN0IGV4dCA9IGZpbGUubmFtZS5zbGljZShmaWxlLm5hbWUubGFzdEluZGV4T2YoJy4nKSArIDEpO1xuICAgIGlmIChhbHJlYWR5X2NvbXByZXNzZWQuaGFzKGV4dCkpIHtcbiAgICAgIHRoaXMuZ3ppcHBlZCA9IGZpbGU7XG4gICAgICB0aGlzLmVtaXQodGhpcy5ldmVudG5hbWVzLmNvdW50ZXIsIHtcbiAgICAgICAgbmFtZTogJ3ppcCcsXG4gICAgICAgIGZpbGVwYXRoOiBmaWxlcGF0aCxcbiAgICAgICAgc2l6ZTogZmlsZS5zaXplXG4gICAgICB9KTtcbiAgICAgIHRoaXMuZW1pdCh0aGlzLmV2ZW50bmFtZXMuY29tcGxldGUsIHtcbiAgICAgICAgbmFtZTogdGhpcy5ldmVudG5hbWVzLmJpZ2ZpbGUsXG4gICAgICAgIGJpZ2ZpbGU6IGZpbGVwYXRoXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5lbWl0KHRoaXMuZXZlbnRuYW1lcy5nemlwLCB7XG4gICAgICAgIG5hbWU6IHRoaXMuZXZlbnRuYW1lcy5nemlwLFxuICAgICAgICBiaWdmaWxlOiBmaWxlcGF0aCxcbiAgICAgICAgc2l6ZTogZmlsZS5zaXplXG4gICAgICB9KTtcbiAgICAgIGxldCB6aXBuYW1lID0gZmlsZS5uYW1lLnNwbGl0KGV4dCk7XG4gICAgICB6aXBuYW1lLnBvcCgpO1xuICAgICAgemlwbmFtZSA9IHppcG5hbWUuam9pbihleHQpICsgJ2d6JztcbiAgICAgIGNvbnNvbGUubG9nKCdiaWdmaWxlIGV4dD0nICsgZXh0LCB6aXBuYW1lKVxuICAgICAgY29uc3Qge1xuICAgICAgICBmaWxlc3RyZWFtLFxuICAgICAgICBzdHJlYW1oYW5kbGVcbiAgICAgIH0gPSBhd2FpdCB0aGlzLmNyZWF0ZUxvY2FsU3RyZWFtKHppcG5hbWUsIHtcbiAgICAgICAgJ2FwcGxpY2F0aW9uL2d6aXAnOiBbJy5neiddLFxuICAgICAgfSk7XG4gICAgICBsZXQgcG9zID0gMDtcbiAgICAgIGNvbnN0IHNlbGZpID0gdGhpcztcbiAgICAgIGNvbnN0IGd6aXBwZWQgPSBuZXcgR3ppcCh7XG4gICAgICAgIGxldmVsOiA5LFxuICAgICAgICBmaWxlbmFtZTogZmlsZXBhdGhcbiAgICAgIH0pO1xuICAgICAgZ3ppcHBlZC5vbmRhdGEgPSAoZGF0YSwgZmluYWwpID0+IHtcbiAgICAgICAgaWYgKGZpbmFsKSB7XG4gICAgICAgICAgY29uc29sZS5sb2coJ2ZpbmFsIEJJR0ZJTEUlJSUlJSUlJSUlJSUlJSUlJSUlJScgKyBzZWxmaS5ldmVudG5hbWVzLmJpZ2ZpbGUsIGZpbGVwYXRoKVxuICAgICAgICAgIHNlbGZpLmVtaXQoc2VsZmkuZXZlbnRuYW1lcy5jb21wbGV0ZSwge1xuICAgICAgICAgICAgbmFtZTogc2VsZmkuZXZlbnRuYW1lcy5iaWdmaWxlLFxuICAgICAgICAgICAgYmlnZmlsZTogZmlsZXBhdGhcblxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgc3RyZWFtaGFuZGxlLmNsb3NlKCk7XG4gICAgICAgICAgY29uc29sZS5sb2coJ3RpbWV0b3ppcCcsIChEYXRlLm5vdygpIC0gdGhpcy5kdCkgLyAxMDAwKVxuICAgICAgICAgIHNlbGZpLmd6aXBwZWQgPSBmaWxlc3RyZWFtO1xuICAgICAgICAgIGNvbnNvbGUubG9nKCdiaWcgZmlsZSAqKioqKioqKioqKioqKioqKioqJyArIGZpbGVwYXRoLCBzZWxmaS5nemlwcGVkKTtcblxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN0cmVhbWhhbmRsZS53cml0ZShkYXRhLCB7XG4gICAgICAgICAgICBhdDogcG9zXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcG9zICs9IGRhdGEubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgYXdhaXQgdGhpcy5yZWFkRmlsZShmaWxlLCBmaWxlcGF0aCwgZ3ppcHBlZCk7XG4gICAgfVxuXG5cbiAgfVxuICBhc3luYyBwYXJ0WmlwKCkge1xuICAgIHRoaXMucGFydCArPSAxO1xuICAgIHRoaXMuZW1pdCh0aGlzLmV2ZW50bmFtZXMuY29tcGxldGUsIHtcbiAgICAgIG5hbWU6IHRoaXMuZXZlbnRuYW1lcy5lbmR6aXAsXG4gICAgICBwYXJ0OiB0aGlzLnBhcnRcbiAgICB9KTtcbiAgfVxuICBhc3luYyByZWFkRmlsZShmaWxlLCBmaWxlcGF0aCwgemlwcGVkc3RyZWFtKSB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgY29uc3QgcmVhZGVyID0gZmlsZS5zdHJlYW0oKS5nZXRSZWFkZXIoKTtcbiAgICBsZXQgcGF1c2UgPSBmYWxzZTtcbiAgICAvKiAgb25CYWNrcHJlc3N1cmUoemlwcGVkc3RyZWFtLCB0aGlzLnN0cmVhbWhhbmRsZSwgc2hvdWxkX2FwcGx5X2JhY2twcmVzc3VyZSA9PiB7XG4gICAgICAgIGlmIChzaG91bGRfYXBwbHlfYmFja3ByZXNzdXJlKSBwYXVzZSA9IHRydWU7XG4gICAgICAgIGVsc2UgaWYgKHBhdXNlKSBwYXVzZSA9IGZhbHNlO1xuICAgICAgfSk7Ki9cbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgY29uc3Qge1xuICAgICAgICBkb25lLFxuICAgICAgICB2YWx1ZVxuICAgICAgfSA9IGF3YWl0IHJlYWRlci5yZWFkKCk7XG4gICAgICBpZiAoZG9uZSkge1xuICAgICAgICB6aXBwZWRzdHJlYW0ucHVzaChuZXcgVWludDhBcnJheSgwKSwgdHJ1ZSk7XG4gICAgICAgIHNlbGYuZW1pdChzZWxmLmV2ZW50bmFtZXMuY291bnRlciwge1xuICAgICAgICAgIG5hbWU6ICd6aXAnLFxuICAgICAgICAgIGZpbGVwYXRoOiBmaWxlcGF0aCxcbiAgICAgICAgICBzaXplOiAoemlwcGVkc3RyZWFtLnNpemUpID8gemlwcGVkc3RyZWFtLnNpemUgOiBmaWxlLnNpemVcbiAgICAgICAgfSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgemlwcGVkc3RyZWFtLnB1c2godmFsdWUpO1xuICAgIH1cbiAgfVxuICBhc3luYyB6aXBTdHJlYW0oZmlsZSwgZmlsZXBhdGgpIHtcbiAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICBjb25zdCBleHQgPSBmaWxlcGF0aC5zbGljZShmaWxlcGF0aC5sYXN0SW5kZXhPZignLicpICsgMSk7XG4gICAgY29uc3QgaXNjb21wcmVzc2VkID0gYWxyZWFkeV9jb21wcmVzc2VkLmhhcyhleHQpO1xuICAgIGNvbnN0IHppcHBlZHN0cmVhbSA9IChpc2NvbXByZXNzZWQpID8gbmV3IFppcFBhc3NUaHJvdWdoKGZpbGVwYXRoKSA6IGZpbGUuc2l6ZSA+IHRoaXMub3B0aW9ucy5sYXJnZWZpbGUgP1xuICAgICAgbmV3IEFzeW5jWmlwRGVmbGF0ZShmaWxlcGF0aCwge1xuICAgICAgICBsZXZlbDogNixcbiAgICAgIH0pIDogbmV3IFppcERlZmxhdGUoZmlsZXBhdGgsIHtcbiAgICAgICAgbGV2ZWw6IDZcbiAgICAgIH0pO1xuICAgIHRoaXMuemlwLmFkZCh6aXBwZWRzdHJlYW0pO1xuICAgIGF3YWl0IHRoaXMucmVhZEZpbGUoZmlsZSwgZmlsZXBhdGgsIHppcHBlZHN0cmVhbSk7XG4gIH1cblxuICBhc3luYyBhZGRGaWxlVG9aaXBTdHJlYW0oZmlsZSwgZmlsZXBhdGgpIHtcbiAgICBjb25zb2xlLmxvZygnZW1pdHNjYW4nLCB0aGlzLmNvdW50ZXIpXG4gICAgdGhpcy5lbWl0KHRoaXMuZXZlbnRuYW1lcy5jb3VudGVyLCB7XG4gICAgICBuYW1lOiAnc2NhbicsXG4gICAgICBmaWxlcGF0aDogZmlsZXBhdGgsXG4gICAgICBzaXplOiBmaWxlLnNpemVcbiAgICB9KTtcbiAgICB0aGlzLmNvbnRpbnVlID0gbnVsbDtcbiAgICAvLyBjaGVjayBmaWxlIHNpemUgPiBtYXggcG9zdCBzaXplXG4gICAgaWYgKGZpbGUuc2l6ZSA+PSBNQVhTSVpFKSB7XG4gICAgICBhd2FpdCB0aGlzLnNlbmRCaWdGaWxlKGZpbGUsIGZpbGVwYXRoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gY2hlY2sgemlwIGZpbGUgc2l6ZSA+IHRvdGFsIHppcCBzaXplXG4gICAgICB0aGlzLnNpemV0b3ppcCArPSBmaWxlLnNpemU7XG4gICAgICBpZiAodGhpcy5zaXpldG96aXAgPj0gTUFYU0laRSkge1xuICAgICAgICB0aGlzLmNvbnRpbnVlID0gYXN5bmMgKCkgPT4ge1xuICAgICAgICAgIGF3YWl0IHRoaXMuemlwU3RyZWFtKGZpbGUsIGZpbGVwYXRoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnBhcnRaaXAoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGF3YWl0IHRoaXMuemlwU3RyZWFtKGZpbGUsIGZpbGVwYXRoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBhc3luYyBwcm9jZXNzRmlsZShlbnRyeSkge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgIGNvbnN0IGZpbGVwYXRoID0gZW50cnkuZnVsbFBhdGg7XG4gICAgY29uc3QgZXh0ID0gZmlsZXBhdGguc2xpY2UoZmlsZXBhdGgubGFzdEluZGV4T2YoJy4nKSArIDEpO1xuICAgIGlmICh0aGlzLm9wdGlvbnMuYWNjZXB0LmluY2x1ZGVzKGV4dCkpIHtcbiAgICAgIGNvbnNvbGUubG9nKCdyZWplY3QnLCBmaWxlcGF0aCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChlbnRyeS5pc0RpcmVjdG9yeSkge1xuICAgICAgY29uc29sZS5sb2coJ3ppcGRpcicsIHRoaXMuY2FsbGJhY2spXG4gICAgICBpZiAodGhpcy5jYWxsYmFjayAhPT0gbnVsbCkgYXdhaXQgdGhpcy5jYWxsYmFjaygpO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbnRyeS5maWxlKGFzeW5jIGZpbGUgPT4ge1xuICAgICAgICBhd2FpdCB0aGlzLmFkZEZpbGVUb1ppcFN0cmVhbShmaWxlLCBmaWxlcGF0aCk7XG4gICAgICB9KTtcblxuICAgIH1cbiAgfVxuICBvbkVycm9yKCkge1xuICAgIHRoaXMuY2xlYW5TdG9yYWdlKCk7XG4gICAgdGhpcy5lbWl0KHRoaXMuZXZlbnRuYW1lcy5lcnJvciwge1xuICAgICAgbmFtZTogXCJyZWxvYWRcIlxuICAgIH0pO1xuICB9XG4gIGFzeW5jIHNlYXJjaFN0b3JhZ2Uoc2VhcmNoKSB7XG4gICAgY29uc3QgZW50cnkgPSBhd2FpdCBuYXZpZ2F0b3Iuc3RvcmFnZS5nZXREaXJlY3RvcnkoKTtcbiAgICBmb3IgYXdhaXQgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBlbnRyeS5lbnRyaWVzKCkpIHtcbiAgICAgIGlmIChzZWFyY2ggPT09IGtleSkge1xuICAgICAgICBjb25zb2xlLmxvZygna2V5Jywga2V5KTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIGZhbHNlXG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgYXN5bmMgY2xlYW5TdG9yYWdlKGVudHJ5ID0gbnVsbCkge1xuICAgIHJldHVybjtcbiAgICBlbnRyeSA9IChlbnRyeSkgPyBlbnRyeSA6IGF3YWl0IG5hdmlnYXRvci5zdG9yYWdlLmdldERpcmVjdG9yeSgpO1xuICAgIGZvciBhd2FpdCAoY29uc3QgW2tleSwgdmFsdWVdIG9mIGVudHJ5LmVudHJpZXMoKSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgYXdhaXQgZW50cnkucmVtb3ZlRW50cnkoa2V5KTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCcgcmVtb3ZlIHN0b3JhZ2UgJyArIGtleSwgZXJyb3IpO1xuICAgICAgfVxuICAgIH1cblxuICB9XG5cbiAgYXN5bmMgZW5kRmV0Y2gobWVzc2FnZSwgY2xlYW4gPSBmYWxzZSkge1xuICAgIG1lc3NhZ2UubmFtZSA9IHRoaXMuZXZlbnRuYW1lcy50ZXJtaW5hdGU7XG4gICAgaWYgKG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJiaWdmaWxlXCIpICYmIG1lc3NhZ2UuYmlnZmlsZSAhPT0gXCJcIiAmJlxuICAgICAgbWVzc2FnZS5iaWdmaWxlICE9PSBmYWxzZSAmJiBtZXNzYWdlLmJpZ2ZpbGUgIT09IG51bGwpIHtcbiAgICAgIG1lc3NhZ2VbXCJiaWdmaWxlXCJdID0gdGhpcy5nemlwcGVkLm5hbWU7XG4gICAgICB0aGlzLmd6aXBwZWQgPSBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAodGhpcy5jb250aW51ZSkge1xuICAgICAgICB0aGlzLnN0cmVhbWhhbmRsZSA9IGF3YWl0IHRoaXMuZmlsZXN0cmVhbS5jcmVhdGVXcml0YWJsZSgpO1xuICAgICAgICBhd2FpdCB0aGlzLmluaXRaaXAoKTtcbiAgICAgIH0gZWxzZSB0aGlzLnJlc2V0KCk7XG4gICAgfVxuICAgIHRoaXMuZW1pdCh0aGlzLmV2ZW50bmFtZXMuY29tcGxldGUsIG1lc3NhZ2UpO1xuICAgIGNvbnNvbGUubG9nKCdjb250aW51ZScsIHRoaXMuY29udGludWUpXG4gIH1cblxuICBhc3luYyBzZW5kQ2h1bmsocGF0aCwgc3RhcnQgPSAwLCBjaHVua251bSA9IDAsIGNodW5rc2l6ZSA9IE1BWFNJWkUpIHtcbiAgICBjb25zb2xlLmxvZygnc2VuZCBjaHVuayAnLCB0aGlzLmd6aXBwZWQpXG4gICAgY29uc29sZS5sb2coJ2NodW5rcGF0aCcsIHBhdGgpXG4gICAgY29uc3QgZmlsZSA9ICh0aGlzLmd6aXBwZWQpID8gYXdhaXQgdGhpcy5nZXRGaWxlKHRoaXMuZ3ppcHBlZCk6IGF3YWl0IHRoaXMuZ2V0RmlsZSgpO1xuICAgIGNvbnNvbGUubG9nKCdmaWxlJywgZmlsZSlcbiAgICBwYXRoID0gcGF0aC5zcGxpdCgnLycpO1xuICAgIHBhdGgucG9wKCk7XG4gICAgcGF0aCA9IHBhdGguam9pbignLycpO1xuICAgIGNvbnN0IGVuZCA9IE1hdGgubWluKHN0YXJ0ICsgY2h1bmtzaXplLCBmaWxlLnNpemUpO1xuICAgIGNvbnNvbGUubG9nKCdlbmQtLS0nLCBlbmQpXG4gICAgaWYgKGVuZCA9PT0gZmlsZS5zaXplKSB7XG5cbiAgICAgIHRoaXMuc2VuZFppcEZpbGUoZmlsZSwgcGF0aCwgbnVsbCwgdHJ1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHBhcnRmaWxlID0gZmlsZS5zbGljZShzdGFydCwgZW5kKTtcbiAgICAgIHBhcnRmaWxlLm5hbWUgPSBjaHVua251bSArICdfJyArIGZpbGUubmFtZTtcbiAgICAgIHRoaXMuc2VuZFppcGZpbGUocGFydGZpbGUsIHBhdGgsICgpID0+IHtcbiAgICAgICAgc3RhcnQgKz0gZW5kO1xuICAgICAgICBjaHVua251bSsrO1xuXG4gICAgICAgIGlmIChzdGFydCA8PSBmaWxlLnNpemUpIHRoaXMuc2VuZENodW5rKHBhdGgsIHN0YXJ0LCBjaHVua251bSwgY2h1bmtzaXplKTtcbiAgICAgIH0sIHRydWUpXG4gICAgfVxuICAgIHJldHVybiBjaHVua251bTtcbiAgfVxuICBhc3luYyBnZXRGaWxlKGZpbGVzdHJlYW0gPSBudWxsKSB7XG4gICAgZmlsZXN0cmVhbSA9IChmaWxlc3RyZWFtID09PSBudWxsKSA/IHRoaXMuZmlsZXN0cmVhbSA6IGZpbGVzdHJlYW07XG4gICAgY29uc3QgZmlsZSA9IGF3YWl0IGZpbGVzdHJlYW0uZ2V0RmlsZSgpO1xuICAgIHJldHVybiBmaWxlO1xuICB9XG4gIGFzeW5jIHNlbmRaaXBGaWxlKGZpbGUsIHBhdGgsIGNhbGxiYWNrY2h1bmsgPSBudWxsLCBpc2JpZ2ZpbGUgPSBmYWxzZSkge1xuICAgIGNvbnNvbGUubG9nKCdzZW5kemlwZmlsZS0tLS0tLS0tLS0tLV9fX19fX19fX19fX19fX19fX19fX19fJyArIGlzYmlnZmlsZSwgZmlsZSlcbiAgICBjb25zdCBtZXNzYWdlID0gKGlzYmlnZmlsZSkgPyB7XG4gICAgICBiaWdmaWxlOiBmaWxlLm5hbWVcbiAgICB9IDoge307XG4gICAgdGhpcy5lbWl0KHRoaXMuZXZlbnRuYW1lcy5wZW5kaW5nLCBtZXNzYWdlKTtcbiAgICBjb25zb2xlLmxvZygnZmlsZScsIGZpbGUpXG4gICAgY29uc29sZS5sb2coJ3BhdGgnLCBwYXRoKVxuICAgIGNvbnNvbGUubG9nKCdjYWxsYmFja2NodW5rLS0tc2VuZHppcCcsIGNhbGxiYWNrY2h1bmspXG4gICAgY29uc3QgZm9ybWRhdGEgPSBuZXcgRm9ybURhdGEoKTtcbiAgICBmb3JtZGF0YS5hcHBlbmQoJ3BhdGgnLCBwYXRoICsgZmlsZS5uYW1lKTtcbiAgICBmb3JtZGF0YS5hcHBlbmQoJ2ZpbGUnLCBmaWxlLCBmaWxlLm5hbWUpO1xuICAgIGlmICh0aGlzLnBhcnQpIGZvcm1kYXRhLmFwcGVuZCgncGFydCcsIHRoaXMucGFydCk7XG4gICAgZWxzZSBpZiAoY2FsbGJhY2tjaHVuayAhPT0gbnVsbCkgZm9ybWRhdGEuYXBwZW5kKCdpc2NodW5rJywgdHJ1ZSk7XG4gICAgZmV0Y2godGhpcy5vcHRpb25zLnVwbG9hZHVybCwge1xuICAgICAgLy8gIG1vZGU6ICdjb3JzJyxcbiAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICBjcmVkZW50aWFsczogXCJpbmNsdWRlXCIsXG4gICAgICBib2R5OiBmb3JtZGF0YSxcbiAgICB9KS50aGVuKGFzeW5jIChyZXNwb25zZSkgPT4ge1xuICAgICAgY29uc29sZS5sb2coJ3Jlc3BvbnNlLS0tLS0tLS0tLS0tLS0tLS0tLS0tLScsIHJlc3BvbnNlKTtcbiAgICAgIGNvbnNvbGUubG9nKCdjYWxsYmFja2NodW5rLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLScsIGNhbGxiYWNrY2h1bmspXG4gICAgICBpZiAoY2FsbGJhY2tjaHVuayAhPT0gbnVsbCkge1xuICAgICAgICBhd2FpdCBjYWxsYmFja2NodW5rKCk7XG4gICAgICB9IGVsc2UgYXdhaXQgdGhpcy5lbmRGZXRjaChtZXNzYWdlKTtcbiAgICB9KTtcbiAgfVxufSJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/modules/files/js-dirtozip.js\n")}}]);