/*! For license information please see src_modules_files_js-dirtozip_js.js.LICENSE.txt */
"use strict";(self.webpackChunk=self.webpackChunk||[]).push([["src_modules_files_js-dirtozip_js"],{"./src/modules/files/js-dirtozip.js":(module,__webpack_exports__,__webpack_require__)=>{eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   JsDirToZip: () => (/* binding */ JsDirToZip)\n/* harmony export */ });\n/* harmony import */ var _modules_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../modules/utils.js */ \"./src/modules/utils.js\");\n/* harmony import */ var fflate__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! fflate */ \"./node_modules/fflate/esm/browser.js\");\n/* harmony import */ var _modules_module_event_emitter_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../modules/module-event-emitter.js */ \"./src/modules/module-event-emitter.js\");\n/* harmony import */ var detect_browser__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! detect-browser */ \"./node_modules/detect-browser/es/index.js\");\n/* harmony import */ var _modules_alert_box_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../modules/alert-box.js */ \"./src/modules/alert-box.js\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_modules_module_event_emitter_js__WEBPACK_IMPORTED_MODULE_1__, _modules_alert_box_js__WEBPACK_IMPORTED_MODULE_2__]);\n([_modules_module_event_emitter_js__WEBPACK_IMPORTED_MODULE_1__, _modules_alert_box_js__WEBPACK_IMPORTED_MODULE_2__] = __webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__);\n\n\n\n\n\n\n\nconst already_compressed = new Set([\n  'zip', 'gz', 'png', 'jpg', 'jpeg', 'pdf', 'doc', 'docx', 'ppt', 'pptx',\n  'xls', 'xlsx', 'heic', 'heif', '7z', 'bz2', 'rar', 'gif', 'webp', 'webm',\n  'mp4', 'mov', 'mp3', 'aifc'\n]);\nconst can_be_compressed = new Set(['tsv','txt','log','csv']);\nconst accept = '.tsv,.png,.jpg, .jpeg,.zip,.gz,.7z,.bz2';\n\nfunction JsDirToZip(options = {}) {\n  const MAXSIZE = (document.querySelector('[data-max_upload_size]'))?parseInt(document.querySelector('[data-max_upload_size]').dataset['max_upload_size']):1073741824;//681574400;//681574400; // 650M //1073741824; //4294967296; //// 3221225472; // 2147483648;\n  const UPLOADINPARTS = (document.querySelector('[data-uploadinparts]'))?true:false;\n  const eventnames = {\n    ready: 'ready',\n    follow: 'follow',\n    complete: 'complete',\n    endreaddir: 'endreaddir',\n    gzip: 'gzip',\n    endzip: 'endzip',\n    sendfile: 'sendfile',\n    bigfile: 'bigfile',\n    terminate: 'terminate',\n    pending: 'pending',\n    errorfile: 'errorfile',\n    counter: 'counter',\n    reject: 'reject',\n    message: 'message',\n    error: 'error',\n    init: 'init',\n    setuploadpath:'setuploadpath'\n  };\n  let jsScanDir, properties,uploadpath;\n  let trydelete=0;\n  const defaultOptions = {\n    uploadurl: '/gui/files/upload',\n    largefile: MAXSIZE,\n    accept: accept.split(',')\n  }\n  // uses https://developer.mozilla.org/en-US/docs/Web/API/File_System_API/Origin_private_file_system\n  //# alternative (not supported in Safari) for .createWritable\n  options = { ...defaultOptions,\n    ...options\n  };\n  // other module receiving events\n  const _listener = (options.listener) ? options.listener : uuid;\n  Object.freeze(options);\n  const uuid = (0,_modules_utils_js__WEBPACK_IMPORTED_MODULE_0__.generate_uuid)();\n  initStorage();\n  init();\n\nfunction browserRequired() {\nconst browser = (0,detect_browser__WEBPACK_IMPORTED_MODULE_3__.detect)();\n     const accepted={android:{chrome:109,opera:74,firefox:111,samsungbrowser:21,webview:109}, ios:false,other:{chrome:86,edge:86,opera:72,firefox:111}};\n        let os =browser.os.toLowerCase();\n        os=(os in ['android','ios'])?os:'other';\n     const name=browser.name.toLowerCase();\n     const version = parseInt(browser.version.split('.')[0]);\n     if (Object.keys(accepted).indexOf(os)<0 || Object.keys(accepted[os]).indexOf(name)<0 || parseInt(accepted[os][name])>parseInt(version))  {\n     _modules_module_event_emitter_js__WEBPACK_IMPORTED_MODULE_1__.ModuleEventEmitter.emit(eventnames.message, {\n          id: \"browser\",\n          name: \"browser\",\n          message: \"your browser does not have a required functionnality. Please upgrade or use a valid browser and version :\"+  JSON.stringify(accepted).replaceAll('\"',''),\n        }, _listener);\n     }\n     }\n  function init() {\n    properties = initProps();\n     _modules_module_event_emitter_js__WEBPACK_IMPORTED_MODULE_1__.ModuleEventEmitter.on(eventnames.setuploadpath, async(e) => {\n    uploadpath=e.path;},uuid);\n    _modules_module_event_emitter_js__WEBPACK_IMPORTED_MODULE_1__.ModuleEventEmitter.on(eventnames.init, async (e) => {\n      if (!isActive()) {\n        await reset();\n        _modules_module_event_emitter_js__WEBPACK_IMPORTED_MODULE_1__.ModuleEventEmitter.emit(eventnames.complete, {\n          name: eventnames.ready\n        }, _listener);\n          _modules_module_event_emitter_js__WEBPACK_IMPORTED_MODULE_1__.ModuleEventEmitter.emit(eventnames.message, {\n          name: _modules_alert_box_js__WEBPACK_IMPORTED_MODULE_2__.AlertBox.alertconfig.types.success,\n          message: \"Upload of \"+ e.path +\" is done\",\n        }, _listener);\n        properties.endreaddir = false;\n      } else console.log('partly finished '+properties.hashandlers+ 'follow='+properties.follow, e);\n    }, uuid);\n    _modules_module_event_emitter_js__WEBPACK_IMPORTED_MODULE_1__.ModuleEventEmitter.on(eventnames.endzip, async(e) => {\n      if (!e.bigfile && properties.zip) properties.zip.end();\n      const evtsend=async function() {\n      const zipclosed = await listStorage(null,properties.zipname);\n      if (zipclosed === true) {\n      const message = buildMessage(e, {\n        name: eventnames.sendfile,      });\n\n      _modules_module_event_emitter_js__WEBPACK_IMPORTED_MODULE_1__.ModuleEventEmitter.emit(eventnames.complete, message, _listener);}\n      else setTimeout(async function() {await evtsend();},2000);}\n      evtsend();\n    }, uuid);\n    _modules_module_event_emitter_js__WEBPACK_IMPORTED_MODULE_1__.ModuleEventEmitter.on(eventnames.sendfile, async (e) => {\n      if (properties.hashandlers) {\n        const message = buildMessage(e, {\n            name: eventnames.follow,\n        });\n        _modules_module_event_emitter_js__WEBPACK_IMPORTED_MODULE_1__.ModuleEventEmitter.emit(eventnames.follow, message, _listener);\n        await execHandler();\n      } else { const message = buildMessage(e, {\n        name: eventnames.pending,\n      });\n\n        _modules_module_event_emitter_js__WEBPACK_IMPORTED_MODULE_1__.ModuleEventEmitter.emit(eventnames.complete, message, _listener);\n      }\n\n      const file = await getFile();\n      sendZipFile(file, (e.path ? e.path : uploadpath), null);\n    }, uuid);\n    _modules_module_event_emitter_js__WEBPACK_IMPORTED_MODULE_1__.ModuleEventEmitter.on(eventnames.endreaddir, (e) => {\n      properties.endreaddir = true;\n      checkProcessed(e);\n    }, uuid);\n    _modules_module_event_emitter_js__WEBPACK_IMPORTED_MODULE_1__.ModuleEventEmitter.on(eventnames.counter, async (e) => {\n      properties.endcounter = false;\n      properties.counter[e.name] += 1;\n      _modules_module_event_emitter_js__WEBPACK_IMPORTED_MODULE_1__.ModuleEventEmitter.emit(eventnames.counter, e, _listener);\n      if (e.name === 'zip' && properties.counter.scan === properties.counter.zip) {\n        properties.endcounter = true;\n        checkProcessed(e);\n      }\n      if (e.name === 'zip' && properties.callback) await properties.callback();\n    }, uuid);\n    _modules_module_event_emitter_js__WEBPACK_IMPORTED_MODULE_1__.ModuleEventEmitter.on(eventnames.error,  (e) => {});\n  }\n\n  function initProps() {\n    return {\n      zip: null,\n      zipname: null,\n      filestream: null,\n      streamhandle: null,\n      gzipped: null,\n      sizetozip: 0,\n      part: 0,\n      follow: null,\n      endcounter: false,\n      endreaddir: false,\n      callback: null,\n      pos: 0,\n      counter: {\n        scan: 0,\n        zip: 0,\n        reject: 0,\n        error:0,\n      },\n      handlers: [],\n      hashandlers:false,\n     }\n  }\n  async function reset() {\n    properties = initProps();\n    await initStorage();\n  }\n\n  function isActive() {\n    return (properties.zip !== null || properties.follow !== null || properties.hashandlers || properties.endreaddir !== true);\n  }\n\n  async function initZip() {\n    properties.pos = 0;\n    properties.sizetozip = 0;\n    properties.zip = new fflate__WEBPACK_IMPORTED_MODULE_4__.Zip((error, chunk, final) => {\n      if (error) {\n        onError(eventnames.errorfile, {\n                message: error}, _listener);\n        return false;\n      } else {\n        properties.streamhandle.write(chunk, {\n          at: self.pos\n        });\n        properties.pos += chunk.length;\n        if (final) {\n          properties.streamhandle.close();\n        }\n      }\n    });\n    // hack for memory usage\n    zipOnData();\n    if (properties.follow) await properties.follow();\n  }\n\n  function checkProcessed(e) {\n    if (properties.endreaddir === true) {\n    if(properties.endcounter === true) {\n      const message = buildMessage(e, {\n       name: eventnames.endzip\n      });\n      _modules_module_event_emitter_js__WEBPACK_IMPORTED_MODULE_1__.ModuleEventEmitter.emit(eventnames.complete, message, _listener);\n    }  else if (properties.counter.error>0) endProcess();}\n  }\n\n  function zipOnData(zip = null) {\n    zip = (zip === null) ? properties.zip : zip;\n    const ondata = zip.ondata;\n    zip.ondata = (error, data, final) => {\n      ondata(error, data, final);\n      if (final) {\n        zip.d = null;\n        if (zip.u && zip.u.at(-1)) zip.u.at(-1).d = null; // Object created in `zip.add()`\n      }\n    }\n  }\n\n  function buildMessage(e, message = {}) {\n    if (e.hasOwnProperty(\"part\")) {\n      message.part = e.part;\n    } else properties.part = 0;\n    if (e.hasOwnProperty(\"bigfile\")) message.bigfile = e.bigfile;\n    if (e.hasOwnProperty(\"path\")) message.path = e.path;\n    return message;\n  }\n\n  async function quotaEstimate() {\n    if (navigator && navigator.storage && navigator.storage.estimate) {\n      navigator.storage.estimate().then((quota) => {\n        const percentageUsed = ((quota.usage / quota.quota) * 100).toFixed(2);\n        const remaining = (0,_modules_utils_js__WEBPACK_IMPORTED_MODULE_0__.format_bytes)(quota.quota - quota.usage);\n        _modules_module_event_emitter_js__WEBPACK_IMPORTED_MODULE_1__.ModuleEventEmitter.emit(eventnames.message, {\n          id: \"quota\",\n          name: \"console\",\n          message: \"you've used \" + percentageUsed + \"% of the available browser storage necessary to locally compress files (\" + remaining + \").\",\n        }, _listener);\n      });\n    }\n  }\n\n  async function initStorage() {\n    if (navigator && navigator.storage && navigator.storage.estimate) {\n      await cleanStorage();\n      quotaEstimate();\n    } else _modules_module_event_emitter_js__WEBPACK_IMPORTED_MODULE_1__.ModuleEventEmitter.emit(eventnames.message, {\n      name: \"error\",\n      message: \"no navigator storage\"\n    }, uuid);\n  }\n\n  async function createLocalStream(name, accept = {\n    'application/zip': ['.zip'],\n  }) {\n    const root = await navigator.storage.getDirectory();\n    const opts = {\n      types: [{\n        description: 'Temp file',\n        accept: accept,\n      }, ],\n      create: true\n    };\n    const filestream = await root.getFileHandle(name, opts);\n    const streamhandle = await filestream.createWritable({mode:\"exclusive\"});\n    return {\n      filestream,\n      streamhandle\n    };\n  }\n  async function scanCommon(zipname, options = {}) {\n    properties.endreaddir = false;\n    if (properties.zip === null) {\n      zipname = zipname.split(_modules_utils_js__WEBPACK_IMPORTED_MODULE_0__.dirseparator)[0];\n      zipname = (zipname.trim() === ``) ? 'temp' : zipname;\n      const type = (options && options.type) ? options.type : '.zip';\n      properties.zipname = ((options.zipname) ? options.zipname : zipname) + type; //\n      const zipinstorage = await searchStorage(properties.zipname);\n      if (zipinstorage) properties.zipname = '1_' + properties.zipname;\n      const {\n        filestream,\n        streamhandle\n      } = await createLocalStream(properties.zipname);\n      properties.filestream = filestream;\n      properties.streamhandle = streamhandle;\n      let size = 0;\n      properties.part = 0;\n      await initZip();\n      if (!jsScanDir) {\n        const {\n          JsScanDir\n        } = await __webpack_require__.e(/*! import() */ \"src_modules_files_js-scandir_js\").then(__webpack_require__.bind(__webpack_require__, /*! ../files/js-scandir.js */ \"./src/modules/files/js-scandir.js\"));\n        const process_file = async (entry, callback) => {\n          if (acceptFile(entry)) {\n            properties.callback = callback;\n            await processFile(entry);\n          } else rejectFile(entry, callback);\n        }\n        jsScanDir = JsScanDir(process_file);\n      }\n    }\n  }\n\n  async function scanBrowse(pick, options = {}) {\n    const entries = (pick instanceof FileList) ? Array.from(pick) : (pick.kind === \"directory\") ? await Array.fromAsync(pick.values()): (Array.isArray(pick)) ? pick : [pick];\n    const name = entries[0].name;\n    let relpath = (pick instanceof FileList) ? entries[0].webkitRelativePath : null;\n    relpath = (relpath) ? relpath.split(_modules_utils_js__WEBPACK_IMPORTED_MODULE_0__.dirseparator) : [``];\n    if (relpath.length) relpath.pop();\n    relpath = relpath.join(_modules_utils_js__WEBPACK_IMPORTED_MODULE_0__.dirseparator);\n    const path = (pick instanceof FileList) ? relpath : (pick.kind === \"directory\") ? pick.name : ``;\n    await scanCommon(path, options);\n    await jsScanDir.processEntries(entries, path, () => {\n      dirComplete();\n    });\n  }\n\n  async function scanHandle(dropped, options = {}) {\n    await scanCommon(dropped.name, options);\n    if (dropped.isDirectory === true) {\n      await jsScanDir.readDirectory(dropped, () => {\n        dirComplete();\n      });\n    } else if (dropped.isFile === true) {\n      await jsScanDir.processFile(dropped, () => {\n        dirComplete();\n      });\n    }\n  }\n\n  function dirComplete() {\n    _modules_module_event_emitter_js__WEBPACK_IMPORTED_MODULE_1__.ModuleEventEmitter.emit(eventnames.endreaddir, {\n      name: eventnames.endreaddir\n    }, uuid);\n  }\n\n  function addHandler(handler) {\n    properties.handlers.push(handler);\n    properties.hashandlers= (properties.handlers.length>0)\n  }\n\n  async function execHandler() {\n    // serie\n    if (properties.hashandlers) {\n      const handler = properties.handlers.shift();\n      await handler();\n     properties.hashandlers = (properties.handlers.length>0)\n    }\n    return;\n  }\n    async function gzipBigFile(file, filepath) {\n    let dt = Date.now();\n    filepath = (filepath.indexOf(_modules_utils_js__WEBPACK_IMPORTED_MODULE_0__.dirseparator) === 0) ? filepath.substr(1) : filepath;\n    const parts = filepath.split(_modules_utils_js__WEBPACK_IMPORTED_MODULE_0__.dirseparator);\n    parts.pop();\n    const sendpath = uploadpath + _modules_utils_js__WEBPACK_IMPORTED_MODULE_0__.dirseparator +parts.join(_modules_utils_js__WEBPACK_IMPORTED_MODULE_0__.dirseparator);\n    const ext = file.name.slice(file.name.lastIndexOf('.') + 1);\n    if (already_compressed.has(ext)) {\n       _modules_module_event_emitter_js__WEBPACK_IMPORTED_MODULE_1__.ModuleEventEmitter.emit(eventnames.counter, {\n        name: 'zip',\n        path: filepath,\n        bigfile:file.name,\n        size: file.size\n      }, uuid);\n      addHandler(async () => {\n        await sendChunk(sendpath,file);\n      });\n    } else {\n      let zipname = file.name + '.gz';\n      const {\n        filestream,\n        streamhandle\n      } = await createLocalStream(zipname, {\n        'application/gzip': ['.gz'],\n      });\n      let pos = 0;\n\n      const gzipped = new fflate__WEBPACK_IMPORTED_MODULE_4__.AsyncGzip({\n        level: 6,\n        filename: filepath\n      });\n      gzipped.ondata = (err, data, final) => {\n       if(pos > MAXSIZE)  {\n                properties.counter.error+=1;\n              onError(_modules_alert_box_js__WEBPACK_IMPORTED_MODULE_2__.AlertBox.alertconfig.types.error, {\n\n                name:_modules_alert_box_js__WEBPACK_IMPORTED_MODULE_2__.AlertBox.alertconfig.types.error,\n                bigfile:file.name,\n                path:filepath,\n                message:'File '+file.name+' size exceeds maxsize. Cannot be sent in chunks for the moment.'}, _listener);\n          streamhandle.close();gzipped.ondata= (err, data, final) => {}; return endProcess();\n          }\n        if (err) {\n            properties.counter.error+=1;\n          onError(_modules_alert_box_js__WEBPACK_IMPORTED_MODULE_2__.AlertBox.alertconfig.types.error, {\n            name:_modules_alert_box_js__WEBPACK_IMPORTED_MODULE_2__.AlertBox.alertconfig.types.error,\n            bigfile: file.name,\n            path: filepath,\n            size: file.size,\n            message: 'Error compressing file '+ file.name +' '+err\n          });\n        } else {\n          streamhandle.write(data, {\n            at: pos\n          });\n          pos += data.length;\n          if (final) {\n            streamhandle.close();\n                 filepath+='.gz';\n                _modules_module_event_emitter_js__WEBPACK_IMPORTED_MODULE_1__.ModuleEventEmitter.emit(eventnames.counter, {\n              name: 'zip',\n              path: filepath,\n              size: file.size,\n              bigfile:file.name\n            }, uuid);\n\n         addHandler(async () => {\n         await sendChunk(sendpath,filestream);\n            });\n          }\n        }\n      };\n      const count = false;\n      await readFile(file, filepath, gzipped, count);\n    }\n  }\n  async function partZip() {\n    properties.part += 1;\n    _modules_module_event_emitter_js__WEBPACK_IMPORTED_MODULE_1__.ModuleEventEmitter.emit(eventnames.complete, {\n     name: eventnames.endzip,\n      part: properties.part\n    }, _listener);\n  }\n  async function readFile(file, filepath, zippedstream, count = true) {\n    const reader = file.stream().getReader();\n    let pause = false;\n    /*  onBackpressure(zippedstream, this.streamhandle, should_apply_backpressure => {\n        if (should_apply_backpressure) pause = true;\n        else if (pause) pause = false;\n      });*/\n    while (true) {\n      const {\n        done,\n        value\n      } = await reader.read();\n      if (done) {\n        zippedstream.push(new Uint8Array(0), true);\n        if (count === true) _modules_module_event_emitter_js__WEBPACK_IMPORTED_MODULE_1__.ModuleEventEmitter.emit(eventnames.counter, {\n          name: 'zip',\n          path: filepath,\n          size: (zippedstream.size) ? zippedstream.size : file.size\n        }, uuid);\n        break;\n      }\n      zippedstream.push(value);\n    }\n  }\n\n  async function zipStream(file, filepath) {\n    const ext = filepath.slice(filepath.lastIndexOf('.') + 1);\n    const iscompressed = already_compressed.has(ext);\n    const zippedstream = (iscompressed) ? new fflate__WEBPACK_IMPORTED_MODULE_4__.ZipPassThrough(filepath) : file.size > options.largefile ?\n      new fflate__WEBPACK_IMPORTED_MODULE_4__.AsyncZipDeflate(filepath, {\n        level: 6,\n      }) : new fflate__WEBPACK_IMPORTED_MODULE_4__.ZipDeflate(filepath, {\n        level: 6\n      });\n      properties.zip.add(zippedstream);\n    await readFile(file, filepath, zippedstream);\n  }\n  function compressed_estimate(file) {\n    const ext = file.name.slice(file.name.lastIndexOf('.') + 1);\n    if (can_be_compressed.has(ext)) return Math.floor(file.size/2);\n    return file.size;\n  }\n  async function addFileToZipStream(file, filepath, count = true) {\n    if (count === true) _modules_module_event_emitter_js__WEBPACK_IMPORTED_MODULE_1__.ModuleEventEmitter.emit(eventnames.counter, {\n      name: 'scan',\n      path: filepath,\n      size: file.size\n    }, uuid);\n    properties.follow = null;\n\n    // check file size > max post size\n    const compressed_size = compressed_estimate(file);\n    if (compressed_size >= MAXSIZE ) {\n    // to prevent errors and uncomplete zip send error\n      properties.counter.error+=1;\n      if(UPLOADINPARTS) gzipBigFile(file, filepath);\n      else endProcess();\n    } else {\n      // check zip file size > total zip size\n      properties.sizetozip += compressed_size;\n      if (properties.sizetozip > MAXSIZE) {\n      if(UPLOADINPARTS) {\n      properties.follow = async () => {\n          await zipStream(file, filepath);\n        }\n        partZip();\n        } else endProcess();\n      } else {\n        await zipStream(file, filepath);\n      }\n    }\n  }\n\n  function acceptFile(entry) {\n    const filepath = entry.name;\n    const ext = filepath.slice(filepath.lastIndexOf('.') + 1);\n    return accept.includes(ext);\n  }\n\n  function rejectFile(file, callback = null) {\n    const path = (file.fullPath) ? file.fullPath : file.webkitRelativePath;\n    properties.counter.reject += 1;\n    _modules_module_event_emitter_js__WEBPACK_IMPORTED_MODULE_1__.ModuleEventEmitter.emit(eventnames.reject, {\n      name: eventnames.reject,\n      path: path,\n    }, _listener);\n    if (callback !== null) callback();\n  }\n  async function processFile(entry) {\n    const entrypath = (entry.fullPath) ? entry.fullPath : entry.webkitRelativePath;\n    entry.file(async file => {\n      await addFileToZipStream(file, entrypath);\n    });\n  }\n\n  function onError(action, message = null) {\n    message = (message) ? message : {};\n    switch (action) {\n      case eventnames.init:\n      case eventnames.errorfile:\n        message.name=action;\n        break;\n      default:\n        //message.name = eventnames.error;\n        break;\n    }\n    _modules_module_event_emitter_js__WEBPACK_IMPORTED_MODULE_1__.ModuleEventEmitter.emit(eventnames.message, message, _listener);\n  }\n  async function searchStorage(search) {\n    const entry = await navigator.storage.getDirectory();\n    for await (const [key, value] of entry.entries()) {\n      if (search === key) {\n        return true;\n        break;\n      }\n    }\n    return false;\n  }\n  async function cleanStorage(entry = null) {\n    entry = (entry) ? entry : await navigator.storage.getDirectory();\n     for await (const [key, value] of entry.entries()) {\n      try {\n        await entry.removeEntry(key);\n        console.log(' Success remove storage ', key);\n      } catch (error) {\n        console.log(' error remove storage ' + key, error);\n        }\n      }\n    }\nasync function listStorage(entry = null,name=null) {\n    entry = (entry) ? entry : await navigator.storage.getDirectory();\n    let rep=true;\n     for await (const [key, value] of entry.entries()) {\n        if (name!==null) {\n            const parts = key.split('.');\n            if (parts.pop()==='crswap' && parts.join('.') ===name) {\n            rep=false;\n            break;\n            }\n        }\n        }\n      return rep;\n    }\n  async function endFetch(message, clean = false) {\n    if (properties.follow) {\n      properties.streamhandle = await properties.filestream.createWritable({mode:\"exclusive\"});\n      message.name = eventnames.follow;\n      _modules_module_event_emitter_js__WEBPACK_IMPORTED_MODULE_1__.ModuleEventEmitter.emit(eventnames.follow, message, _listener);\n      await initZip();\n      return;\n    } else properties.zip = null;\n    if (!properties.hashandlers) {message.name = eventnames.terminate;_modules_module_event_emitter_js__WEBPACK_IMPORTED_MODULE_1__.ModuleEventEmitter.emit(eventnames.complete, message, _listener);}\n  }\n\n  async function sendChunk(path,gzipped, start = 0, chunknum = 0, chunksize = MAXSIZE) {\n    const ext = gzipped.name.slice(gzipped.name.lastIndexOf('.') + 1);\n    const file = (already_compressed.has(ext))?gzipped:await gzipped.getFile();\n    const end = Math.min(start + chunksize, file.size);\n    if (end === file.size) {\n    path=path.replace(file.name,'');\n     sendZipFile(file, path, null, true);\n    } else {\n        properties.counter.error+=1;\n    onError(eventnames.errorfile, {\n          name: eventnames.error,\n          message:'File '+path+_modules_utils_js__WEBPACK_IMPORTED_MODULE_0__.dirseparator+file.name+' size exceeds capacity. Chunk functionality not supported for the moment.'\n        }, _listener);\n    return endProcess() ;\n    // for the moment ecotaxaback does not support chunks\n      const partfile = file.slice(start, end);\n      partfile.name = chunknum + '_' + file.name;\n      await sendZipFile(partfile, path, async () => {\n        start += end;\n        chunknum++;\n        if (start <= file.size) await sendChunk(path, gzipped,start, chunknum, chunksize);\n      }, true)\n    }\n    return chunknum;\n  }\n  async function getFile(filestream = null) {\n    filestream = (filestream === null) ? properties.filestream : filestream;\n    const file = await filestream.getFile();\n    return file;\n  }\n  async function sendZipFile(file, path, callbackchunk = null, bigfile = false) {\n  if(properties.counter.error>0) return endProcess();\n    const message = {\n      name: eventnames.pending,\n      bigfile:bigfile,\n      path: path\n    }\n    const formdata = new FormData();\n    path = path + ((path.slice(-1) === _modules_utils_js__WEBPACK_IMPORTED_MODULE_0__.dirseparator) ? `` : _modules_utils_js__WEBPACK_IMPORTED_MODULE_0__.dirseparator) + file.name;\n    formdata.append('path', path);\n    formdata.append('file', file, file.name);\n    if (properties.part) formdata.append('part', properties.part);\n    else if (callbackchunk !== null) formdata.append('ischunk', true);\n    message.path = path;\n    const response = await fetch(options.uploadurl, {\n      //  mode: 'cors',\n      method: \"POST\",\n      credentials: \"include\",\n      body: formdata,\n    });\n    const body=await response.text();\n      if (response.ok) {\n      if (callbackchunk) {\n        await callbackchunk();\n      } else { if(!bigfile || !properties.hashandlers)  await endFetch(message);\n       if (bigfile) {message.name=eventnames.follow;\n      _modules_module_event_emitter_js__WEBPACK_IMPORTED_MODULE_1__.ModuleEventEmitter.emit(eventnames.follow, message, _listener);\n      } }\n      } else {\n        properties.follow=null;\n        await endFetch(message);\n         properties.counter.error+=1;\n        onError(eventnames.errorfile, message); if(bigfile || properties.hashandlers) endProcess();    }\n  }\n  function endProcess() {\n    properties.follow=null;\n    onError(eventnames.errorfile,{\n            name: _modules_alert_box_js__WEBPACK_IMPORTED_MODULE_2__.AlertBox.alertconfig.types.error,\n            message: \"Upload not done. one or more files exceeds max upload size\",\n            path:uploadpath,\n            });\n    reset().then(() => {\n        _modules_module_event_emitter_js__WEBPACK_IMPORTED_MODULE_1__.ModuleEventEmitter.emit(eventnames.complete, {\n          name: eventnames.ready\n        }, _listener);\n        properties.endreaddir = false;  });\n    return false;\n    }\n  return {\n    uuid,\n    eventnames,\n    scanBrowse,\n    scanHandle,\n    quotaEstimate,\n    browserRequired\n  }\n}\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvbW9kdWxlcy9maWxlcy9qcy1kaXJ0b3ppcC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7QUFBYTtBQU1tQjs7QUFRaEI7QUFHK0I7QUFDUDtBQUNZO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPLGdDQUFnQztBQUN2QyxzS0FBc0ssWUFBWSxhQUFhLHNCQUFzQixjQUFjLGlCQUFpQjtBQUNwUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGdFQUFhO0FBQzVCO0FBQ0E7O0FBRUE7QUFDQSxnQkFBZ0Isc0RBQU07QUFDdEIscUJBQXFCLFNBQVMsOERBQThELG1CQUFtQjtBQUMvRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxnRkFBa0I7QUFDdkI7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxnRkFBa0I7QUFDdkIsdUJBQXVCO0FBQ3ZCLElBQUksZ0ZBQWtCO0FBQ3RCO0FBQ0E7QUFDQSxRQUFRLGdGQUFrQjtBQUMxQjtBQUNBLFNBQVM7QUFDVCxVQUFVLGdGQUFrQjtBQUM1QixnQkFBZ0IsMkRBQVE7QUFDeEI7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxRQUFRO0FBQ1IsS0FBSztBQUNMLElBQUksZ0ZBQWtCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7O0FBRXpDLE1BQU0sZ0ZBQWtCO0FBQ3hCLHdDQUF3QyxpQkFBaUI7QUFDekQ7QUFDQSxLQUFLO0FBQ0wsSUFBSSxnRkFBa0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULFFBQVEsZ0ZBQWtCO0FBQzFCO0FBQ0EsUUFBUSxPQUFPO0FBQ2Y7QUFDQSxPQUFPOztBQUVQLFFBQVEsZ0ZBQWtCO0FBQzFCOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSSxnRkFBa0I7QUFDdEI7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJLGdGQUFrQjtBQUN0QjtBQUNBO0FBQ0EsTUFBTSxnRkFBa0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJLGdGQUFrQixnQ0FBZ0M7QUFDdEQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLHVDQUFHO0FBQzVCO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTSxnRkFBa0I7QUFDeEIsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBEO0FBQzFEO0FBQ0E7QUFDQTs7QUFFQSx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQiwrREFBWTtBQUN0QyxRQUFRLGdGQUFrQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLEtBQUssZ0ZBQWtCO0FBQzdCO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRCxpQkFBaUI7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRDtBQUNqRDtBQUNBO0FBQ0EsOEJBQThCLDJEQUFZO0FBQzFDO0FBQ0E7QUFDQSxtRkFBbUY7QUFDbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxRQUFRLCtMQUFnQztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDhDQUE4QztBQUM5QztBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsMkRBQVk7QUFDcEQ7QUFDQSwyQkFBMkIsMkRBQVk7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUEsaURBQWlEO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQSxJQUFJLGdGQUFrQjtBQUN0QjtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLDJEQUFZO0FBQzdDLGlDQUFpQywyREFBWTtBQUM3QztBQUNBLGtDQUFrQywyREFBWSxhQUFhLDJEQUFZO0FBQ3ZFO0FBQ0E7QUFDQSxPQUFPLGdGQUFrQjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLE9BQU87QUFDUDs7QUFFQSwwQkFBMEIsNkNBQVM7QUFDbkM7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsMkRBQVE7O0FBRTlCLHFCQUFxQiwyREFBUTtBQUM3QjtBQUNBO0FBQ0EsNEdBQTRHO0FBQzVHLCtCQUErQiwwQ0FBMEM7QUFDekU7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLDJEQUFRO0FBQzFCLGlCQUFpQiwyREFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixnRkFBa0I7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxnRkFBa0I7QUFDdEI7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU8sRUFBRTtBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSw0QkFBNEIsZ0ZBQWtCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxrREFBYztBQUM1RCxVQUFVLG1EQUFlO0FBQ3pCO0FBQ0EsT0FBTyxRQUFRLDhDQUFVO0FBQ3pCO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixnRkFBa0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSSxnRkFBa0I7QUFDdEI7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksZ0ZBQWtCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRFQUE0RSxpQkFBaUI7QUFDN0Y7QUFDQSxNQUFNLGdGQUFrQjtBQUN4QjtBQUNBO0FBQ0EsTUFBTTtBQUNOLGtDQUFrQyxvQ0FBb0MsZ0ZBQWtCO0FBQ3hGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLCtCQUErQiwyREFBWTtBQUMzQyxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QywyREFBWSxTQUFTLDJEQUFZO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxPQUFPO0FBQ2YscUJBQXFCO0FBQ3JCLE1BQU0sZ0ZBQWtCO0FBQ3hCO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRDtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQiwyREFBUTtBQUMxQjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsUUFBUSxnRkFBa0I7QUFDMUI7QUFDQSxTQUFTO0FBQ1QseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy9tb2R1bGVzL2ZpbGVzL2pzLWRpcnRvemlwLmpzPzg1MzgiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuaW1wb3J0IHtcbiAgZmV0Y2hTZXR0aW5ncyxcbiAgZm9ybWF0X2J5dGVzLFxuICBkaXJzZXBhcmF0b3IsXG4gIGdlbmVyYXRlX3V1aWRcbn0gZnJvbSAnLi4vLi4vbW9kdWxlcy91dGlscy5qcyc7XG5cbmltcG9ydCB7XG4gIEFzeW5jR3ppcCxcbiAgWmlwLFxuICBBc3luY1ppcERlZmxhdGUsXG4gIFppcFBhc3NUaHJvdWdoLFxuICBaaXBEZWZsYXRlLFxufSBmcm9tICdmZmxhdGUnO1xuaW1wb3J0IHtcbiAgTW9kdWxlRXZlbnRFbWl0dGVyXG59IGZyb20gJy4uLy4uL21vZHVsZXMvbW9kdWxlLWV2ZW50LWVtaXR0ZXIuanMnO1xuaW1wb3J0IHsgZGV0ZWN0IH0gZnJvbSAnZGV0ZWN0LWJyb3dzZXInO1xuaW1wb3J0IHtBbGVydEJveH0gZnJvbSAnLi4vLi4vbW9kdWxlcy9hbGVydC1ib3guanMnO1xuY29uc3QgYWxyZWFkeV9jb21wcmVzc2VkID0gbmV3IFNldChbXG4gICd6aXAnLCAnZ3onLCAncG5nJywgJ2pwZycsICdqcGVnJywgJ3BkZicsICdkb2MnLCAnZG9jeCcsICdwcHQnLCAncHB0eCcsXG4gICd4bHMnLCAneGxzeCcsICdoZWljJywgJ2hlaWYnLCAnN3onLCAnYnoyJywgJ3JhcicsICdnaWYnLCAnd2VicCcsICd3ZWJtJyxcbiAgJ21wNCcsICdtb3YnLCAnbXAzJywgJ2FpZmMnXG5dKTtcbmNvbnN0IGNhbl9iZV9jb21wcmVzc2VkID0gbmV3IFNldChbJ3RzdicsJ3R4dCcsJ2xvZycsJ2NzdiddKTtcbmNvbnN0IGFjY2VwdCA9ICcudHN2LC5wbmcsLmpwZywgLmpwZWcsLnppcCwuZ3osLjd6LC5iejInO1xuXG5leHBvcnQgZnVuY3Rpb24gSnNEaXJUb1ppcChvcHRpb25zID0ge30pIHtcbiAgY29uc3QgTUFYU0laRSA9IChkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdbZGF0YS1tYXhfdXBsb2FkX3NpemVdJykpP3BhcnNlSW50KGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ1tkYXRhLW1heF91cGxvYWRfc2l6ZV0nKS5kYXRhc2V0WydtYXhfdXBsb2FkX3NpemUnXSk6MTA3Mzc0MTgyNDsvLzY4MTU3NDQwMDsvLzY4MTU3NDQwMDsgLy8gNjUwTSAvLzEwNzM3NDE4MjQ7IC8vNDI5NDk2NzI5NjsgLy8vLyAzMjIxMjI1NDcyOyAvLyAyMTQ3NDgzNjQ4O1xuICBjb25zdCBVUExPQURJTlBBUlRTID0gKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ1tkYXRhLXVwbG9hZGlucGFydHNdJykpP3RydWU6ZmFsc2U7XG4gIGNvbnN0IGV2ZW50bmFtZXMgPSB7XG4gICAgcmVhZHk6ICdyZWFkeScsXG4gICAgZm9sbG93OiAnZm9sbG93JyxcbiAgICBjb21wbGV0ZTogJ2NvbXBsZXRlJyxcbiAgICBlbmRyZWFkZGlyOiAnZW5kcmVhZGRpcicsXG4gICAgZ3ppcDogJ2d6aXAnLFxuICAgIGVuZHppcDogJ2VuZHppcCcsXG4gICAgc2VuZGZpbGU6ICdzZW5kZmlsZScsXG4gICAgYmlnZmlsZTogJ2JpZ2ZpbGUnLFxuICAgIHRlcm1pbmF0ZTogJ3Rlcm1pbmF0ZScsXG4gICAgcGVuZGluZzogJ3BlbmRpbmcnLFxuICAgIGVycm9yZmlsZTogJ2Vycm9yZmlsZScsXG4gICAgY291bnRlcjogJ2NvdW50ZXInLFxuICAgIHJlamVjdDogJ3JlamVjdCcsXG4gICAgbWVzc2FnZTogJ21lc3NhZ2UnLFxuICAgIGVycm9yOiAnZXJyb3InLFxuICAgIGluaXQ6ICdpbml0JyxcbiAgICBzZXR1cGxvYWRwYXRoOidzZXR1cGxvYWRwYXRoJ1xuICB9O1xuICBsZXQganNTY2FuRGlyLCBwcm9wZXJ0aWVzLHVwbG9hZHBhdGg7XG4gIGxldCB0cnlkZWxldGU9MDtcbiAgY29uc3QgZGVmYXVsdE9wdGlvbnMgPSB7XG4gICAgdXBsb2FkdXJsOiAnL2d1aS9maWxlcy91cGxvYWQnLFxuICAgIGxhcmdlZmlsZTogTUFYU0laRSxcbiAgICBhY2NlcHQ6IGFjY2VwdC5zcGxpdCgnLCcpXG4gIH1cbiAgLy8gdXNlcyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvRmlsZV9TeXN0ZW1fQVBJL09yaWdpbl9wcml2YXRlX2ZpbGVfc3lzdGVtXG4gIC8vIyBhbHRlcm5hdGl2ZSAobm90IHN1cHBvcnRlZCBpbiBTYWZhcmkpIGZvciAuY3JlYXRlV3JpdGFibGVcbiAgb3B0aW9ucyA9IHsgLi4uZGVmYXVsdE9wdGlvbnMsXG4gICAgLi4ub3B0aW9uc1xuICB9O1xuICAvLyBvdGhlciBtb2R1bGUgcmVjZWl2aW5nIGV2ZW50c1xuICBjb25zdCBfbGlzdGVuZXIgPSAob3B0aW9ucy5saXN0ZW5lcikgPyBvcHRpb25zLmxpc3RlbmVyIDogdXVpZDtcbiAgT2JqZWN0LmZyZWV6ZShvcHRpb25zKTtcbiAgY29uc3QgdXVpZCA9IGdlbmVyYXRlX3V1aWQoKTtcbiAgaW5pdFN0b3JhZ2UoKTtcbiAgaW5pdCgpO1xuXG5mdW5jdGlvbiBicm93c2VyUmVxdWlyZWQoKSB7XG5jb25zdCBicm93c2VyID0gZGV0ZWN0KCk7XG4gICAgIGNvbnN0IGFjY2VwdGVkPXthbmRyb2lkOntjaHJvbWU6MTA5LG9wZXJhOjc0LGZpcmVmb3g6MTExLHNhbXN1bmdicm93c2VyOjIxLHdlYnZpZXc6MTA5fSwgaW9zOmZhbHNlLG90aGVyOntjaHJvbWU6ODYsZWRnZTo4NixvcGVyYTo3MixmaXJlZm94OjExMX19O1xuICAgICAgICBsZXQgb3MgPWJyb3dzZXIub3MudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgb3M9KG9zIGluIFsnYW5kcm9pZCcsJ2lvcyddKT9vczonb3RoZXInO1xuICAgICBjb25zdCBuYW1lPWJyb3dzZXIubmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICBjb25zdCB2ZXJzaW9uID0gcGFyc2VJbnQoYnJvd3Nlci52ZXJzaW9uLnNwbGl0KCcuJylbMF0pO1xuICAgICBpZiAoT2JqZWN0LmtleXMoYWNjZXB0ZWQpLmluZGV4T2Yob3MpPDAgfHwgT2JqZWN0LmtleXMoYWNjZXB0ZWRbb3NdKS5pbmRleE9mKG5hbWUpPDAgfHwgcGFyc2VJbnQoYWNjZXB0ZWRbb3NdW25hbWVdKT5wYXJzZUludCh2ZXJzaW9uKSkgIHtcbiAgICAgTW9kdWxlRXZlbnRFbWl0dGVyLmVtaXQoZXZlbnRuYW1lcy5tZXNzYWdlLCB7XG4gICAgICAgICAgaWQ6IFwiYnJvd3NlclwiLFxuICAgICAgICAgIG5hbWU6IFwiYnJvd3NlclwiLFxuICAgICAgICAgIG1lc3NhZ2U6IFwieW91ciBicm93c2VyIGRvZXMgbm90IGhhdmUgYSByZXF1aXJlZCBmdW5jdGlvbm5hbGl0eS4gUGxlYXNlIHVwZ3JhZGUgb3IgdXNlIGEgdmFsaWQgYnJvd3NlciBhbmQgdmVyc2lvbiA6XCIrICBKU09OLnN0cmluZ2lmeShhY2NlcHRlZCkucmVwbGFjZUFsbCgnXCInLCcnKSxcbiAgICAgICAgfSwgX2xpc3RlbmVyKTtcbiAgICAgfVxuICAgICB9XG4gIGZ1bmN0aW9uIGluaXQoKSB7XG4gICAgcHJvcGVydGllcyA9IGluaXRQcm9wcygpO1xuICAgICBNb2R1bGVFdmVudEVtaXR0ZXIub24oZXZlbnRuYW1lcy5zZXR1cGxvYWRwYXRoLCBhc3luYyhlKSA9PiB7XG4gICAgdXBsb2FkcGF0aD1lLnBhdGg7fSx1dWlkKTtcbiAgICBNb2R1bGVFdmVudEVtaXR0ZXIub24oZXZlbnRuYW1lcy5pbml0LCBhc3luYyAoZSkgPT4ge1xuICAgICAgaWYgKCFpc0FjdGl2ZSgpKSB7XG4gICAgICAgIGF3YWl0IHJlc2V0KCk7XG4gICAgICAgIE1vZHVsZUV2ZW50RW1pdHRlci5lbWl0KGV2ZW50bmFtZXMuY29tcGxldGUsIHtcbiAgICAgICAgICBuYW1lOiBldmVudG5hbWVzLnJlYWR5XG4gICAgICAgIH0sIF9saXN0ZW5lcik7XG4gICAgICAgICAgTW9kdWxlRXZlbnRFbWl0dGVyLmVtaXQoZXZlbnRuYW1lcy5tZXNzYWdlLCB7XG4gICAgICAgICAgbmFtZTogQWxlcnRCb3guYWxlcnRjb25maWcudHlwZXMuc3VjY2VzcyxcbiAgICAgICAgICBtZXNzYWdlOiBcIlVwbG9hZCBvZiBcIisgZS5wYXRoICtcIiBpcyBkb25lXCIsXG4gICAgICAgIH0sIF9saXN0ZW5lcik7XG4gICAgICAgIHByb3BlcnRpZXMuZW5kcmVhZGRpciA9IGZhbHNlO1xuICAgICAgfSBlbHNlIGNvbnNvbGUubG9nKCdwYXJ0bHkgZmluaXNoZWQgJytwcm9wZXJ0aWVzLmhhc2hhbmRsZXJzKyAnZm9sbG93PScrcHJvcGVydGllcy5mb2xsb3csIGUpO1xuICAgIH0sIHV1aWQpO1xuICAgIE1vZHVsZUV2ZW50RW1pdHRlci5vbihldmVudG5hbWVzLmVuZHppcCwgYXN5bmMoZSkgPT4ge1xuICAgICAgaWYgKCFlLmJpZ2ZpbGUgJiYgcHJvcGVydGllcy56aXApIHByb3BlcnRpZXMuemlwLmVuZCgpO1xuICAgICAgY29uc3QgZXZ0c2VuZD1hc3luYyBmdW5jdGlvbigpIHtcbiAgICAgIGNvbnN0IHppcGNsb3NlZCA9IGF3YWl0IGxpc3RTdG9yYWdlKG51bGwscHJvcGVydGllcy56aXBuYW1lKTtcbiAgICAgIGlmICh6aXBjbG9zZWQgPT09IHRydWUpIHtcbiAgICAgIGNvbnN0IG1lc3NhZ2UgPSBidWlsZE1lc3NhZ2UoZSwge1xuICAgICAgICBuYW1lOiBldmVudG5hbWVzLnNlbmRmaWxlLCAgICAgIH0pO1xuXG4gICAgICBNb2R1bGVFdmVudEVtaXR0ZXIuZW1pdChldmVudG5hbWVzLmNvbXBsZXRlLCBtZXNzYWdlLCBfbGlzdGVuZXIpO31cbiAgICAgIGVsc2Ugc2V0VGltZW91dChhc3luYyBmdW5jdGlvbigpIHthd2FpdCBldnRzZW5kKCk7fSwyMDAwKTt9XG4gICAgICBldnRzZW5kKCk7XG4gICAgfSwgdXVpZCk7XG4gICAgTW9kdWxlRXZlbnRFbWl0dGVyLm9uKGV2ZW50bmFtZXMuc2VuZGZpbGUsIGFzeW5jIChlKSA9PiB7XG4gICAgICBpZiAocHJvcGVydGllcy5oYXNoYW5kbGVycykge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gYnVpbGRNZXNzYWdlKGUsIHtcbiAgICAgICAgICAgIG5hbWU6IGV2ZW50bmFtZXMuZm9sbG93LFxuICAgICAgICB9KTtcbiAgICAgICAgTW9kdWxlRXZlbnRFbWl0dGVyLmVtaXQoZXZlbnRuYW1lcy5mb2xsb3csIG1lc3NhZ2UsIF9saXN0ZW5lcik7XG4gICAgICAgIGF3YWl0IGV4ZWNIYW5kbGVyKCk7XG4gICAgICB9IGVsc2UgeyBjb25zdCBtZXNzYWdlID0gYnVpbGRNZXNzYWdlKGUsIHtcbiAgICAgICAgbmFtZTogZXZlbnRuYW1lcy5wZW5kaW5nLFxuICAgICAgfSk7XG5cbiAgICAgICAgTW9kdWxlRXZlbnRFbWl0dGVyLmVtaXQoZXZlbnRuYW1lcy5jb21wbGV0ZSwgbWVzc2FnZSwgX2xpc3RlbmVyKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgZmlsZSA9IGF3YWl0IGdldEZpbGUoKTtcbiAgICAgIHNlbmRaaXBGaWxlKGZpbGUsIChlLnBhdGggPyBlLnBhdGggOiB1cGxvYWRwYXRoKSwgbnVsbCk7XG4gICAgfSwgdXVpZCk7XG4gICAgTW9kdWxlRXZlbnRFbWl0dGVyLm9uKGV2ZW50bmFtZXMuZW5kcmVhZGRpciwgKGUpID0+IHtcbiAgICAgIHByb3BlcnRpZXMuZW5kcmVhZGRpciA9IHRydWU7XG4gICAgICBjaGVja1Byb2Nlc3NlZChlKTtcbiAgICB9LCB1dWlkKTtcbiAgICBNb2R1bGVFdmVudEVtaXR0ZXIub24oZXZlbnRuYW1lcy5jb3VudGVyLCBhc3luYyAoZSkgPT4ge1xuICAgICAgcHJvcGVydGllcy5lbmRjb3VudGVyID0gZmFsc2U7XG4gICAgICBwcm9wZXJ0aWVzLmNvdW50ZXJbZS5uYW1lXSArPSAxO1xuICAgICAgTW9kdWxlRXZlbnRFbWl0dGVyLmVtaXQoZXZlbnRuYW1lcy5jb3VudGVyLCBlLCBfbGlzdGVuZXIpO1xuICAgICAgaWYgKGUubmFtZSA9PT0gJ3ppcCcgJiYgcHJvcGVydGllcy5jb3VudGVyLnNjYW4gPT09IHByb3BlcnRpZXMuY291bnRlci56aXApIHtcbiAgICAgICAgcHJvcGVydGllcy5lbmRjb3VudGVyID0gdHJ1ZTtcbiAgICAgICAgY2hlY2tQcm9jZXNzZWQoZSk7XG4gICAgICB9XG4gICAgICBpZiAoZS5uYW1lID09PSAnemlwJyAmJiBwcm9wZXJ0aWVzLmNhbGxiYWNrKSBhd2FpdCBwcm9wZXJ0aWVzLmNhbGxiYWNrKCk7XG4gICAgfSwgdXVpZCk7XG4gICAgTW9kdWxlRXZlbnRFbWl0dGVyLm9uKGV2ZW50bmFtZXMuZXJyb3IsICAoZSkgPT4ge30pO1xuICB9XG5cbiAgZnVuY3Rpb24gaW5pdFByb3BzKCkge1xuICAgIHJldHVybiB7XG4gICAgICB6aXA6IG51bGwsXG4gICAgICB6aXBuYW1lOiBudWxsLFxuICAgICAgZmlsZXN0cmVhbTogbnVsbCxcbiAgICAgIHN0cmVhbWhhbmRsZTogbnVsbCxcbiAgICAgIGd6aXBwZWQ6IG51bGwsXG4gICAgICBzaXpldG96aXA6IDAsXG4gICAgICBwYXJ0OiAwLFxuICAgICAgZm9sbG93OiBudWxsLFxuICAgICAgZW5kY291bnRlcjogZmFsc2UsXG4gICAgICBlbmRyZWFkZGlyOiBmYWxzZSxcbiAgICAgIGNhbGxiYWNrOiBudWxsLFxuICAgICAgcG9zOiAwLFxuICAgICAgY291bnRlcjoge1xuICAgICAgICBzY2FuOiAwLFxuICAgICAgICB6aXA6IDAsXG4gICAgICAgIHJlamVjdDogMCxcbiAgICAgICAgZXJyb3I6MCxcbiAgICAgIH0sXG4gICAgICBoYW5kbGVyczogW10sXG4gICAgICBoYXNoYW5kbGVyczpmYWxzZSxcbiAgICAgfVxuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIHJlc2V0KCkge1xuICAgIHByb3BlcnRpZXMgPSBpbml0UHJvcHMoKTtcbiAgICBhd2FpdCBpbml0U3RvcmFnZSgpO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNBY3RpdmUoKSB7XG4gICAgcmV0dXJuIChwcm9wZXJ0aWVzLnppcCAhPT0gbnVsbCB8fCBwcm9wZXJ0aWVzLmZvbGxvdyAhPT0gbnVsbCB8fCBwcm9wZXJ0aWVzLmhhc2hhbmRsZXJzIHx8IHByb3BlcnRpZXMuZW5kcmVhZGRpciAhPT0gdHJ1ZSk7XG4gIH1cblxuICBhc3luYyBmdW5jdGlvbiBpbml0WmlwKCkge1xuICAgIHByb3BlcnRpZXMucG9zID0gMDtcbiAgICBwcm9wZXJ0aWVzLnNpemV0b3ppcCA9IDA7XG4gICAgcHJvcGVydGllcy56aXAgPSBuZXcgWmlwKChlcnJvciwgY2h1bmssIGZpbmFsKSA9PiB7XG4gICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgb25FcnJvcihldmVudG5hbWVzLmVycm9yZmlsZSwge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGVycm9yfSwgX2xpc3RlbmVyKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcHJvcGVydGllcy5zdHJlYW1oYW5kbGUud3JpdGUoY2h1bmssIHtcbiAgICAgICAgICBhdDogc2VsZi5wb3NcbiAgICAgICAgfSk7XG4gICAgICAgIHByb3BlcnRpZXMucG9zICs9IGNodW5rLmxlbmd0aDtcbiAgICAgICAgaWYgKGZpbmFsKSB7XG4gICAgICAgICAgcHJvcGVydGllcy5zdHJlYW1oYW5kbGUuY2xvc2UoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICAgIC8vIGhhY2sgZm9yIG1lbW9yeSB1c2FnZVxuICAgIHppcE9uRGF0YSgpO1xuICAgIGlmIChwcm9wZXJ0aWVzLmZvbGxvdykgYXdhaXQgcHJvcGVydGllcy5mb2xsb3coKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNoZWNrUHJvY2Vzc2VkKGUpIHtcbiAgICBpZiAocHJvcGVydGllcy5lbmRyZWFkZGlyID09PSB0cnVlKSB7XG4gICAgaWYocHJvcGVydGllcy5lbmRjb3VudGVyID09PSB0cnVlKSB7XG4gICAgICBjb25zdCBtZXNzYWdlID0gYnVpbGRNZXNzYWdlKGUsIHtcbiAgICAgICBuYW1lOiBldmVudG5hbWVzLmVuZHppcFxuICAgICAgfSk7XG4gICAgICBNb2R1bGVFdmVudEVtaXR0ZXIuZW1pdChldmVudG5hbWVzLmNvbXBsZXRlLCBtZXNzYWdlLCBfbGlzdGVuZXIpO1xuICAgIH0gIGVsc2UgaWYgKHByb3BlcnRpZXMuY291bnRlci5lcnJvcj4wKSBlbmRQcm9jZXNzKCk7fVxuICB9XG5cbiAgZnVuY3Rpb24gemlwT25EYXRhKHppcCA9IG51bGwpIHtcbiAgICB6aXAgPSAoemlwID09PSBudWxsKSA/IHByb3BlcnRpZXMuemlwIDogemlwO1xuICAgIGNvbnN0IG9uZGF0YSA9IHppcC5vbmRhdGE7XG4gICAgemlwLm9uZGF0YSA9IChlcnJvciwgZGF0YSwgZmluYWwpID0+IHtcbiAgICAgIG9uZGF0YShlcnJvciwgZGF0YSwgZmluYWwpO1xuICAgICAgaWYgKGZpbmFsKSB7XG4gICAgICAgIHppcC5kID0gbnVsbDtcbiAgICAgICAgaWYgKHppcC51ICYmIHppcC51LmF0KC0xKSkgemlwLnUuYXQoLTEpLmQgPSBudWxsOyAvLyBPYmplY3QgY3JlYXRlZCBpbiBgemlwLmFkZCgpYFxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGJ1aWxkTWVzc2FnZShlLCBtZXNzYWdlID0ge30pIHtcbiAgICBpZiAoZS5oYXNPd25Qcm9wZXJ0eShcInBhcnRcIikpIHtcbiAgICAgIG1lc3NhZ2UucGFydCA9IGUucGFydDtcbiAgICB9IGVsc2UgcHJvcGVydGllcy5wYXJ0ID0gMDtcbiAgICBpZiAoZS5oYXNPd25Qcm9wZXJ0eShcImJpZ2ZpbGVcIikpIG1lc3NhZ2UuYmlnZmlsZSA9IGUuYmlnZmlsZTtcbiAgICBpZiAoZS5oYXNPd25Qcm9wZXJ0eShcInBhdGhcIikpIG1lc3NhZ2UucGF0aCA9IGUucGF0aDtcbiAgICByZXR1cm4gbWVzc2FnZTtcbiAgfVxuXG4gIGFzeW5jIGZ1bmN0aW9uIHF1b3RhRXN0aW1hdGUoKSB7XG4gICAgaWYgKG5hdmlnYXRvciAmJiBuYXZpZ2F0b3Iuc3RvcmFnZSAmJiBuYXZpZ2F0b3Iuc3RvcmFnZS5lc3RpbWF0ZSkge1xuICAgICAgbmF2aWdhdG9yLnN0b3JhZ2UuZXN0aW1hdGUoKS50aGVuKChxdW90YSkgPT4ge1xuICAgICAgICBjb25zdCBwZXJjZW50YWdlVXNlZCA9ICgocXVvdGEudXNhZ2UgLyBxdW90YS5xdW90YSkgKiAxMDApLnRvRml4ZWQoMik7XG4gICAgICAgIGNvbnN0IHJlbWFpbmluZyA9IGZvcm1hdF9ieXRlcyhxdW90YS5xdW90YSAtIHF1b3RhLnVzYWdlKTtcbiAgICAgICAgTW9kdWxlRXZlbnRFbWl0dGVyLmVtaXQoZXZlbnRuYW1lcy5tZXNzYWdlLCB7XG4gICAgICAgICAgaWQ6IFwicXVvdGFcIixcbiAgICAgICAgICBuYW1lOiBcImNvbnNvbGVcIixcbiAgICAgICAgICBtZXNzYWdlOiBcInlvdSd2ZSB1c2VkIFwiICsgcGVyY2VudGFnZVVzZWQgKyBcIiUgb2YgdGhlIGF2YWlsYWJsZSBicm93c2VyIHN0b3JhZ2UgbmVjZXNzYXJ5IHRvIGxvY2FsbHkgY29tcHJlc3MgZmlsZXMgKFwiICsgcmVtYWluaW5nICsgXCIpLlwiLFxuICAgICAgICB9LCBfbGlzdGVuZXIpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgYXN5bmMgZnVuY3Rpb24gaW5pdFN0b3JhZ2UoKSB7XG4gICAgaWYgKG5hdmlnYXRvciAmJiBuYXZpZ2F0b3Iuc3RvcmFnZSAmJiBuYXZpZ2F0b3Iuc3RvcmFnZS5lc3RpbWF0ZSkge1xuICAgICAgYXdhaXQgY2xlYW5TdG9yYWdlKCk7XG4gICAgICBxdW90YUVzdGltYXRlKCk7XG4gICAgfSBlbHNlIE1vZHVsZUV2ZW50RW1pdHRlci5lbWl0KGV2ZW50bmFtZXMubWVzc2FnZSwge1xuICAgICAgbmFtZTogXCJlcnJvclwiLFxuICAgICAgbWVzc2FnZTogXCJubyBuYXZpZ2F0b3Igc3RvcmFnZVwiXG4gICAgfSwgdXVpZCk7XG4gIH1cblxuICBhc3luYyBmdW5jdGlvbiBjcmVhdGVMb2NhbFN0cmVhbShuYW1lLCBhY2NlcHQgPSB7XG4gICAgJ2FwcGxpY2F0aW9uL3ppcCc6IFsnLnppcCddLFxuICB9KSB7XG4gICAgY29uc3Qgcm9vdCA9IGF3YWl0IG5hdmlnYXRvci5zdG9yYWdlLmdldERpcmVjdG9yeSgpO1xuICAgIGNvbnN0IG9wdHMgPSB7XG4gICAgICB0eXBlczogW3tcbiAgICAgICAgZGVzY3JpcHRpb246ICdUZW1wIGZpbGUnLFxuICAgICAgICBhY2NlcHQ6IGFjY2VwdCxcbiAgICAgIH0sIF0sXG4gICAgICBjcmVhdGU6IHRydWVcbiAgICB9O1xuICAgIGNvbnN0IGZpbGVzdHJlYW0gPSBhd2FpdCByb290LmdldEZpbGVIYW5kbGUobmFtZSwgb3B0cyk7XG4gICAgY29uc3Qgc3RyZWFtaGFuZGxlID0gYXdhaXQgZmlsZXN0cmVhbS5jcmVhdGVXcml0YWJsZSh7bW9kZTpcImV4Y2x1c2l2ZVwifSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGZpbGVzdHJlYW0sXG4gICAgICBzdHJlYW1oYW5kbGVcbiAgICB9O1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIHNjYW5Db21tb24oemlwbmFtZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgcHJvcGVydGllcy5lbmRyZWFkZGlyID0gZmFsc2U7XG4gICAgaWYgKHByb3BlcnRpZXMuemlwID09PSBudWxsKSB7XG4gICAgICB6aXBuYW1lID0gemlwbmFtZS5zcGxpdChkaXJzZXBhcmF0b3IpWzBdO1xuICAgICAgemlwbmFtZSA9ICh6aXBuYW1lLnRyaW0oKSA9PT0gYGApID8gJ3RlbXAnIDogemlwbmFtZTtcbiAgICAgIGNvbnN0IHR5cGUgPSAob3B0aW9ucyAmJiBvcHRpb25zLnR5cGUpID8gb3B0aW9ucy50eXBlIDogJy56aXAnO1xuICAgICAgcHJvcGVydGllcy56aXBuYW1lID0gKChvcHRpb25zLnppcG5hbWUpID8gb3B0aW9ucy56aXBuYW1lIDogemlwbmFtZSkgKyB0eXBlOyAvL1xuICAgICAgY29uc3QgemlwaW5zdG9yYWdlID0gYXdhaXQgc2VhcmNoU3RvcmFnZShwcm9wZXJ0aWVzLnppcG5hbWUpO1xuICAgICAgaWYgKHppcGluc3RvcmFnZSkgcHJvcGVydGllcy56aXBuYW1lID0gJzFfJyArIHByb3BlcnRpZXMuemlwbmFtZTtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgZmlsZXN0cmVhbSxcbiAgICAgICAgc3RyZWFtaGFuZGxlXG4gICAgICB9ID0gYXdhaXQgY3JlYXRlTG9jYWxTdHJlYW0ocHJvcGVydGllcy56aXBuYW1lKTtcbiAgICAgIHByb3BlcnRpZXMuZmlsZXN0cmVhbSA9IGZpbGVzdHJlYW07XG4gICAgICBwcm9wZXJ0aWVzLnN0cmVhbWhhbmRsZSA9IHN0cmVhbWhhbmRsZTtcbiAgICAgIGxldCBzaXplID0gMDtcbiAgICAgIHByb3BlcnRpZXMucGFydCA9IDA7XG4gICAgICBhd2FpdCBpbml0WmlwKCk7XG4gICAgICBpZiAoIWpzU2NhbkRpcikge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgSnNTY2FuRGlyXG4gICAgICAgIH0gPSBhd2FpdCBpbXBvcnQoJy4uL2ZpbGVzL2pzLXNjYW5kaXIuanMnKTtcbiAgICAgICAgY29uc3QgcHJvY2Vzc19maWxlID0gYXN5bmMgKGVudHJ5LCBjYWxsYmFjaykgPT4ge1xuICAgICAgICAgIGlmIChhY2NlcHRGaWxlKGVudHJ5KSkge1xuICAgICAgICAgICAgcHJvcGVydGllcy5jYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgICAgICAgICAgYXdhaXQgcHJvY2Vzc0ZpbGUoZW50cnkpO1xuICAgICAgICAgIH0gZWxzZSByZWplY3RGaWxlKGVudHJ5LCBjYWxsYmFjayk7XG4gICAgICAgIH1cbiAgICAgICAganNTY2FuRGlyID0gSnNTY2FuRGlyKHByb2Nlc3NfZmlsZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgYXN5bmMgZnVuY3Rpb24gc2NhbkJyb3dzZShwaWNrLCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCBlbnRyaWVzID0gKHBpY2sgaW5zdGFuY2VvZiBGaWxlTGlzdCkgPyBBcnJheS5mcm9tKHBpY2spIDogKHBpY2sua2luZCA9PT0gXCJkaXJlY3RvcnlcIikgPyBhd2FpdCBBcnJheS5mcm9tQXN5bmMocGljay52YWx1ZXMoKSk6IChBcnJheS5pc0FycmF5KHBpY2spKSA/IHBpY2sgOiBbcGlja107XG4gICAgY29uc3QgbmFtZSA9IGVudHJpZXNbMF0ubmFtZTtcbiAgICBsZXQgcmVscGF0aCA9IChwaWNrIGluc3RhbmNlb2YgRmlsZUxpc3QpID8gZW50cmllc1swXS53ZWJraXRSZWxhdGl2ZVBhdGggOiBudWxsO1xuICAgIHJlbHBhdGggPSAocmVscGF0aCkgPyByZWxwYXRoLnNwbGl0KGRpcnNlcGFyYXRvcikgOiBbYGBdO1xuICAgIGlmIChyZWxwYXRoLmxlbmd0aCkgcmVscGF0aC5wb3AoKTtcbiAgICByZWxwYXRoID0gcmVscGF0aC5qb2luKGRpcnNlcGFyYXRvcik7XG4gICAgY29uc3QgcGF0aCA9IChwaWNrIGluc3RhbmNlb2YgRmlsZUxpc3QpID8gcmVscGF0aCA6IChwaWNrLmtpbmQgPT09IFwiZGlyZWN0b3J5XCIpID8gcGljay5uYW1lIDogYGA7XG4gICAgYXdhaXQgc2NhbkNvbW1vbihwYXRoLCBvcHRpb25zKTtcbiAgICBhd2FpdCBqc1NjYW5EaXIucHJvY2Vzc0VudHJpZXMoZW50cmllcywgcGF0aCwgKCkgPT4ge1xuICAgICAgZGlyQ29tcGxldGUoKTtcbiAgICB9KTtcbiAgfVxuXG4gIGFzeW5jIGZ1bmN0aW9uIHNjYW5IYW5kbGUoZHJvcHBlZCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgYXdhaXQgc2NhbkNvbW1vbihkcm9wcGVkLm5hbWUsIG9wdGlvbnMpO1xuICAgIGlmIChkcm9wcGVkLmlzRGlyZWN0b3J5ID09PSB0cnVlKSB7XG4gICAgICBhd2FpdCBqc1NjYW5EaXIucmVhZERpcmVjdG9yeShkcm9wcGVkLCAoKSA9PiB7XG4gICAgICAgIGRpckNvbXBsZXRlKCk7XG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKGRyb3BwZWQuaXNGaWxlID09PSB0cnVlKSB7XG4gICAgICBhd2FpdCBqc1NjYW5EaXIucHJvY2Vzc0ZpbGUoZHJvcHBlZCwgKCkgPT4ge1xuICAgICAgICBkaXJDb21wbGV0ZSgpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZGlyQ29tcGxldGUoKSB7XG4gICAgTW9kdWxlRXZlbnRFbWl0dGVyLmVtaXQoZXZlbnRuYW1lcy5lbmRyZWFkZGlyLCB7XG4gICAgICBuYW1lOiBldmVudG5hbWVzLmVuZHJlYWRkaXJcbiAgICB9LCB1dWlkKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGFkZEhhbmRsZXIoaGFuZGxlcikge1xuICAgIHByb3BlcnRpZXMuaGFuZGxlcnMucHVzaChoYW5kbGVyKTtcbiAgICBwcm9wZXJ0aWVzLmhhc2hhbmRsZXJzPSAocHJvcGVydGllcy5oYW5kbGVycy5sZW5ndGg+MClcbiAgfVxuXG4gIGFzeW5jIGZ1bmN0aW9uIGV4ZWNIYW5kbGVyKCkge1xuICAgIC8vIHNlcmllXG4gICAgaWYgKHByb3BlcnRpZXMuaGFzaGFuZGxlcnMpIHtcbiAgICAgIGNvbnN0IGhhbmRsZXIgPSBwcm9wZXJ0aWVzLmhhbmRsZXJzLnNoaWZ0KCk7XG4gICAgICBhd2FpdCBoYW5kbGVyKCk7XG4gICAgIHByb3BlcnRpZXMuaGFzaGFuZGxlcnMgPSAocHJvcGVydGllcy5oYW5kbGVycy5sZW5ndGg+MClcbiAgICB9XG4gICAgcmV0dXJuO1xuICB9XG4gICAgYXN5bmMgZnVuY3Rpb24gZ3ppcEJpZ0ZpbGUoZmlsZSwgZmlsZXBhdGgpIHtcbiAgICBsZXQgZHQgPSBEYXRlLm5vdygpO1xuICAgIGZpbGVwYXRoID0gKGZpbGVwYXRoLmluZGV4T2YoZGlyc2VwYXJhdG9yKSA9PT0gMCkgPyBmaWxlcGF0aC5zdWJzdHIoMSkgOiBmaWxlcGF0aDtcbiAgICBjb25zdCBwYXJ0cyA9IGZpbGVwYXRoLnNwbGl0KGRpcnNlcGFyYXRvcik7XG4gICAgcGFydHMucG9wKCk7XG4gICAgY29uc3Qgc2VuZHBhdGggPSB1cGxvYWRwYXRoICsgZGlyc2VwYXJhdG9yICtwYXJ0cy5qb2luKGRpcnNlcGFyYXRvcik7XG4gICAgY29uc3QgZXh0ID0gZmlsZS5uYW1lLnNsaWNlKGZpbGUubmFtZS5sYXN0SW5kZXhPZignLicpICsgMSk7XG4gICAgaWYgKGFscmVhZHlfY29tcHJlc3NlZC5oYXMoZXh0KSkge1xuICAgICAgIE1vZHVsZUV2ZW50RW1pdHRlci5lbWl0KGV2ZW50bmFtZXMuY291bnRlciwge1xuICAgICAgICBuYW1lOiAnemlwJyxcbiAgICAgICAgcGF0aDogZmlsZXBhdGgsXG4gICAgICAgIGJpZ2ZpbGU6ZmlsZS5uYW1lLFxuICAgICAgICBzaXplOiBmaWxlLnNpemVcbiAgICAgIH0sIHV1aWQpO1xuICAgICAgYWRkSGFuZGxlcihhc3luYyAoKSA9PiB7XG4gICAgICAgIGF3YWl0IHNlbmRDaHVuayhzZW5kcGF0aCxmaWxlKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgemlwbmFtZSA9IGZpbGUubmFtZSArICcuZ3onO1xuICAgICAgY29uc3Qge1xuICAgICAgICBmaWxlc3RyZWFtLFxuICAgICAgICBzdHJlYW1oYW5kbGVcbiAgICAgIH0gPSBhd2FpdCBjcmVhdGVMb2NhbFN0cmVhbSh6aXBuYW1lLCB7XG4gICAgICAgICdhcHBsaWNhdGlvbi9nemlwJzogWycuZ3onXSxcbiAgICAgIH0pO1xuICAgICAgbGV0IHBvcyA9IDA7XG5cbiAgICAgIGNvbnN0IGd6aXBwZWQgPSBuZXcgQXN5bmNHemlwKHtcbiAgICAgICAgbGV2ZWw6IDYsXG4gICAgICAgIGZpbGVuYW1lOiBmaWxlcGF0aFxuICAgICAgfSk7XG4gICAgICBnemlwcGVkLm9uZGF0YSA9IChlcnIsIGRhdGEsIGZpbmFsKSA9PiB7XG4gICAgICAgaWYocG9zID4gTUFYU0laRSkgIHtcbiAgICAgICAgICAgICAgICBwcm9wZXJ0aWVzLmNvdW50ZXIuZXJyb3IrPTE7XG4gICAgICAgICAgICAgIG9uRXJyb3IoQWxlcnRCb3guYWxlcnRjb25maWcudHlwZXMuZXJyb3IsIHtcblxuICAgICAgICAgICAgICAgIG5hbWU6QWxlcnRCb3guYWxlcnRjb25maWcudHlwZXMuZXJyb3IsXG4gICAgICAgICAgICAgICAgYmlnZmlsZTpmaWxlLm5hbWUsXG4gICAgICAgICAgICAgICAgcGF0aDpmaWxlcGF0aCxcbiAgICAgICAgICAgICAgICBtZXNzYWdlOidGaWxlICcrZmlsZS5uYW1lKycgc2l6ZSBleGNlZWRzIG1heHNpemUuIENhbm5vdCBiZSBzZW50IGluIGNodW5rcyBmb3IgdGhlIG1vbWVudC4nfSwgX2xpc3RlbmVyKTtcbiAgICAgICAgICBzdHJlYW1oYW5kbGUuY2xvc2UoKTtnemlwcGVkLm9uZGF0YT0gKGVyciwgZGF0YSwgZmluYWwpID0+IHt9OyByZXR1cm4gZW5kUHJvY2VzcygpO1xuICAgICAgICAgIH1cbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgcHJvcGVydGllcy5jb3VudGVyLmVycm9yKz0xO1xuICAgICAgICAgIG9uRXJyb3IoQWxlcnRCb3guYWxlcnRjb25maWcudHlwZXMuZXJyb3IsIHtcbiAgICAgICAgICAgIG5hbWU6QWxlcnRCb3guYWxlcnRjb25maWcudHlwZXMuZXJyb3IsXG4gICAgICAgICAgICBiaWdmaWxlOiBmaWxlLm5hbWUsXG4gICAgICAgICAgICBwYXRoOiBmaWxlcGF0aCxcbiAgICAgICAgICAgIHNpemU6IGZpbGUuc2l6ZSxcbiAgICAgICAgICAgIG1lc3NhZ2U6ICdFcnJvciBjb21wcmVzc2luZyBmaWxlICcrIGZpbGUubmFtZSArJyAnK2VyclxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN0cmVhbWhhbmRsZS53cml0ZShkYXRhLCB7XG4gICAgICAgICAgICBhdDogcG9zXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcG9zICs9IGRhdGEubGVuZ3RoO1xuICAgICAgICAgIGlmIChmaW5hbCkge1xuICAgICAgICAgICAgc3RyZWFtaGFuZGxlLmNsb3NlKCk7XG4gICAgICAgICAgICAgICAgIGZpbGVwYXRoKz0nLmd6JztcbiAgICAgICAgICAgICAgICBNb2R1bGVFdmVudEVtaXR0ZXIuZW1pdChldmVudG5hbWVzLmNvdW50ZXIsIHtcbiAgICAgICAgICAgICAgbmFtZTogJ3ppcCcsXG4gICAgICAgICAgICAgIHBhdGg6IGZpbGVwYXRoLFxuICAgICAgICAgICAgICBzaXplOiBmaWxlLnNpemUsXG4gICAgICAgICAgICAgIGJpZ2ZpbGU6ZmlsZS5uYW1lXG4gICAgICAgICAgICB9LCB1dWlkKTtcblxuICAgICAgICAgYWRkSGFuZGxlcihhc3luYyAoKSA9PiB7XG4gICAgICAgICBhd2FpdCBzZW5kQ2h1bmsoc2VuZHBhdGgsZmlsZXN0cmVhbSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBjb25zdCBjb3VudCA9IGZhbHNlO1xuICAgICAgYXdhaXQgcmVhZEZpbGUoZmlsZSwgZmlsZXBhdGgsIGd6aXBwZWQsIGNvdW50KTtcbiAgICB9XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gcGFydFppcCgpIHtcbiAgICBwcm9wZXJ0aWVzLnBhcnQgKz0gMTtcbiAgICBNb2R1bGVFdmVudEVtaXR0ZXIuZW1pdChldmVudG5hbWVzLmNvbXBsZXRlLCB7XG4gICAgIG5hbWU6IGV2ZW50bmFtZXMuZW5kemlwLFxuICAgICAgcGFydDogcHJvcGVydGllcy5wYXJ0XG4gICAgfSwgX2xpc3RlbmVyKTtcbiAgfVxuICBhc3luYyBmdW5jdGlvbiByZWFkRmlsZShmaWxlLCBmaWxlcGF0aCwgemlwcGVkc3RyZWFtLCBjb3VudCA9IHRydWUpIHtcbiAgICBjb25zdCByZWFkZXIgPSBmaWxlLnN0cmVhbSgpLmdldFJlYWRlcigpO1xuICAgIGxldCBwYXVzZSA9IGZhbHNlO1xuICAgIC8qICBvbkJhY2twcmVzc3VyZSh6aXBwZWRzdHJlYW0sIHRoaXMuc3RyZWFtaGFuZGxlLCBzaG91bGRfYXBwbHlfYmFja3ByZXNzdXJlID0+IHtcbiAgICAgICAgaWYgKHNob3VsZF9hcHBseV9iYWNrcHJlc3N1cmUpIHBhdXNlID0gdHJ1ZTtcbiAgICAgICAgZWxzZSBpZiAocGF1c2UpIHBhdXNlID0gZmFsc2U7XG4gICAgICB9KTsqL1xuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGRvbmUsXG4gICAgICAgIHZhbHVlXG4gICAgICB9ID0gYXdhaXQgcmVhZGVyLnJlYWQoKTtcbiAgICAgIGlmIChkb25lKSB7XG4gICAgICAgIHppcHBlZHN0cmVhbS5wdXNoKG5ldyBVaW50OEFycmF5KDApLCB0cnVlKTtcbiAgICAgICAgaWYgKGNvdW50ID09PSB0cnVlKSBNb2R1bGVFdmVudEVtaXR0ZXIuZW1pdChldmVudG5hbWVzLmNvdW50ZXIsIHtcbiAgICAgICAgICBuYW1lOiAnemlwJyxcbiAgICAgICAgICBwYXRoOiBmaWxlcGF0aCxcbiAgICAgICAgICBzaXplOiAoemlwcGVkc3RyZWFtLnNpemUpID8gemlwcGVkc3RyZWFtLnNpemUgOiBmaWxlLnNpemVcbiAgICAgICAgfSwgdXVpZCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgemlwcGVkc3RyZWFtLnB1c2godmFsdWUpO1xuICAgIH1cbiAgfVxuXG4gIGFzeW5jIGZ1bmN0aW9uIHppcFN0cmVhbShmaWxlLCBmaWxlcGF0aCkge1xuICAgIGNvbnN0IGV4dCA9IGZpbGVwYXRoLnNsaWNlKGZpbGVwYXRoLmxhc3RJbmRleE9mKCcuJykgKyAxKTtcbiAgICBjb25zdCBpc2NvbXByZXNzZWQgPSBhbHJlYWR5X2NvbXByZXNzZWQuaGFzKGV4dCk7XG4gICAgY29uc3QgemlwcGVkc3RyZWFtID0gKGlzY29tcHJlc3NlZCkgPyBuZXcgWmlwUGFzc1Rocm91Z2goZmlsZXBhdGgpIDogZmlsZS5zaXplID4gb3B0aW9ucy5sYXJnZWZpbGUgP1xuICAgICAgbmV3IEFzeW5jWmlwRGVmbGF0ZShmaWxlcGF0aCwge1xuICAgICAgICBsZXZlbDogNixcbiAgICAgIH0pIDogbmV3IFppcERlZmxhdGUoZmlsZXBhdGgsIHtcbiAgICAgICAgbGV2ZWw6IDZcbiAgICAgIH0pO1xuICAgICAgcHJvcGVydGllcy56aXAuYWRkKHppcHBlZHN0cmVhbSk7XG4gICAgYXdhaXQgcmVhZEZpbGUoZmlsZSwgZmlsZXBhdGgsIHppcHBlZHN0cmVhbSk7XG4gIH1cbiAgZnVuY3Rpb24gY29tcHJlc3NlZF9lc3RpbWF0ZShmaWxlKSB7XG4gICAgY29uc3QgZXh0ID0gZmlsZS5uYW1lLnNsaWNlKGZpbGUubmFtZS5sYXN0SW5kZXhPZignLicpICsgMSk7XG4gICAgaWYgKGNhbl9iZV9jb21wcmVzc2VkLmhhcyhleHQpKSByZXR1cm4gTWF0aC5mbG9vcihmaWxlLnNpemUvMik7XG4gICAgcmV0dXJuIGZpbGUuc2l6ZTtcbiAgfVxuICBhc3luYyBmdW5jdGlvbiBhZGRGaWxlVG9aaXBTdHJlYW0oZmlsZSwgZmlsZXBhdGgsIGNvdW50ID0gdHJ1ZSkge1xuICAgIGlmIChjb3VudCA9PT0gdHJ1ZSkgTW9kdWxlRXZlbnRFbWl0dGVyLmVtaXQoZXZlbnRuYW1lcy5jb3VudGVyLCB7XG4gICAgICBuYW1lOiAnc2NhbicsXG4gICAgICBwYXRoOiBmaWxlcGF0aCxcbiAgICAgIHNpemU6IGZpbGUuc2l6ZVxuICAgIH0sIHV1aWQpO1xuICAgIHByb3BlcnRpZXMuZm9sbG93ID0gbnVsbDtcblxuICAgIC8vIGNoZWNrIGZpbGUgc2l6ZSA+IG1heCBwb3N0IHNpemVcbiAgICBjb25zdCBjb21wcmVzc2VkX3NpemUgPSBjb21wcmVzc2VkX2VzdGltYXRlKGZpbGUpO1xuICAgIGlmIChjb21wcmVzc2VkX3NpemUgPj0gTUFYU0laRSApIHtcbiAgICAvLyB0byBwcmV2ZW50IGVycm9ycyBhbmQgdW5jb21wbGV0ZSB6aXAgc2VuZCBlcnJvclxuICAgICAgcHJvcGVydGllcy5jb3VudGVyLmVycm9yKz0xO1xuICAgICAgaWYoVVBMT0FESU5QQVJUUykgZ3ppcEJpZ0ZpbGUoZmlsZSwgZmlsZXBhdGgpO1xuICAgICAgZWxzZSBlbmRQcm9jZXNzKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGNoZWNrIHppcCBmaWxlIHNpemUgPiB0b3RhbCB6aXAgc2l6ZVxuICAgICAgcHJvcGVydGllcy5zaXpldG96aXAgKz0gY29tcHJlc3NlZF9zaXplO1xuICAgICAgaWYgKHByb3BlcnRpZXMuc2l6ZXRvemlwID4gTUFYU0laRSkge1xuICAgICAgaWYoVVBMT0FESU5QQVJUUykge1xuICAgICAgcHJvcGVydGllcy5mb2xsb3cgPSBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgYXdhaXQgemlwU3RyZWFtKGZpbGUsIGZpbGVwYXRoKTtcbiAgICAgICAgfVxuICAgICAgICBwYXJ0WmlwKCk7XG4gICAgICAgIH0gZWxzZSBlbmRQcm9jZXNzKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhd2FpdCB6aXBTdHJlYW0oZmlsZSwgZmlsZXBhdGgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGFjY2VwdEZpbGUoZW50cnkpIHtcbiAgICBjb25zdCBmaWxlcGF0aCA9IGVudHJ5Lm5hbWU7XG4gICAgY29uc3QgZXh0ID0gZmlsZXBhdGguc2xpY2UoZmlsZXBhdGgubGFzdEluZGV4T2YoJy4nKSArIDEpO1xuICAgIHJldHVybiBhY2NlcHQuaW5jbHVkZXMoZXh0KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlamVjdEZpbGUoZmlsZSwgY2FsbGJhY2sgPSBudWxsKSB7XG4gICAgY29uc3QgcGF0aCA9IChmaWxlLmZ1bGxQYXRoKSA/IGZpbGUuZnVsbFBhdGggOiBmaWxlLndlYmtpdFJlbGF0aXZlUGF0aDtcbiAgICBwcm9wZXJ0aWVzLmNvdW50ZXIucmVqZWN0ICs9IDE7XG4gICAgTW9kdWxlRXZlbnRFbWl0dGVyLmVtaXQoZXZlbnRuYW1lcy5yZWplY3QsIHtcbiAgICAgIG5hbWU6IGV2ZW50bmFtZXMucmVqZWN0LFxuICAgICAgcGF0aDogcGF0aCxcbiAgICB9LCBfbGlzdGVuZXIpO1xuICAgIGlmIChjYWxsYmFjayAhPT0gbnVsbCkgY2FsbGJhY2soKTtcbiAgfVxuICBhc3luYyBmdW5jdGlvbiBwcm9jZXNzRmlsZShlbnRyeSkge1xuICAgIGNvbnN0IGVudHJ5cGF0aCA9IChlbnRyeS5mdWxsUGF0aCkgPyBlbnRyeS5mdWxsUGF0aCA6IGVudHJ5LndlYmtpdFJlbGF0aXZlUGF0aDtcbiAgICBlbnRyeS5maWxlKGFzeW5jIGZpbGUgPT4ge1xuICAgICAgYXdhaXQgYWRkRmlsZVRvWmlwU3RyZWFtKGZpbGUsIGVudHJ5cGF0aCk7XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBvbkVycm9yKGFjdGlvbiwgbWVzc2FnZSA9IG51bGwpIHtcbiAgICBtZXNzYWdlID0gKG1lc3NhZ2UpID8gbWVzc2FnZSA6IHt9O1xuICAgIHN3aXRjaCAoYWN0aW9uKSB7XG4gICAgICBjYXNlIGV2ZW50bmFtZXMuaW5pdDpcbiAgICAgIGNhc2UgZXZlbnRuYW1lcy5lcnJvcmZpbGU6XG4gICAgICAgIG1lc3NhZ2UubmFtZT1hY3Rpb247XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgLy9tZXNzYWdlLm5hbWUgPSBldmVudG5hbWVzLmVycm9yO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gICAgTW9kdWxlRXZlbnRFbWl0dGVyLmVtaXQoZXZlbnRuYW1lcy5tZXNzYWdlLCBtZXNzYWdlLCBfbGlzdGVuZXIpO1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIHNlYXJjaFN0b3JhZ2Uoc2VhcmNoKSB7XG4gICAgY29uc3QgZW50cnkgPSBhd2FpdCBuYXZpZ2F0b3Iuc3RvcmFnZS5nZXREaXJlY3RvcnkoKTtcbiAgICBmb3IgYXdhaXQgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBlbnRyeS5lbnRyaWVzKCkpIHtcbiAgICAgIGlmIChzZWFyY2ggPT09IGtleSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBhc3luYyBmdW5jdGlvbiBjbGVhblN0b3JhZ2UoZW50cnkgPSBudWxsKSB7XG4gICAgZW50cnkgPSAoZW50cnkpID8gZW50cnkgOiBhd2FpdCBuYXZpZ2F0b3Iuc3RvcmFnZS5nZXREaXJlY3RvcnkoKTtcbiAgICAgZm9yIGF3YWl0IChjb25zdCBba2V5LCB2YWx1ZV0gb2YgZW50cnkuZW50cmllcygpKSB7XG4gICAgICB0cnkge1xuICAgICAgICBhd2FpdCBlbnRyeS5yZW1vdmVFbnRyeShrZXkpO1xuICAgICAgICBjb25zb2xlLmxvZygnIFN1Y2Nlc3MgcmVtb3ZlIHN0b3JhZ2UgJywga2V5KTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCcgZXJyb3IgcmVtb3ZlIHN0b3JhZ2UgJyArIGtleSwgZXJyb3IpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuYXN5bmMgZnVuY3Rpb24gbGlzdFN0b3JhZ2UoZW50cnkgPSBudWxsLG5hbWU9bnVsbCkge1xuICAgIGVudHJ5ID0gKGVudHJ5KSA/IGVudHJ5IDogYXdhaXQgbmF2aWdhdG9yLnN0b3JhZ2UuZ2V0RGlyZWN0b3J5KCk7XG4gICAgbGV0IHJlcD10cnVlO1xuICAgICBmb3IgYXdhaXQgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBlbnRyeS5lbnRyaWVzKCkpIHtcbiAgICAgICAgaWYgKG5hbWUhPT1udWxsKSB7XG4gICAgICAgICAgICBjb25zdCBwYXJ0cyA9IGtleS5zcGxpdCgnLicpO1xuICAgICAgICAgICAgaWYgKHBhcnRzLnBvcCgpPT09J2Nyc3dhcCcgJiYgcGFydHMuam9pbignLicpID09PW5hbWUpIHtcbiAgICAgICAgICAgIHJlcD1mYWxzZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIHJldHVybiByZXA7XG4gICAgfVxuICBhc3luYyBmdW5jdGlvbiBlbmRGZXRjaChtZXNzYWdlLCBjbGVhbiA9IGZhbHNlKSB7XG4gICAgaWYgKHByb3BlcnRpZXMuZm9sbG93KSB7XG4gICAgICBwcm9wZXJ0aWVzLnN0cmVhbWhhbmRsZSA9IGF3YWl0IHByb3BlcnRpZXMuZmlsZXN0cmVhbS5jcmVhdGVXcml0YWJsZSh7bW9kZTpcImV4Y2x1c2l2ZVwifSk7XG4gICAgICBtZXNzYWdlLm5hbWUgPSBldmVudG5hbWVzLmZvbGxvdztcbiAgICAgIE1vZHVsZUV2ZW50RW1pdHRlci5lbWl0KGV2ZW50bmFtZXMuZm9sbG93LCBtZXNzYWdlLCBfbGlzdGVuZXIpO1xuICAgICAgYXdhaXQgaW5pdFppcCgpO1xuICAgICAgcmV0dXJuO1xuICAgIH0gZWxzZSBwcm9wZXJ0aWVzLnppcCA9IG51bGw7XG4gICAgaWYgKCFwcm9wZXJ0aWVzLmhhc2hhbmRsZXJzKSB7bWVzc2FnZS5uYW1lID0gZXZlbnRuYW1lcy50ZXJtaW5hdGU7TW9kdWxlRXZlbnRFbWl0dGVyLmVtaXQoZXZlbnRuYW1lcy5jb21wbGV0ZSwgbWVzc2FnZSwgX2xpc3RlbmVyKTt9XG4gIH1cblxuICBhc3luYyBmdW5jdGlvbiBzZW5kQ2h1bmsocGF0aCxnemlwcGVkLCBzdGFydCA9IDAsIGNodW5rbnVtID0gMCwgY2h1bmtzaXplID0gTUFYU0laRSkge1xuICAgIGNvbnN0IGV4dCA9IGd6aXBwZWQubmFtZS5zbGljZShnemlwcGVkLm5hbWUubGFzdEluZGV4T2YoJy4nKSArIDEpO1xuICAgIGNvbnN0IGZpbGUgPSAoYWxyZWFkeV9jb21wcmVzc2VkLmhhcyhleHQpKT9nemlwcGVkOmF3YWl0IGd6aXBwZWQuZ2V0RmlsZSgpO1xuICAgIGNvbnN0IGVuZCA9IE1hdGgubWluKHN0YXJ0ICsgY2h1bmtzaXplLCBmaWxlLnNpemUpO1xuICAgIGlmIChlbmQgPT09IGZpbGUuc2l6ZSkge1xuICAgIHBhdGg9cGF0aC5yZXBsYWNlKGZpbGUubmFtZSwnJyk7XG4gICAgIHNlbmRaaXBGaWxlKGZpbGUsIHBhdGgsIG51bGwsIHRydWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHByb3BlcnRpZXMuY291bnRlci5lcnJvcis9MTtcbiAgICBvbkVycm9yKGV2ZW50bmFtZXMuZXJyb3JmaWxlLCB7XG4gICAgICAgICAgbmFtZTogZXZlbnRuYW1lcy5lcnJvcixcbiAgICAgICAgICBtZXNzYWdlOidGaWxlICcrcGF0aCtkaXJzZXBhcmF0b3IrZmlsZS5uYW1lKycgc2l6ZSBleGNlZWRzIGNhcGFjaXR5LiBDaHVuayBmdW5jdGlvbmFsaXR5IG5vdCBzdXBwb3J0ZWQgZm9yIHRoZSBtb21lbnQuJ1xuICAgICAgICB9LCBfbGlzdGVuZXIpO1xuICAgIHJldHVybiBlbmRQcm9jZXNzKCkgO1xuICAgIC8vIGZvciB0aGUgbW9tZW50IGVjb3RheGFiYWNrIGRvZXMgbm90IHN1cHBvcnQgY2h1bmtzXG4gICAgICBjb25zdCBwYXJ0ZmlsZSA9IGZpbGUuc2xpY2Uoc3RhcnQsIGVuZCk7XG4gICAgICBwYXJ0ZmlsZS5uYW1lID0gY2h1bmtudW0gKyAnXycgKyBmaWxlLm5hbWU7XG4gICAgICBhd2FpdCBzZW5kWmlwRmlsZShwYXJ0ZmlsZSwgcGF0aCwgYXN5bmMgKCkgPT4ge1xuICAgICAgICBzdGFydCArPSBlbmQ7XG4gICAgICAgIGNodW5rbnVtKys7XG4gICAgICAgIGlmIChzdGFydCA8PSBmaWxlLnNpemUpIGF3YWl0IHNlbmRDaHVuayhwYXRoLCBnemlwcGVkLHN0YXJ0LCBjaHVua251bSwgY2h1bmtzaXplKTtcbiAgICAgIH0sIHRydWUpXG4gICAgfVxuICAgIHJldHVybiBjaHVua251bTtcbiAgfVxuICBhc3luYyBmdW5jdGlvbiBnZXRGaWxlKGZpbGVzdHJlYW0gPSBudWxsKSB7XG4gICAgZmlsZXN0cmVhbSA9IChmaWxlc3RyZWFtID09PSBudWxsKSA/IHByb3BlcnRpZXMuZmlsZXN0cmVhbSA6IGZpbGVzdHJlYW07XG4gICAgY29uc3QgZmlsZSA9IGF3YWl0IGZpbGVzdHJlYW0uZ2V0RmlsZSgpO1xuICAgIHJldHVybiBmaWxlO1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIHNlbmRaaXBGaWxlKGZpbGUsIHBhdGgsIGNhbGxiYWNrY2h1bmsgPSBudWxsLCBiaWdmaWxlID0gZmFsc2UpIHtcbiAgaWYocHJvcGVydGllcy5jb3VudGVyLmVycm9yPjApIHJldHVybiBlbmRQcm9jZXNzKCk7XG4gICAgY29uc3QgbWVzc2FnZSA9IHtcbiAgICAgIG5hbWU6IGV2ZW50bmFtZXMucGVuZGluZyxcbiAgICAgIGJpZ2ZpbGU6YmlnZmlsZSxcbiAgICAgIHBhdGg6IHBhdGhcbiAgICB9XG4gICAgY29uc3QgZm9ybWRhdGEgPSBuZXcgRm9ybURhdGEoKTtcbiAgICBwYXRoID0gcGF0aCArICgocGF0aC5zbGljZSgtMSkgPT09IGRpcnNlcGFyYXRvcikgPyBgYCA6IGRpcnNlcGFyYXRvcikgKyBmaWxlLm5hbWU7XG4gICAgZm9ybWRhdGEuYXBwZW5kKCdwYXRoJywgcGF0aCk7XG4gICAgZm9ybWRhdGEuYXBwZW5kKCdmaWxlJywgZmlsZSwgZmlsZS5uYW1lKTtcbiAgICBpZiAocHJvcGVydGllcy5wYXJ0KSBmb3JtZGF0YS5hcHBlbmQoJ3BhcnQnLCBwcm9wZXJ0aWVzLnBhcnQpO1xuICAgIGVsc2UgaWYgKGNhbGxiYWNrY2h1bmsgIT09IG51bGwpIGZvcm1kYXRhLmFwcGVuZCgnaXNjaHVuaycsIHRydWUpO1xuICAgIG1lc3NhZ2UucGF0aCA9IHBhdGg7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChvcHRpb25zLnVwbG9hZHVybCwge1xuICAgICAgLy8gIG1vZGU6ICdjb3JzJyxcbiAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICBjcmVkZW50aWFsczogXCJpbmNsdWRlXCIsXG4gICAgICBib2R5OiBmb3JtZGF0YSxcbiAgICB9KTtcbiAgICBjb25zdCBib2R5PWF3YWl0IHJlc3BvbnNlLnRleHQoKTtcbiAgICAgIGlmIChyZXNwb25zZS5vaykge1xuICAgICAgaWYgKGNhbGxiYWNrY2h1bmspIHtcbiAgICAgICAgYXdhaXQgY2FsbGJhY2tjaHVuaygpO1xuICAgICAgfSBlbHNlIHsgaWYoIWJpZ2ZpbGUgfHwgIXByb3BlcnRpZXMuaGFzaGFuZGxlcnMpICBhd2FpdCBlbmRGZXRjaChtZXNzYWdlKTtcbiAgICAgICBpZiAoYmlnZmlsZSkge21lc3NhZ2UubmFtZT1ldmVudG5hbWVzLmZvbGxvdztcbiAgICAgIE1vZHVsZUV2ZW50RW1pdHRlci5lbWl0KGV2ZW50bmFtZXMuZm9sbG93LCBtZXNzYWdlLCBfbGlzdGVuZXIpO1xuICAgICAgfSB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwcm9wZXJ0aWVzLmZvbGxvdz1udWxsO1xuICAgICAgICBhd2FpdCBlbmRGZXRjaChtZXNzYWdlKTtcbiAgICAgICAgIHByb3BlcnRpZXMuY291bnRlci5lcnJvcis9MTtcbiAgICAgICAgb25FcnJvcihldmVudG5hbWVzLmVycm9yZmlsZSwgbWVzc2FnZSk7IGlmKGJpZ2ZpbGUgfHwgcHJvcGVydGllcy5oYXNoYW5kbGVycykgZW5kUHJvY2VzcygpOyAgICB9XG4gIH1cbiAgZnVuY3Rpb24gZW5kUHJvY2VzcygpIHtcbiAgICBwcm9wZXJ0aWVzLmZvbGxvdz1udWxsO1xuICAgIG9uRXJyb3IoZXZlbnRuYW1lcy5lcnJvcmZpbGUse1xuICAgICAgICAgICAgbmFtZTogQWxlcnRCb3guYWxlcnRjb25maWcudHlwZXMuZXJyb3IsXG4gICAgICAgICAgICBtZXNzYWdlOiBcIlVwbG9hZCBub3QgZG9uZS4gb25lIG9yIG1vcmUgZmlsZXMgZXhjZWVkcyBtYXggdXBsb2FkIHNpemVcIixcbiAgICAgICAgICAgIHBhdGg6dXBsb2FkcGF0aCxcbiAgICAgICAgICAgIH0pO1xuICAgIHJlc2V0KCkudGhlbigoKSA9PiB7XG4gICAgICAgIE1vZHVsZUV2ZW50RW1pdHRlci5lbWl0KGV2ZW50bmFtZXMuY29tcGxldGUsIHtcbiAgICAgICAgICBuYW1lOiBldmVudG5hbWVzLnJlYWR5XG4gICAgICAgIH0sIF9saXN0ZW5lcik7XG4gICAgICAgIHByb3BlcnRpZXMuZW5kcmVhZGRpciA9IGZhbHNlOyAgfSk7XG4gICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgcmV0dXJuIHtcbiAgICB1dWlkLFxuICAgIGV2ZW50bmFtZXMsXG4gICAgc2NhbkJyb3dzZSxcbiAgICBzY2FuSGFuZGxlLFxuICAgIHF1b3RhRXN0aW1hdGUsXG4gICAgYnJvd3NlclJlcXVpcmVkXG4gIH1cbn0iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/modules/files/js-dirtozip.js\n")}}]);