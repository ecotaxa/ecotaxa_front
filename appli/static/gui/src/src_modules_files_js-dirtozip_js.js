/*! For license information please see src_modules_files_js-dirtozip_js.js.LICENSE.txt */
"use strict";(self.webpackChunk=self.webpackChunk||[]).push([["src_modules_files_js-dirtozip_js"],{"./src/modules/files/js-dirtozip.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   JsDirToZip: () => (/* binding */ JsDirToZip)\n/* harmony export */ });\n/* harmony import */ var _modules_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../modules/utils.js */ \"./src/modules/utils.js\");\n/* harmony import */ var fflate__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! fflate */ \"./node_modules/fflate/esm/browser.js\");\n\n\n\n\nconst already_compressed = new Set([\n  'zip', 'gz', 'png', 'jpg', 'jpeg', 'pdf', 'doc', 'docx', 'ppt', 'pptx',\n  'xls', 'xlsx', 'heic', 'heif', '7z', 'bz2', 'rar', 'gif', 'webp', 'webm',\n  'mp4', 'mov', 'mp3', 'aifc'\n]);\nconst accept = '.tsv,.png,.jpg, .jpeg,.zip,.gz,.7z,.bz2';\nlet instance = null;\nconst MAXSIZE = 1073741824; //4294967296; //// 3221225472; // 2147483648; // 1073741824;   // ////1073741824; ////maxfilesize: 1073741824,\nclass JsDirToZip {\n  _events = {};\n  eventnames = {\n    ready: 'ready',\n    follow: 'follow',\n    endzip: 'endzip',\n    complete: 'complete',\n    endreaddir: 'endreaddir',\n    gzip: 'gzip',\n    sendfile: 'sendfile',\n    bigfile: 'bigfile',\n    terminate: 'terminate',\n    pending: 'pending',\n    errorfile: 'errorfile',\n    counter: 'counter',\n    clientcounter: 'clientcounter',\n    reject: 'reject',\n    message: 'message',\n    error: 'error',\n    init: 'init'\n  }\n\n  // uses https://developer.mozilla.org/en-US/docs/Web/API/File_System_API/Origin_private_file_system\n  //# alternative (not supported in Safari) for .createWritable\n  constructor(options = {}) {\n    if (instance) return instance;\n    const defaultOptions = {\n      uploadurl: '/gui/files/upload',\n      largefile: MAXSIZE, // 1073741824, // 2147483648, // //4294967296, // 4194304,\n      accept: accept.split(',')\n    }\n    this.options = { ...defaultOptions,\n      ...options\n    };\n    this.init();\n    instance = this;\n    return instance;\n  }\n  init() {\n    (0,_modules_utils_js__WEBPACK_IMPORTED_MODULE_0__.add_custom_events)(this);\n    this.initProps();\n    this.on(this.eventnames.init, async (e) => {\n      //  if (!e.bigfile && !e.part) {\n      if (this.isActive() === false) {\n        console.log('reset terminate event end')\n        await this.reset();\n        this.emit(this.eventnames.complete, {\n          name: this.eventnames.ready\n        });\n        this.endreaddir = false;\n      } else console.log(' partly finshed ', e);\n    });\n    this.on(this.eventnames.endzip, (e) => {\n\n      if (!e.bigfile && this.zip) {\n        this.zip.end();\n      } else if (e.bigfile && this.gzipped) {\n        console.log(' -------------------------gzipped end ', this.gzipped);\n      }\n      const message = this.buildMessage(e, {\n        name: this.eventnames.sendfile,\n      });\n      console.log('endzip%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%', message)\n      this.emit(this.eventnames.complete, message);\n    });\n\n    this.on(this.eventnames.sendfile, async (e) => {\n      const file = (e.bigfile) ? await this.gzipped.getFile(): await this.getFile();\n      if (e.bigfile) {\n        const path = (e.path ? e.path : '').replace(e.bigfile, '');\n        this.sendChunk(path);\n      } else this.sendZipFile(file, (e.path ? e.path : ''), null);\n    });\n    this.on(this.eventnames.bigfile, (e) => {\n      console.log('onsendchunk', e)\n      const path = (e.path ? e.path : '').replace(e.bigfile, '');\n      this.sendChunk(path);\n    });\n    this.on(this.eventnames.endreaddir, (e) => {\n      this.endreaddir = true;\n      this.checkProcessed(e);\n    });\n    this.on(this.eventnames.counter, async (e) => {\n      this.endcounter = false;\n      this.counter[e.name] += 1;\n      this.emit(this.eventnames.clientcounter, e);\n      if (e.name === 'zip' && this.counter.scan === this.counter.zip) {\n        this.endcounter = true;\n        this.checkProcessed(e);\n      }\n      if (e.name === 'zip' && this.callback) await this.callback();\n    });\n\n  }\n\n  initProps() {\n    this.zip = null;\n    this.zipname = null;\n    this.filestream = null;\n    this.streamhandle = null;\n    this.gzipped = null;\n    this.sizetozip = 0;\n    this.part = 0;\n    this.continue = null;\n    this.endcounter = false;\n    this.counter = {\n      scan: 0,\n      zip: 0,\n      reject: 0\n    }\n    this.handlers = [];\n  }\n\n  async reset() {\n    this.initProps();\n    await this.initStorage();\n  }\n  isActive() {\n    return (this.zip !== null || this.continue !== null || this.gzipped !== null || this.endreaddir !== true);\n  }\n  async initZip() {\n    const self = this;\n    this.pos = 0;\n    this.sizetozip = 0;\n    console.log('==================newzip');\n    this.zip = new fflate__WEBPACK_IMPORTED_MODULE_1__.Zip((error, chunk, final) => {\n      if (error) {\n        console.log('error', error);\n        return false;\n      } else {\n        self.streamhandle.write(chunk, {\n          at: self.pos\n        });\n        self.pos += chunk.length;\n        if (final) {\n          self.streamhandle.close();\n          console.log('final-----------------------------*******************************-', self.pos);\n\n        }\n\n      }\n    });\n    // hack for memory usage\n    this.zipOnData();\n\n    if (this.continue) await this.continue();\n  }\n  checkProcessed(e) {\n    if (this.endreaddir === true && this.endcounter === true) {\n      const message = this.buildMessage(e, {\n        name: this.eventnames.endzip\n      });\n      this.emit(this.eventnames.complete, message);\n    }\n  }\n  zipOnData(zip = null) {\n    zip = (zip === null) ? this.zip : zip;\n    const ondata = zip.ondata;\n    zip.ondata = (error, data, final) => {\n      ondata(error, data, final);\n      if (final) {\n        zip.d = null;\n        zip.u.at(-1).d = null; // Object created in `zip.add()`\n      }\n    }\n  }\n\n  buildMessage(e, message = {}) {\n    if (e.hasOwnProperty(\"part\")) {\n      message.part = e.part;\n    } else this.part = 0;\n    if (e.hasOwnProperty(\"bigfile\")) message.bigfile = e.bigfile;\n    if (e.hasOwnProperty(\"path\")) message.path = e.path;\n    return message;\n  }\n  async quotaEstimate() {\n    if (navigator && navigator.storage && navigator.storage.estimate) {\n      navigator.storage.estimate().then((quota) => {\n        const percentageUsed = ((quota.usage / quota.quota) * 100).toFixed(2);\n        const remaining = (0,_modules_utils_js__WEBPACK_IMPORTED_MODULE_0__.format_bytes)(quota.quota - quota.usage);\n        this.emit(this.eventnames.message, {\n          id: \"quota\",\n          name: \"console\",\n          message: \"you've used \" + percentageUsed + \"% of the available storage (\" + remaining + \").\",\n        });\n      });\n    }\n  }\n\n  async initStorage() {\n    if (navigator && navigator.storage && navigator.storage.estimate) {\n      await this.cleanStorage();\n      this.quotaEstimate();\n    } else this.emit(this.eventnames.message, {\n      name: \"error\",\n      message: \"no navigator storage\"\n    });\n  }\n  async createLocalStream(name, accept = {\n    'application/zip': ['.zip'],\n  }) {\n    const root = await navigator.storage.getDirectory();\n    const opts = {\n      types: [{\n        description: 'Temp file',\n        accept: accept,\n      }, ],\n      create: true\n    };\n    const filestream = await root.getFileHandle(name, opts);\n    const streamhandle = await filestream.createWritable();\n    return {\n      filestream,\n      streamhandle\n    };\n  }\n  async scanCommon(zipname, options = {}) {\n    this.endreaddir = false;\n    if (this.zip === null) {\n      console.log('scancommmon zipname', zipname)\n      zipname = zipname.split(_modules_utils_js__WEBPACK_IMPORTED_MODULE_0__.dirseparator)[0];\n      zipname = (zipname.trim() === ``) ? 'temp' : zipname;\n      const type = (options && options.type) ? options.type : '.zip';\n      this.zipname = ((options.zipname) ? options.zipname : zipname) + type; //\n      const zipinstorage = await this.searchStorage(this.zipname);\n      if (zipinstorage) this.zipname = '1_' + this.zipname;\n      const {\n        filestream,\n        streamhandle\n      } = await this.createLocalStream(this.zipname);\n      this.filestream = filestream;\n      this.streamhandle = streamhandle;\n      let size = 0;\n      this.part = 0;\n      await this.initZip();\n      if (!this.jsScanDir) {\n        const {\n          JsScanDir\n        } = await __webpack_require__.e(/*! import() */ \"src_modules_files_js-scandir_js\").then(__webpack_require__.bind(__webpack_require__, /*! ../files/js-scandir.js */ \"./src/modules/files/js-scandir.js\"));\n        this.jsScanDir = new JsScanDir();\n      }\n      this.jsScanDir.processFile = async (entry, callback) => {\n        if (this.acceptFile(entry)) {\n          this.callback = callback;\n          await this.processFile(entry);\n        } else this.rejectFile(entry, callback);\n      }\n    }\n  }\n\n  async scanBrowse(pick, options = {}) {\n    const entries = (pick instanceof FileList) ? Array.from(pick) : (pick.kind === \"directory\") ? await Array.fromAsync(pick.values()): (Array.isArray(pick)) ? pick : [pick];\n    const name = entries[0].name;\n    let relpath = (pick instanceof FileList) ? entries[0].webkitRelativePath : null;\n    relpath = (relpath) ? relpath.split(_modules_utils_js__WEBPACK_IMPORTED_MODULE_0__.dirseparator) : [``];\n    if (relpath.length) relpath.pop();\n    relpath = relpath.join(_modules_utils_js__WEBPACK_IMPORTED_MODULE_0__.dirseparator)\n    const path = (pick instanceof FileList) ? relpath : (pick.kind === \"directory\") ? pick.name : ``;\n    await this.scanCommon(path, options);\n    await this.jsScanDir.processEntries(entries, path, () => {\n      this.dirComplete();\n    });\n  }\n\n  async scanHandle(dropped, options = {}) {\n    await this.scanCommon(dropped.name, options);\n    if (dropped.isDirectory === true) {\n      await this.jsScanDir.readDirectory(dropped, () => {\n        this.dirComplete();\n      });\n    } else if (dropped.isFile === true) {\n      await this.jsScanDir.processFile(dropped, () => {\n        this.dirComplete();\n      });\n    }\n  }\n\n  dirComplete() {\n    this.emit(this.eventnames.endreaddir, {\n      name: this.eventnames.endreaddir\n    });\n  }\n  addHandler(handler) {\n    this.handlers.push(handler);\n  }\n\n  async execHandler() {\n    // serie\n    if (this.handlers.length > 0) {\n      const handler = this.handlers.shift();\n      console.log('handler', handler)\n      await handler();\n    }\n    return;\n  }\n  async gzipBigFile(file, filepath) {\n    console.log('gzipbigfilepath', filepath)\n    if (this.gzipped !== null) {\n      await this.addHandler(async () => {\n        await this.gzipBigFile(file, filepath);\n      });\n      return;\n    }\n    this.dt = Date.now();\n    filepath = (filepath.indexOf(_modules_utils_js__WEBPACK_IMPORTED_MODULE_0__.dirseparator) === 0) ? filepath.substr(1) : filepath;\n    /*filepath = filepath.split(dirseparator);\n    filepath.pop();\n    filepath = filepath.join(dirseparator);*/\n    const ext = file.name.slice(file.name.lastIndexOf('.') + 1);\n\n    if (already_compressed.has(ext)) {\n      this.gzipped = file;\n      this.emit(this.eventnames.counter, {\n        name: 'zip',\n        path: filepath,\n        size: file.size\n      });\n      this.emit(this.eventnames.complete, {\n        name: this.eventnames.bigfile,\n        bigfile: file.name,\n        path: filepath,\n      });\n    } else {\n      let zipname = file.name + '.gz';\n      this.emit(this.eventnames.complete, {\n        name: this.eventnames.gzip,\n        bigfile: file.name,\n        path: filepath,\n        size: file.size\n      });\n      console.log(' gzipp ///////////////////////////////////////////////////', filepath);\n      const {\n        filestream,\n        streamhandle\n      } = await this.createLocalStream(zipname, {\n        'application/gzip': ['.gz'],\n      });\n      let pos = 0;\n      const self = this;\n\n      const gzipped = new fflate__WEBPACK_IMPORTED_MODULE_1__.AsyncGzip({\n        level: 6,\n        filename: filepath\n      });\n      gzipped.ondata = (err, data, final) => {\n        if (err) {\n          console.log('gzip err', err);\n          this.onError(this.eventnames.errorfile, {\n            bigfile: file.name,\n            path: filepath,\n            size: file.size\n          });\n        } else {\n          streamhandle.write(data, {\n            at: pos\n          });\n          pos += data.length;\n\n          if (final) {\n            console.log('final BIGFILE%%%%%%%%%%%%%%%%%%%%' + self.eventnames.bigfile, filepath)\n\n            console.log('timetogzzip', (Date.now() - self.dt) / 1000);\n\n            streamhandle.close();\n            self.gzipped = filestream;\n            self.emit(self.eventnames.counter, {\n              name: 'zip',\n              path: filepath,\n              size: file.size\n            });\n            self.emit(self.eventnames.complete, {\n              name: self.eventnames.bigfile,\n              bigfile: file.name,\n              path: filepath\n            });\n          }\n        }\n      };\n      const count = false;\n      await this.readFile(file, filepath, gzipped, count);\n    }\n\n\n  }\n  async partZip() {\n    this.part += 1;\n    this.emit(this.eventnames.complete, {\n      name: this.eventnames.endzip,\n      part: this.part\n    });\n  }\n  async readFile(file, filepath, zippedstream, count = true) {\n    const self = this;\n    const reader = file.stream().getReader();\n    let pause = false;\n    /*  onBackpressure(zippedstream, this.streamhandle, should_apply_backpressure => {\n        if (should_apply_backpressure) pause = true;\n        else if (pause) pause = false;\n      });*/\n    while (true) {\n      const {\n        done,\n        value\n      } = await reader.read();\n      if (done) {\n        zippedstream.push(new Uint8Array(0), true);\n        if (count === true) self.emit(self.eventnames.counter, {\n          name: 'zip',\n          path: filepath,\n          size: (zippedstream.size) ? zippedstream.size : file.size\n        });\n        break;\n      }\n      zippedstream.push(value);\n    }\n  }\n\n  async zipStream(file, filepath) {\n    const ext = filepath.slice(filepath.lastIndexOf('.') + 1);\n    const iscompressed = already_compressed.has(ext);\n    const zippedstream = (iscompressed) ? new fflate__WEBPACK_IMPORTED_MODULE_1__.ZipPassThrough(filepath) : file.size > this.options.largefile ?\n      new fflate__WEBPACK_IMPORTED_MODULE_1__.AsyncZipDeflate(filepath, {\n        level: 6,\n      }) : new fflate__WEBPACK_IMPORTED_MODULE_1__.ZipDeflate(filepath, {\n        level: 6\n      });\n    this.zip.add(zippedstream);\n    await this.readFile(file, filepath, zippedstream);\n  }\n\n  async addFileToZipStream(file, filepath, count = true) {\n    if (count === true) this.emit(this.eventnames.counter, {\n      name: 'scan',\n      path: filepath,\n      size: file.size\n    });\n    this.continue = null;\n    // check file size > max post size\n    if (file.size >= MAXSIZE) {\n      this.gzipBigFile(file, filepath);\n    } else {\n      // check zip file size > total zip size\n      this.sizetozip += file.size;\n      if (this.sizetozip >= MAXSIZE) {\n        this.continue = async () => {\n          await this.zipStream(file, filepath);\n        }\n        this.partZip();\n      } else {\n        await this.zipStream(file, filepath);\n      }\n    }\n  }\n\n  acceptFile(entry) {\n    const filepath = entry.name;\n    const ext = filepath.slice(filepath.lastIndexOf('.') + 1);\n    return accept.includes(ext);\n  }\n\n  rejectFile(file, callback = null) {\n    const path = (file.fullPath) ? file.fullPath : file.webkitRelativePath;\n    this.counter.reject += 1;\n    this.emit(this.eventnames.reject, {\n      name: this.eventnames.reject,\n      path: path,\n    });\n    if (callback !== null) callback();\n  }\n  async processFile(entry) {\n    const path = (entry.fullPath) ? entry.fullPath : entry.webkitRelativePath;\n    entry.file(async file => {\n      await this.addFileToZipStream(file, path);\n    });\n  }\n\n  onError(action, message = null) {\n\n    message = (message) ? message : {};\n    switch (action) {\n      case this.eventnames.init:\n        message.name = this.eventnames.init;\n        break;\n      case this.eventnames.errorfile:\n        console.log('errorfile', message);\n      default:\n        message.name = this.eventnames.follow;\n        break;\n    }\n    this.emit(this.eventnames.error, message);\n  }\n  async searchStorage(search) {\n    const entry = await navigator.storage.getDirectory();\n    for await (const [key, value] of entry.entries()) {\n      if (search === key) {\n        return true;\n        break;\n      }\n    }\n    return false;\n  }\n  async cleanStorage(entry = null) {\n    entry = (entry) ? entry : await navigator.storage.getDirectory();\n    for await (const [key, value] of entry.entries()) {\n      try {\n        await entry.removeEntry(key);\n        console.log(' Success remove storage ', key);\n      } catch (error) {\n        console.log(' error remove storage ' + key, error);\n      }\n    }\n\n  }\n\n  async endFetch(message, clean = false) {\n    message.name = this.eventnames.terminate;\n    if (this.continue) {\n      this.streamhandle = await this.filestream.createWritable();\n      message.name = this.eventnames.follow;\n      this.emit(this.eventnames.follow, message);\n      await this.initZip();\n      return;\n    } else if (message.hasOwnProperty(\"bigfile\") && message.bigfile !== false) {\n      this.gzipped = null;\n\n      if (this.handlers.length > 0) {\n        message.name = this.eventnames.follow;\n        this.emit(this.eventnames.follow, message);\n        console.log(' handlers to do', message);\n        if (this.handlers.length > 0) await this.execHandler();\n        return;\n      }\n    } else this.zip = null;\n    this.emit(this.eventnames.complete, message);\n  }\n\n  async sendChunk(path, start = 0, chunknum = 0, chunksize = MAXSIZE) {\n    console.log('send chunk ', this.gzipped)\n    const file = await this.gzipped.getFile();\n    const end = Math.min(start + chunksize, file.size);\n    if (end === file.size) {\n      this.sendZipFile(file, path, null, true);\n    } else {\n      const partfile = file.slice(start, end);\n      partfile.name = chunknum + '_' + file.name;\n      this.sendZipfile(partfile, path, () => {\n        start += end;\n        chunknum++;\n\n        if (start <= file.size) this.sendChunk(path, start, chunknum, chunksize);\n      }, true)\n    }\n    return chunknum;\n  }\n  async getFile(filestream = null) {\n    filestream = (filestream === null) ? this.filestream : filestream;\n    const file = await filestream.getFile();\n    return file;\n  }\n  async sendZipFile(file, path, callbackchunk = null, bigfile = false) {\n    const message = {\n      name: this.eventnames.pending,\n      path: path\n    }\n    if (bigfile) message.bigfile = file.name;\n    this.emit(this.eventnames.complete, message);\n    const formdata = new FormData();\n    path = path + ((path.slice(-1) === _modules_utils_js__WEBPACK_IMPORTED_MODULE_0__.dirseparator) ? `` : _modules_utils_js__WEBPACK_IMPORTED_MODULE_0__.dirseparator) + file.name;\n    formdata.append('path', path);\n    formdata.append('file', file, file.name);\n    if (this.part) formdata.append('part', this.part);\n    else if (callbackchunk !== null) formdata.append('ischunk', true);\n    fetch(this.options.uploadurl, {\n      //  mode: 'cors',\n      method: \"POST\",\n      credentials: \"include\",\n      body: formdata,\n    }).then(async (response) => {\n      console.log('response----------------------', response);\n      console.log('callbackchunk-------------------------------', callbackchunk)\n      message.path = path;\n      if (response.status !== 200) {\n        this.onError(this.eventnames.error, message);\n        return;\n      }\n      if (callbackchunk !== null) {\n        await callbackchunk();\n      } else await this.endFetch(message);\n    });\n  }\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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bW9kdWxlcy9maWxlcy9qcy1kaXJ0b3ppcC5qcz84NTM4Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcbmltcG9ydCB7XG4gIGFkZF9jdXN0b21fZXZlbnRzLFxuICBmZXRjaFNldHRpbmdzLFxuICBmb3JtYXRfYnl0ZXMsXG4gIGRpcnNlcGFyYXRvclxufSBmcm9tICcuLi8uLi9tb2R1bGVzL3V0aWxzLmpzJztcblxuaW1wb3J0IHtcbiAgQXN5bmNHemlwLFxuICBaaXAsXG4gIEFzeW5jWmlwRGVmbGF0ZSxcbiAgWmlwUGFzc1Rocm91Z2gsXG4gIFppcERlZmxhdGUsXG59IGZyb20gJ2ZmbGF0ZSc7XG5jb25zdCBhbHJlYWR5X2NvbXByZXNzZWQgPSBuZXcgU2V0KFtcbiAgJ3ppcCcsICdneicsICdwbmcnLCAnanBnJywgJ2pwZWcnLCAncGRmJywgJ2RvYycsICdkb2N4JywgJ3BwdCcsICdwcHR4JyxcbiAgJ3hscycsICd4bHN4JywgJ2hlaWMnLCAnaGVpZicsICc3eicsICdiejInLCAncmFyJywgJ2dpZicsICd3ZWJwJywgJ3dlYm0nLFxuICAnbXA0JywgJ21vdicsICdtcDMnLCAnYWlmYydcbl0pO1xuY29uc3QgYWNjZXB0ID0gJy50c3YsLnBuZywuanBnLCAuanBlZywuemlwLC5neiwuN3osLmJ6Mic7XG5sZXQgaW5zdGFuY2UgPSBudWxsO1xuY29uc3QgTUFYU0laRSA9IDEwNzM3NDE4MjQ7IC8vNDI5NDk2NzI5NjsgLy8vLyAzMjIxMjI1NDcyOyAvLyAyMTQ3NDgzNjQ4OyAvLyAxMDczNzQxODI0OyAgIC8vIC8vLy8xMDczNzQxODI0OyAvLy8vbWF4ZmlsZXNpemU6IDEwNzM3NDE4MjQsXG5leHBvcnQgY2xhc3MgSnNEaXJUb1ppcCB7XG4gIF9ldmVudHMgPSB7fTtcbiAgZXZlbnRuYW1lcyA9IHtcbiAgICByZWFkeTogJ3JlYWR5JyxcbiAgICBmb2xsb3c6ICdmb2xsb3cnLFxuICAgIGVuZHppcDogJ2VuZHppcCcsXG4gICAgY29tcGxldGU6ICdjb21wbGV0ZScsXG4gICAgZW5kcmVhZGRpcjogJ2VuZHJlYWRkaXInLFxuICAgIGd6aXA6ICdnemlwJyxcbiAgICBzZW5kZmlsZTogJ3NlbmRmaWxlJyxcbiAgICBiaWdmaWxlOiAnYmlnZmlsZScsXG4gICAgdGVybWluYXRlOiAndGVybWluYXRlJyxcbiAgICBwZW5kaW5nOiAncGVuZGluZycsXG4gICAgZXJyb3JmaWxlOiAnZXJyb3JmaWxlJyxcbiAgICBjb3VudGVyOiAnY291bnRlcicsXG4gICAgY2xpZW50Y291bnRlcjogJ2NsaWVudGNvdW50ZXInLFxuICAgIHJlamVjdDogJ3JlamVjdCcsXG4gICAgbWVzc2FnZTogJ21lc3NhZ2UnLFxuICAgIGVycm9yOiAnZXJyb3InLFxuICAgIGluaXQ6ICdpbml0J1xuICB9XG5cbiAgLy8gdXNlcyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvRmlsZV9TeXN0ZW1fQVBJL09yaWdpbl9wcml2YXRlX2ZpbGVfc3lzdGVtXG4gIC8vIyBhbHRlcm5hdGl2ZSAobm90IHN1cHBvcnRlZCBpbiBTYWZhcmkpIGZvciAuY3JlYXRlV3JpdGFibGVcbiAgY29uc3RydWN0b3Iob3B0aW9ucyA9IHt9KSB7XG4gICAgaWYgKGluc3RhbmNlKSByZXR1cm4gaW5zdGFuY2U7XG4gICAgY29uc3QgZGVmYXVsdE9wdGlvbnMgPSB7XG4gICAgICB1cGxvYWR1cmw6ICcvZ3VpL2ZpbGVzL3VwbG9hZCcsXG4gICAgICBsYXJnZWZpbGU6IE1BWFNJWkUsIC8vIDEwNzM3NDE4MjQsIC8vIDIxNDc0ODM2NDgsIC8vIC8vNDI5NDk2NzI5NiwgLy8gNDE5NDMwNCxcbiAgICAgIGFjY2VwdDogYWNjZXB0LnNwbGl0KCcsJylcbiAgICB9XG4gICAgdGhpcy5vcHRpb25zID0geyAuLi5kZWZhdWx0T3B0aW9ucyxcbiAgICAgIC4uLm9wdGlvbnNcbiAgICB9O1xuICAgIHRoaXMuaW5pdCgpO1xuICAgIGluc3RhbmNlID0gdGhpcztcbiAgICByZXR1cm4gaW5zdGFuY2U7XG4gIH1cbiAgaW5pdCgpIHtcbiAgICBhZGRfY3VzdG9tX2V2ZW50cyh0aGlzKTtcbiAgICB0aGlzLmluaXRQcm9wcygpO1xuICAgIHRoaXMub24odGhpcy5ldmVudG5hbWVzLmluaXQsIGFzeW5jIChlKSA9PiB7XG4gICAgICAvLyAgaWYgKCFlLmJpZ2ZpbGUgJiYgIWUucGFydCkge1xuICAgICAgaWYgKHRoaXMuaXNBY3RpdmUoKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgY29uc29sZS5sb2coJ3Jlc2V0IHRlcm1pbmF0ZSBldmVudCBlbmQnKVxuICAgICAgICBhd2FpdCB0aGlzLnJlc2V0KCk7XG4gICAgICAgIHRoaXMuZW1pdCh0aGlzLmV2ZW50bmFtZXMuY29tcGxldGUsIHtcbiAgICAgICAgICBuYW1lOiB0aGlzLmV2ZW50bmFtZXMucmVhZHlcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuZW5kcmVhZGRpciA9IGZhbHNlO1xuICAgICAgfSBlbHNlIGNvbnNvbGUubG9nKCcgcGFydGx5IGZpbnNoZWQgJywgZSk7XG4gICAgfSk7XG4gICAgdGhpcy5vbih0aGlzLmV2ZW50bmFtZXMuZW5kemlwLCAoZSkgPT4ge1xuXG4gICAgICBpZiAoIWUuYmlnZmlsZSAmJiB0aGlzLnppcCkge1xuICAgICAgICB0aGlzLnppcC5lbmQoKTtcbiAgICAgIH0gZWxzZSBpZiAoZS5iaWdmaWxlICYmIHRoaXMuZ3ppcHBlZCkge1xuICAgICAgICBjb25zb2xlLmxvZygnIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1nemlwcGVkIGVuZCAnLCB0aGlzLmd6aXBwZWQpO1xuICAgICAgfVxuICAgICAgY29uc3QgbWVzc2FnZSA9IHRoaXMuYnVpbGRNZXNzYWdlKGUsIHtcbiAgICAgICAgbmFtZTogdGhpcy5ldmVudG5hbWVzLnNlbmRmaWxlLFxuICAgICAgfSk7XG4gICAgICBjb25zb2xlLmxvZygnZW5kemlwJSUlJSUlJSUlJSUlJSUlJSUlJSUlJSUlJSUlJSUlJSUlJScsIG1lc3NhZ2UpXG4gICAgICB0aGlzLmVtaXQodGhpcy5ldmVudG5hbWVzLmNvbXBsZXRlLCBtZXNzYWdlKTtcbiAgICB9KTtcblxuICAgIHRoaXMub24odGhpcy5ldmVudG5hbWVzLnNlbmRmaWxlLCBhc3luYyAoZSkgPT4ge1xuICAgICAgY29uc3QgZmlsZSA9IChlLmJpZ2ZpbGUpID8gYXdhaXQgdGhpcy5nemlwcGVkLmdldEZpbGUoKTogYXdhaXQgdGhpcy5nZXRGaWxlKCk7XG4gICAgICBpZiAoZS5iaWdmaWxlKSB7XG4gICAgICAgIGNvbnN0IHBhdGggPSAoZS5wYXRoID8gZS5wYXRoIDogJycpLnJlcGxhY2UoZS5iaWdmaWxlLCAnJyk7XG4gICAgICAgIHRoaXMuc2VuZENodW5rKHBhdGgpO1xuICAgICAgfSBlbHNlIHRoaXMuc2VuZFppcEZpbGUoZmlsZSwgKGUucGF0aCA/IGUucGF0aCA6ICcnKSwgbnVsbCk7XG4gICAgfSk7XG4gICAgdGhpcy5vbih0aGlzLmV2ZW50bmFtZXMuYmlnZmlsZSwgKGUpID0+IHtcbiAgICAgIGNvbnNvbGUubG9nKCdvbnNlbmRjaHVuaycsIGUpXG4gICAgICBjb25zdCBwYXRoID0gKGUucGF0aCA/IGUucGF0aCA6ICcnKS5yZXBsYWNlKGUuYmlnZmlsZSwgJycpO1xuICAgICAgdGhpcy5zZW5kQ2h1bmsocGF0aCk7XG4gICAgfSk7XG4gICAgdGhpcy5vbih0aGlzLmV2ZW50bmFtZXMuZW5kcmVhZGRpciwgKGUpID0+IHtcbiAgICAgIHRoaXMuZW5kcmVhZGRpciA9IHRydWU7XG4gICAgICB0aGlzLmNoZWNrUHJvY2Vzc2VkKGUpO1xuICAgIH0pO1xuICAgIHRoaXMub24odGhpcy5ldmVudG5hbWVzLmNvdW50ZXIsIGFzeW5jIChlKSA9PiB7XG4gICAgICB0aGlzLmVuZGNvdW50ZXIgPSBmYWxzZTtcbiAgICAgIHRoaXMuY291bnRlcltlLm5hbWVdICs9IDE7XG4gICAgICB0aGlzLmVtaXQodGhpcy5ldmVudG5hbWVzLmNsaWVudGNvdW50ZXIsIGUpO1xuICAgICAgaWYgKGUubmFtZSA9PT0gJ3ppcCcgJiYgdGhpcy5jb3VudGVyLnNjYW4gPT09IHRoaXMuY291bnRlci56aXApIHtcbiAgICAgICAgdGhpcy5lbmRjb3VudGVyID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5jaGVja1Byb2Nlc3NlZChlKTtcbiAgICAgIH1cbiAgICAgIGlmIChlLm5hbWUgPT09ICd6aXAnICYmIHRoaXMuY2FsbGJhY2spIGF3YWl0IHRoaXMuY2FsbGJhY2soKTtcbiAgICB9KTtcblxuICB9XG5cbiAgaW5pdFByb3BzKCkge1xuICAgIHRoaXMuemlwID0gbnVsbDtcbiAgICB0aGlzLnppcG5hbWUgPSBudWxsO1xuICAgIHRoaXMuZmlsZXN0cmVhbSA9IG51bGw7XG4gICAgdGhpcy5zdHJlYW1oYW5kbGUgPSBudWxsO1xuICAgIHRoaXMuZ3ppcHBlZCA9IG51bGw7XG4gICAgdGhpcy5zaXpldG96aXAgPSAwO1xuICAgIHRoaXMucGFydCA9IDA7XG4gICAgdGhpcy5jb250aW51ZSA9IG51bGw7XG4gICAgdGhpcy5lbmRjb3VudGVyID0gZmFsc2U7XG4gICAgdGhpcy5jb3VudGVyID0ge1xuICAgICAgc2NhbjogMCxcbiAgICAgIHppcDogMCxcbiAgICAgIHJlamVjdDogMFxuICAgIH1cbiAgICB0aGlzLmhhbmRsZXJzID0gW107XG4gIH1cblxuICBhc3luYyByZXNldCgpIHtcbiAgICB0aGlzLmluaXRQcm9wcygpO1xuICAgIGF3YWl0IHRoaXMuaW5pdFN0b3JhZ2UoKTtcbiAgfVxuICBpc0FjdGl2ZSgpIHtcbiAgICByZXR1cm4gKHRoaXMuemlwICE9PSBudWxsIHx8IHRoaXMuY29udGludWUgIT09IG51bGwgfHwgdGhpcy5nemlwcGVkICE9PSBudWxsIHx8IHRoaXMuZW5kcmVhZGRpciAhPT0gdHJ1ZSk7XG4gIH1cbiAgYXN5bmMgaW5pdFppcCgpIHtcbiAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICB0aGlzLnBvcyA9IDA7XG4gICAgdGhpcy5zaXpldG96aXAgPSAwO1xuICAgIGNvbnNvbGUubG9nKCc9PT09PT09PT09PT09PT09PT1uZXd6aXAnKTtcbiAgICB0aGlzLnppcCA9IG5ldyBaaXAoKGVycm9yLCBjaHVuaywgZmluYWwpID0+IHtcbiAgICAgIGlmIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmxvZygnZXJyb3InLCBlcnJvcik7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNlbGYuc3RyZWFtaGFuZGxlLndyaXRlKGNodW5rLCB7XG4gICAgICAgICAgYXQ6IHNlbGYucG9zXG4gICAgICAgIH0pO1xuICAgICAgICBzZWxmLnBvcyArPSBjaHVuay5sZW5ndGg7XG4gICAgICAgIGlmIChmaW5hbCkge1xuICAgICAgICAgIHNlbGYuc3RyZWFtaGFuZGxlLmNsb3NlKCk7XG4gICAgICAgICAgY29uc29sZS5sb2coJ2ZpbmFsLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqLScsIHNlbGYucG9zKTtcblxuICAgICAgICB9XG5cbiAgICAgIH1cbiAgICB9KTtcbiAgICAvLyBoYWNrIGZvciBtZW1vcnkgdXNhZ2VcbiAgICB0aGlzLnppcE9uRGF0YSgpO1xuXG4gICAgaWYgKHRoaXMuY29udGludWUpIGF3YWl0IHRoaXMuY29udGludWUoKTtcbiAgfVxuICBjaGVja1Byb2Nlc3NlZChlKSB7XG4gICAgaWYgKHRoaXMuZW5kcmVhZGRpciA9PT0gdHJ1ZSAmJiB0aGlzLmVuZGNvdW50ZXIgPT09IHRydWUpIHtcbiAgICAgIGNvbnN0IG1lc3NhZ2UgPSB0aGlzLmJ1aWxkTWVzc2FnZShlLCB7XG4gICAgICAgIG5hbWU6IHRoaXMuZXZlbnRuYW1lcy5lbmR6aXBcbiAgICAgIH0pO1xuICAgICAgdGhpcy5lbWl0KHRoaXMuZXZlbnRuYW1lcy5jb21wbGV0ZSwgbWVzc2FnZSk7XG4gICAgfVxuICB9XG4gIHppcE9uRGF0YSh6aXAgPSBudWxsKSB7XG4gICAgemlwID0gKHppcCA9PT0gbnVsbCkgPyB0aGlzLnppcCA6IHppcDtcbiAgICBjb25zdCBvbmRhdGEgPSB6aXAub25kYXRhO1xuICAgIHppcC5vbmRhdGEgPSAoZXJyb3IsIGRhdGEsIGZpbmFsKSA9PiB7XG4gICAgICBvbmRhdGEoZXJyb3IsIGRhdGEsIGZpbmFsKTtcbiAgICAgIGlmIChmaW5hbCkge1xuICAgICAgICB6aXAuZCA9IG51bGw7XG4gICAgICAgIHppcC51LmF0KC0xKS5kID0gbnVsbDsgLy8gT2JqZWN0IGNyZWF0ZWQgaW4gYHppcC5hZGQoKWBcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBidWlsZE1lc3NhZ2UoZSwgbWVzc2FnZSA9IHt9KSB7XG4gICAgaWYgKGUuaGFzT3duUHJvcGVydHkoXCJwYXJ0XCIpKSB7XG4gICAgICBtZXNzYWdlLnBhcnQgPSBlLnBhcnQ7XG4gICAgfSBlbHNlIHRoaXMucGFydCA9IDA7XG4gICAgaWYgKGUuaGFzT3duUHJvcGVydHkoXCJiaWdmaWxlXCIpKSBtZXNzYWdlLmJpZ2ZpbGUgPSBlLmJpZ2ZpbGU7XG4gICAgaWYgKGUuaGFzT3duUHJvcGVydHkoXCJwYXRoXCIpKSBtZXNzYWdlLnBhdGggPSBlLnBhdGg7XG4gICAgcmV0dXJuIG1lc3NhZ2U7XG4gIH1cbiAgYXN5bmMgcXVvdGFFc3RpbWF0ZSgpIHtcbiAgICBpZiAobmF2aWdhdG9yICYmIG5hdmlnYXRvci5zdG9yYWdlICYmIG5hdmlnYXRvci5zdG9yYWdlLmVzdGltYXRlKSB7XG4gICAgICBuYXZpZ2F0b3Iuc3RvcmFnZS5lc3RpbWF0ZSgpLnRoZW4oKHF1b3RhKSA9PiB7XG4gICAgICAgIGNvbnN0IHBlcmNlbnRhZ2VVc2VkID0gKChxdW90YS51c2FnZSAvIHF1b3RhLnF1b3RhKSAqIDEwMCkudG9GaXhlZCgyKTtcbiAgICAgICAgY29uc3QgcmVtYWluaW5nID0gZm9ybWF0X2J5dGVzKHF1b3RhLnF1b3RhIC0gcXVvdGEudXNhZ2UpO1xuICAgICAgICB0aGlzLmVtaXQodGhpcy5ldmVudG5hbWVzLm1lc3NhZ2UsIHtcbiAgICAgICAgICBpZDogXCJxdW90YVwiLFxuICAgICAgICAgIG5hbWU6IFwiY29uc29sZVwiLFxuICAgICAgICAgIG1lc3NhZ2U6IFwieW91J3ZlIHVzZWQgXCIgKyBwZXJjZW50YWdlVXNlZCArIFwiJSBvZiB0aGUgYXZhaWxhYmxlIHN0b3JhZ2UgKFwiICsgcmVtYWluaW5nICsgXCIpLlwiLFxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIGFzeW5jIGluaXRTdG9yYWdlKCkge1xuICAgIGlmIChuYXZpZ2F0b3IgJiYgbmF2aWdhdG9yLnN0b3JhZ2UgJiYgbmF2aWdhdG9yLnN0b3JhZ2UuZXN0aW1hdGUpIHtcbiAgICAgIGF3YWl0IHRoaXMuY2xlYW5TdG9yYWdlKCk7XG4gICAgICB0aGlzLnF1b3RhRXN0aW1hdGUoKTtcbiAgICB9IGVsc2UgdGhpcy5lbWl0KHRoaXMuZXZlbnRuYW1lcy5tZXNzYWdlLCB7XG4gICAgICBuYW1lOiBcImVycm9yXCIsXG4gICAgICBtZXNzYWdlOiBcIm5vIG5hdmlnYXRvciBzdG9yYWdlXCJcbiAgICB9KTtcbiAgfVxuICBhc3luYyBjcmVhdGVMb2NhbFN0cmVhbShuYW1lLCBhY2NlcHQgPSB7XG4gICAgJ2FwcGxpY2F0aW9uL3ppcCc6IFsnLnppcCddLFxuICB9KSB7XG4gICAgY29uc3Qgcm9vdCA9IGF3YWl0IG5hdmlnYXRvci5zdG9yYWdlLmdldERpcmVjdG9yeSgpO1xuICAgIGNvbnN0IG9wdHMgPSB7XG4gICAgICB0eXBlczogW3tcbiAgICAgICAgZGVzY3JpcHRpb246ICdUZW1wIGZpbGUnLFxuICAgICAgICBhY2NlcHQ6IGFjY2VwdCxcbiAgICAgIH0sIF0sXG4gICAgICBjcmVhdGU6IHRydWVcbiAgICB9O1xuICAgIGNvbnN0IGZpbGVzdHJlYW0gPSBhd2FpdCByb290LmdldEZpbGVIYW5kbGUobmFtZSwgb3B0cyk7XG4gICAgY29uc3Qgc3RyZWFtaGFuZGxlID0gYXdhaXQgZmlsZXN0cmVhbS5jcmVhdGVXcml0YWJsZSgpO1xuICAgIHJldHVybiB7XG4gICAgICBmaWxlc3RyZWFtLFxuICAgICAgc3RyZWFtaGFuZGxlXG4gICAgfTtcbiAgfVxuICBhc3luYyBzY2FuQ29tbW9uKHppcG5hbWUsIG9wdGlvbnMgPSB7fSkge1xuICAgIHRoaXMuZW5kcmVhZGRpciA9IGZhbHNlO1xuICAgIGlmICh0aGlzLnppcCA9PT0gbnVsbCkge1xuICAgICAgY29uc29sZS5sb2coJ3NjYW5jb21tbW9uIHppcG5hbWUnLCB6aXBuYW1lKVxuICAgICAgemlwbmFtZSA9IHppcG5hbWUuc3BsaXQoZGlyc2VwYXJhdG9yKVswXTtcbiAgICAgIHppcG5hbWUgPSAoemlwbmFtZS50cmltKCkgPT09IGBgKSA/ICd0ZW1wJyA6IHppcG5hbWU7XG4gICAgICBjb25zdCB0eXBlID0gKG9wdGlvbnMgJiYgb3B0aW9ucy50eXBlKSA/IG9wdGlvbnMudHlwZSA6ICcuemlwJztcbiAgICAgIHRoaXMuemlwbmFtZSA9ICgob3B0aW9ucy56aXBuYW1lKSA/IG9wdGlvbnMuemlwbmFtZSA6IHppcG5hbWUpICsgdHlwZTsgLy9cbiAgICAgIGNvbnN0IHppcGluc3RvcmFnZSA9IGF3YWl0IHRoaXMuc2VhcmNoU3RvcmFnZSh0aGlzLnppcG5hbWUpO1xuICAgICAgaWYgKHppcGluc3RvcmFnZSkgdGhpcy56aXBuYW1lID0gJzFfJyArIHRoaXMuemlwbmFtZTtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgZmlsZXN0cmVhbSxcbiAgICAgICAgc3RyZWFtaGFuZGxlXG4gICAgICB9ID0gYXdhaXQgdGhpcy5jcmVhdGVMb2NhbFN0cmVhbSh0aGlzLnppcG5hbWUpO1xuICAgICAgdGhpcy5maWxlc3RyZWFtID0gZmlsZXN0cmVhbTtcbiAgICAgIHRoaXMuc3RyZWFtaGFuZGxlID0gc3RyZWFtaGFuZGxlO1xuICAgICAgbGV0IHNpemUgPSAwO1xuICAgICAgdGhpcy5wYXJ0ID0gMDtcbiAgICAgIGF3YWl0IHRoaXMuaW5pdFppcCgpO1xuICAgICAgaWYgKCF0aGlzLmpzU2NhbkRpcikge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgSnNTY2FuRGlyXG4gICAgICAgIH0gPSBhd2FpdCBpbXBvcnQoJy4uL2ZpbGVzL2pzLXNjYW5kaXIuanMnKTtcbiAgICAgICAgdGhpcy5qc1NjYW5EaXIgPSBuZXcgSnNTY2FuRGlyKCk7XG4gICAgICB9XG4gICAgICB0aGlzLmpzU2NhbkRpci5wcm9jZXNzRmlsZSA9IGFzeW5jIChlbnRyeSwgY2FsbGJhY2spID0+IHtcbiAgICAgICAgaWYgKHRoaXMuYWNjZXB0RmlsZShlbnRyeSkpIHtcbiAgICAgICAgICB0aGlzLmNhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgICAgICAgYXdhaXQgdGhpcy5wcm9jZXNzRmlsZShlbnRyeSk7XG4gICAgICAgIH0gZWxzZSB0aGlzLnJlamVjdEZpbGUoZW50cnksIGNhbGxiYWNrKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBhc3luYyBzY2FuQnJvd3NlKHBpY2ssIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IGVudHJpZXMgPSAocGljayBpbnN0YW5jZW9mIEZpbGVMaXN0KSA/IEFycmF5LmZyb20ocGljaykgOiAocGljay5raW5kID09PSBcImRpcmVjdG9yeVwiKSA/IGF3YWl0IEFycmF5LmZyb21Bc3luYyhwaWNrLnZhbHVlcygpKTogKEFycmF5LmlzQXJyYXkocGljaykpID8gcGljayA6IFtwaWNrXTtcbiAgICBjb25zdCBuYW1lID0gZW50cmllc1swXS5uYW1lO1xuICAgIGxldCByZWxwYXRoID0gKHBpY2sgaW5zdGFuY2VvZiBGaWxlTGlzdCkgPyBlbnRyaWVzWzBdLndlYmtpdFJlbGF0aXZlUGF0aCA6IG51bGw7XG4gICAgcmVscGF0aCA9IChyZWxwYXRoKSA/IHJlbHBhdGguc3BsaXQoZGlyc2VwYXJhdG9yKSA6IFtgYF07XG4gICAgaWYgKHJlbHBhdGgubGVuZ3RoKSByZWxwYXRoLnBvcCgpO1xuICAgIHJlbHBhdGggPSByZWxwYXRoLmpvaW4oZGlyc2VwYXJhdG9yKVxuICAgIGNvbnN0IHBhdGggPSAocGljayBpbnN0YW5jZW9mIEZpbGVMaXN0KSA/IHJlbHBhdGggOiAocGljay5raW5kID09PSBcImRpcmVjdG9yeVwiKSA/IHBpY2submFtZSA6IGBgO1xuICAgIGF3YWl0IHRoaXMuc2NhbkNvbW1vbihwYXRoLCBvcHRpb25zKTtcbiAgICBhd2FpdCB0aGlzLmpzU2NhbkRpci5wcm9jZXNzRW50cmllcyhlbnRyaWVzLCBwYXRoLCAoKSA9PiB7XG4gICAgICB0aGlzLmRpckNvbXBsZXRlKCk7XG4gICAgfSk7XG4gIH1cblxuICBhc3luYyBzY2FuSGFuZGxlKGRyb3BwZWQsIG9wdGlvbnMgPSB7fSkge1xuICAgIGF3YWl0IHRoaXMuc2NhbkNvbW1vbihkcm9wcGVkLm5hbWUsIG9wdGlvbnMpO1xuICAgIGlmIChkcm9wcGVkLmlzRGlyZWN0b3J5ID09PSB0cnVlKSB7XG4gICAgICBhd2FpdCB0aGlzLmpzU2NhbkRpci5yZWFkRGlyZWN0b3J5KGRyb3BwZWQsICgpID0+IHtcbiAgICAgICAgdGhpcy5kaXJDb21wbGV0ZSgpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChkcm9wcGVkLmlzRmlsZSA9PT0gdHJ1ZSkge1xuICAgICAgYXdhaXQgdGhpcy5qc1NjYW5EaXIucHJvY2Vzc0ZpbGUoZHJvcHBlZCwgKCkgPT4ge1xuICAgICAgICB0aGlzLmRpckNvbXBsZXRlKCk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICBkaXJDb21wbGV0ZSgpIHtcbiAgICB0aGlzLmVtaXQodGhpcy5ldmVudG5hbWVzLmVuZHJlYWRkaXIsIHtcbiAgICAgIG5hbWU6IHRoaXMuZXZlbnRuYW1lcy5lbmRyZWFkZGlyXG4gICAgfSk7XG4gIH1cbiAgYWRkSGFuZGxlcihoYW5kbGVyKSB7XG4gICAgdGhpcy5oYW5kbGVycy5wdXNoKGhhbmRsZXIpO1xuICB9XG5cbiAgYXN5bmMgZXhlY0hhbmRsZXIoKSB7XG4gICAgLy8gc2VyaWVcbiAgICBpZiAodGhpcy5oYW5kbGVycy5sZW5ndGggPiAwKSB7XG4gICAgICBjb25zdCBoYW5kbGVyID0gdGhpcy5oYW5kbGVycy5zaGlmdCgpO1xuICAgICAgY29uc29sZS5sb2coJ2hhbmRsZXInLCBoYW5kbGVyKVxuICAgICAgYXdhaXQgaGFuZGxlcigpO1xuICAgIH1cbiAgICByZXR1cm47XG4gIH1cbiAgYXN5bmMgZ3ppcEJpZ0ZpbGUoZmlsZSwgZmlsZXBhdGgpIHtcbiAgICBjb25zb2xlLmxvZygnZ3ppcGJpZ2ZpbGVwYXRoJywgZmlsZXBhdGgpXG4gICAgaWYgKHRoaXMuZ3ppcHBlZCAhPT0gbnVsbCkge1xuICAgICAgYXdhaXQgdGhpcy5hZGRIYW5kbGVyKGFzeW5jICgpID0+IHtcbiAgICAgICAgYXdhaXQgdGhpcy5nemlwQmlnRmlsZShmaWxlLCBmaWxlcGF0aCk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5kdCA9IERhdGUubm93KCk7XG4gICAgZmlsZXBhdGggPSAoZmlsZXBhdGguaW5kZXhPZihkaXJzZXBhcmF0b3IpID09PSAwKSA/IGZpbGVwYXRoLnN1YnN0cigxKSA6IGZpbGVwYXRoO1xuICAgIC8qZmlsZXBhdGggPSBmaWxlcGF0aC5zcGxpdChkaXJzZXBhcmF0b3IpO1xuICAgIGZpbGVwYXRoLnBvcCgpO1xuICAgIGZpbGVwYXRoID0gZmlsZXBhdGguam9pbihkaXJzZXBhcmF0b3IpOyovXG4gICAgY29uc3QgZXh0ID0gZmlsZS5uYW1lLnNsaWNlKGZpbGUubmFtZS5sYXN0SW5kZXhPZignLicpICsgMSk7XG5cbiAgICBpZiAoYWxyZWFkeV9jb21wcmVzc2VkLmhhcyhleHQpKSB7XG4gICAgICB0aGlzLmd6aXBwZWQgPSBmaWxlO1xuICAgICAgdGhpcy5lbWl0KHRoaXMuZXZlbnRuYW1lcy5jb3VudGVyLCB7XG4gICAgICAgIG5hbWU6ICd6aXAnLFxuICAgICAgICBwYXRoOiBmaWxlcGF0aCxcbiAgICAgICAgc2l6ZTogZmlsZS5zaXplXG4gICAgICB9KTtcbiAgICAgIHRoaXMuZW1pdCh0aGlzLmV2ZW50bmFtZXMuY29tcGxldGUsIHtcbiAgICAgICAgbmFtZTogdGhpcy5ldmVudG5hbWVzLmJpZ2ZpbGUsXG4gICAgICAgIGJpZ2ZpbGU6IGZpbGUubmFtZSxcbiAgICAgICAgcGF0aDogZmlsZXBhdGgsXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IHppcG5hbWUgPSBmaWxlLm5hbWUgKyAnLmd6JztcbiAgICAgIHRoaXMuZW1pdCh0aGlzLmV2ZW50bmFtZXMuY29tcGxldGUsIHtcbiAgICAgICAgbmFtZTogdGhpcy5ldmVudG5hbWVzLmd6aXAsXG4gICAgICAgIGJpZ2ZpbGU6IGZpbGUubmFtZSxcbiAgICAgICAgcGF0aDogZmlsZXBhdGgsXG4gICAgICAgIHNpemU6IGZpbGUuc2l6ZVxuICAgICAgfSk7XG4gICAgICBjb25zb2xlLmxvZygnIGd6aXBwIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLycsIGZpbGVwYXRoKTtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgZmlsZXN0cmVhbSxcbiAgICAgICAgc3RyZWFtaGFuZGxlXG4gICAgICB9ID0gYXdhaXQgdGhpcy5jcmVhdGVMb2NhbFN0cmVhbSh6aXBuYW1lLCB7XG4gICAgICAgICdhcHBsaWNhdGlvbi9nemlwJzogWycuZ3onXSxcbiAgICAgIH0pO1xuICAgICAgbGV0IHBvcyA9IDA7XG4gICAgICBjb25zdCBzZWxmID0gdGhpcztcblxuICAgICAgY29uc3QgZ3ppcHBlZCA9IG5ldyBBc3luY0d6aXAoe1xuICAgICAgICBsZXZlbDogNixcbiAgICAgICAgZmlsZW5hbWU6IGZpbGVwYXRoXG4gICAgICB9KTtcbiAgICAgIGd6aXBwZWQub25kYXRhID0gKGVyciwgZGF0YSwgZmluYWwpID0+IHtcbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgIGNvbnNvbGUubG9nKCdnemlwIGVycicsIGVycik7XG4gICAgICAgICAgdGhpcy5vbkVycm9yKHRoaXMuZXZlbnRuYW1lcy5lcnJvcmZpbGUsIHtcbiAgICAgICAgICAgIGJpZ2ZpbGU6IGZpbGUubmFtZSxcbiAgICAgICAgICAgIHBhdGg6IGZpbGVwYXRoLFxuICAgICAgICAgICAgc2l6ZTogZmlsZS5zaXplXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3RyZWFtaGFuZGxlLndyaXRlKGRhdGEsIHtcbiAgICAgICAgICAgIGF0OiBwb3NcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBwb3MgKz0gZGF0YS5sZW5ndGg7XG5cbiAgICAgICAgICBpZiAoZmluYWwpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdmaW5hbCBCSUdGSUxFJSUlJSUlJSUlJSUlJSUlJSUlJSUnICsgc2VsZi5ldmVudG5hbWVzLmJpZ2ZpbGUsIGZpbGVwYXRoKVxuXG4gICAgICAgICAgICBjb25zb2xlLmxvZygndGltZXRvZ3p6aXAnLCAoRGF0ZS5ub3coKSAtIHNlbGYuZHQpIC8gMTAwMCk7XG5cbiAgICAgICAgICAgIHN0cmVhbWhhbmRsZS5jbG9zZSgpO1xuICAgICAgICAgICAgc2VsZi5nemlwcGVkID0gZmlsZXN0cmVhbTtcbiAgICAgICAgICAgIHNlbGYuZW1pdChzZWxmLmV2ZW50bmFtZXMuY291bnRlciwge1xuICAgICAgICAgICAgICBuYW1lOiAnemlwJyxcbiAgICAgICAgICAgICAgcGF0aDogZmlsZXBhdGgsXG4gICAgICAgICAgICAgIHNpemU6IGZpbGUuc2l6ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBzZWxmLmVtaXQoc2VsZi5ldmVudG5hbWVzLmNvbXBsZXRlLCB7XG4gICAgICAgICAgICAgIG5hbWU6IHNlbGYuZXZlbnRuYW1lcy5iaWdmaWxlLFxuICAgICAgICAgICAgICBiaWdmaWxlOiBmaWxlLm5hbWUsXG4gICAgICAgICAgICAgIHBhdGg6IGZpbGVwYXRoXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBjb25zdCBjb3VudCA9IGZhbHNlO1xuICAgICAgYXdhaXQgdGhpcy5yZWFkRmlsZShmaWxlLCBmaWxlcGF0aCwgZ3ppcHBlZCwgY291bnQpO1xuICAgIH1cblxuXG4gIH1cbiAgYXN5bmMgcGFydFppcCgpIHtcbiAgICB0aGlzLnBhcnQgKz0gMTtcbiAgICB0aGlzLmVtaXQodGhpcy5ldmVudG5hbWVzLmNvbXBsZXRlLCB7XG4gICAgICBuYW1lOiB0aGlzLmV2ZW50bmFtZXMuZW5kemlwLFxuICAgICAgcGFydDogdGhpcy5wYXJ0XG4gICAgfSk7XG4gIH1cbiAgYXN5bmMgcmVhZEZpbGUoZmlsZSwgZmlsZXBhdGgsIHppcHBlZHN0cmVhbSwgY291bnQgPSB0cnVlKSB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgY29uc3QgcmVhZGVyID0gZmlsZS5zdHJlYW0oKS5nZXRSZWFkZXIoKTtcbiAgICBsZXQgcGF1c2UgPSBmYWxzZTtcbiAgICAvKiAgb25CYWNrcHJlc3N1cmUoemlwcGVkc3RyZWFtLCB0aGlzLnN0cmVhbWhhbmRsZSwgc2hvdWxkX2FwcGx5X2JhY2twcmVzc3VyZSA9PiB7XG4gICAgICAgIGlmIChzaG91bGRfYXBwbHlfYmFja3ByZXNzdXJlKSBwYXVzZSA9IHRydWU7XG4gICAgICAgIGVsc2UgaWYgKHBhdXNlKSBwYXVzZSA9IGZhbHNlO1xuICAgICAgfSk7Ki9cbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgY29uc3Qge1xuICAgICAgICBkb25lLFxuICAgICAgICB2YWx1ZVxuICAgICAgfSA9IGF3YWl0IHJlYWRlci5yZWFkKCk7XG4gICAgICBpZiAoZG9uZSkge1xuICAgICAgICB6aXBwZWRzdHJlYW0ucHVzaChuZXcgVWludDhBcnJheSgwKSwgdHJ1ZSk7XG4gICAgICAgIGlmIChjb3VudCA9PT0gdHJ1ZSkgc2VsZi5lbWl0KHNlbGYuZXZlbnRuYW1lcy5jb3VudGVyLCB7XG4gICAgICAgICAgbmFtZTogJ3ppcCcsXG4gICAgICAgICAgcGF0aDogZmlsZXBhdGgsXG4gICAgICAgICAgc2l6ZTogKHppcHBlZHN0cmVhbS5zaXplKSA/IHppcHBlZHN0cmVhbS5zaXplIDogZmlsZS5zaXplXG4gICAgICAgIH0pO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIHppcHBlZHN0cmVhbS5wdXNoKHZhbHVlKTtcbiAgICB9XG4gIH1cblxuICBhc3luYyB6aXBTdHJlYW0oZmlsZSwgZmlsZXBhdGgpIHtcbiAgICBjb25zdCBleHQgPSBmaWxlcGF0aC5zbGljZShmaWxlcGF0aC5sYXN0SW5kZXhPZignLicpICsgMSk7XG4gICAgY29uc3QgaXNjb21wcmVzc2VkID0gYWxyZWFkeV9jb21wcmVzc2VkLmhhcyhleHQpO1xuICAgIGNvbnN0IHppcHBlZHN0cmVhbSA9IChpc2NvbXByZXNzZWQpID8gbmV3IFppcFBhc3NUaHJvdWdoKGZpbGVwYXRoKSA6IGZpbGUuc2l6ZSA+IHRoaXMub3B0aW9ucy5sYXJnZWZpbGUgP1xuICAgICAgbmV3IEFzeW5jWmlwRGVmbGF0ZShmaWxlcGF0aCwge1xuICAgICAgICBsZXZlbDogNixcbiAgICAgIH0pIDogbmV3IFppcERlZmxhdGUoZmlsZXBhdGgsIHtcbiAgICAgICAgbGV2ZWw6IDZcbiAgICAgIH0pO1xuICAgIHRoaXMuemlwLmFkZCh6aXBwZWRzdHJlYW0pO1xuICAgIGF3YWl0IHRoaXMucmVhZEZpbGUoZmlsZSwgZmlsZXBhdGgsIHppcHBlZHN0cmVhbSk7XG4gIH1cblxuICBhc3luYyBhZGRGaWxlVG9aaXBTdHJlYW0oZmlsZSwgZmlsZXBhdGgsIGNvdW50ID0gdHJ1ZSkge1xuICAgIGlmIChjb3VudCA9PT0gdHJ1ZSkgdGhpcy5lbWl0KHRoaXMuZXZlbnRuYW1lcy5jb3VudGVyLCB7XG4gICAgICBuYW1lOiAnc2NhbicsXG4gICAgICBwYXRoOiBmaWxlcGF0aCxcbiAgICAgIHNpemU6IGZpbGUuc2l6ZVxuICAgIH0pO1xuICAgIHRoaXMuY29udGludWUgPSBudWxsO1xuICAgIC8vIGNoZWNrIGZpbGUgc2l6ZSA+IG1heCBwb3N0IHNpemVcbiAgICBpZiAoZmlsZS5zaXplID49IE1BWFNJWkUpIHtcbiAgICAgIHRoaXMuZ3ppcEJpZ0ZpbGUoZmlsZSwgZmlsZXBhdGgpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBjaGVjayB6aXAgZmlsZSBzaXplID4gdG90YWwgemlwIHNpemVcbiAgICAgIHRoaXMuc2l6ZXRvemlwICs9IGZpbGUuc2l6ZTtcbiAgICAgIGlmICh0aGlzLnNpemV0b3ppcCA+PSBNQVhTSVpFKSB7XG4gICAgICAgIHRoaXMuY29udGludWUgPSBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgYXdhaXQgdGhpcy56aXBTdHJlYW0oZmlsZSwgZmlsZXBhdGgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucGFydFppcCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYXdhaXQgdGhpcy56aXBTdHJlYW0oZmlsZSwgZmlsZXBhdGgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGFjY2VwdEZpbGUoZW50cnkpIHtcbiAgICBjb25zdCBmaWxlcGF0aCA9IGVudHJ5Lm5hbWU7XG4gICAgY29uc3QgZXh0ID0gZmlsZXBhdGguc2xpY2UoZmlsZXBhdGgubGFzdEluZGV4T2YoJy4nKSArIDEpO1xuICAgIHJldHVybiBhY2NlcHQuaW5jbHVkZXMoZXh0KTtcbiAgfVxuXG4gIHJlamVjdEZpbGUoZmlsZSwgY2FsbGJhY2sgPSBudWxsKSB7XG4gICAgY29uc3QgcGF0aCA9IChmaWxlLmZ1bGxQYXRoKSA/IGZpbGUuZnVsbFBhdGggOiBmaWxlLndlYmtpdFJlbGF0aXZlUGF0aDtcbiAgICB0aGlzLmNvdW50ZXIucmVqZWN0ICs9IDE7XG4gICAgdGhpcy5lbWl0KHRoaXMuZXZlbnRuYW1lcy5yZWplY3QsIHtcbiAgICAgIG5hbWU6IHRoaXMuZXZlbnRuYW1lcy5yZWplY3QsXG4gICAgICBwYXRoOiBwYXRoLFxuICAgIH0pO1xuICAgIGlmIChjYWxsYmFjayAhPT0gbnVsbCkgY2FsbGJhY2soKTtcbiAgfVxuICBhc3luYyBwcm9jZXNzRmlsZShlbnRyeSkge1xuICAgIGNvbnN0IHBhdGggPSAoZW50cnkuZnVsbFBhdGgpID8gZW50cnkuZnVsbFBhdGggOiBlbnRyeS53ZWJraXRSZWxhdGl2ZVBhdGg7XG4gICAgZW50cnkuZmlsZShhc3luYyBmaWxlID0+IHtcbiAgICAgIGF3YWl0IHRoaXMuYWRkRmlsZVRvWmlwU3RyZWFtKGZpbGUsIHBhdGgpO1xuICAgIH0pO1xuICB9XG5cbiAgb25FcnJvcihhY3Rpb24sIG1lc3NhZ2UgPSBudWxsKSB7XG5cbiAgICBtZXNzYWdlID0gKG1lc3NhZ2UpID8gbWVzc2FnZSA6IHt9O1xuICAgIHN3aXRjaCAoYWN0aW9uKSB7XG4gICAgICBjYXNlIHRoaXMuZXZlbnRuYW1lcy5pbml0OlxuICAgICAgICBtZXNzYWdlLm5hbWUgPSB0aGlzLmV2ZW50bmFtZXMuaW5pdDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIHRoaXMuZXZlbnRuYW1lcy5lcnJvcmZpbGU6XG4gICAgICAgIGNvbnNvbGUubG9nKCdlcnJvcmZpbGUnLCBtZXNzYWdlKTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIG1lc3NhZ2UubmFtZSA9IHRoaXMuZXZlbnRuYW1lcy5mb2xsb3c7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICB0aGlzLmVtaXQodGhpcy5ldmVudG5hbWVzLmVycm9yLCBtZXNzYWdlKTtcbiAgfVxuICBhc3luYyBzZWFyY2hTdG9yYWdlKHNlYXJjaCkge1xuICAgIGNvbnN0IGVudHJ5ID0gYXdhaXQgbmF2aWdhdG9yLnN0b3JhZ2UuZ2V0RGlyZWN0b3J5KCk7XG4gICAgZm9yIGF3YWl0IChjb25zdCBba2V5LCB2YWx1ZV0gb2YgZW50cnkuZW50cmllcygpKSB7XG4gICAgICBpZiAoc2VhcmNoID09PSBrZXkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgYXN5bmMgY2xlYW5TdG9yYWdlKGVudHJ5ID0gbnVsbCkge1xuICAgIGVudHJ5ID0gKGVudHJ5KSA/IGVudHJ5IDogYXdhaXQgbmF2aWdhdG9yLnN0b3JhZ2UuZ2V0RGlyZWN0b3J5KCk7XG4gICAgZm9yIGF3YWl0IChjb25zdCBba2V5LCB2YWx1ZV0gb2YgZW50cnkuZW50cmllcygpKSB7XG4gICAgICB0cnkge1xuICAgICAgICBhd2FpdCBlbnRyeS5yZW1vdmVFbnRyeShrZXkpO1xuICAgICAgICBjb25zb2xlLmxvZygnIFN1Y2Nlc3MgcmVtb3ZlIHN0b3JhZ2UgJywga2V5KTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCcgZXJyb3IgcmVtb3ZlIHN0b3JhZ2UgJyArIGtleSwgZXJyb3IpO1xuICAgICAgfVxuICAgIH1cblxuICB9XG5cbiAgYXN5bmMgZW5kRmV0Y2gobWVzc2FnZSwgY2xlYW4gPSBmYWxzZSkge1xuICAgIG1lc3NhZ2UubmFtZSA9IHRoaXMuZXZlbnRuYW1lcy50ZXJtaW5hdGU7XG4gICAgaWYgKHRoaXMuY29udGludWUpIHtcbiAgICAgIHRoaXMuc3RyZWFtaGFuZGxlID0gYXdhaXQgdGhpcy5maWxlc3RyZWFtLmNyZWF0ZVdyaXRhYmxlKCk7XG4gICAgICBtZXNzYWdlLm5hbWUgPSB0aGlzLmV2ZW50bmFtZXMuZm9sbG93O1xuICAgICAgdGhpcy5lbWl0KHRoaXMuZXZlbnRuYW1lcy5mb2xsb3csIG1lc3NhZ2UpO1xuICAgICAgYXdhaXQgdGhpcy5pbml0WmlwKCk7XG4gICAgICByZXR1cm47XG4gICAgfSBlbHNlIGlmIChtZXNzYWdlLmhhc093blByb3BlcnR5KFwiYmlnZmlsZVwiKSAmJiBtZXNzYWdlLmJpZ2ZpbGUgIT09IGZhbHNlKSB7XG4gICAgICB0aGlzLmd6aXBwZWQgPSBudWxsO1xuXG4gICAgICBpZiAodGhpcy5oYW5kbGVycy5sZW5ndGggPiAwKSB7XG4gICAgICAgIG1lc3NhZ2UubmFtZSA9IHRoaXMuZXZlbnRuYW1lcy5mb2xsb3c7XG4gICAgICAgIHRoaXMuZW1pdCh0aGlzLmV2ZW50bmFtZXMuZm9sbG93LCBtZXNzYWdlKTtcbiAgICAgICAgY29uc29sZS5sb2coJyBoYW5kbGVycyB0byBkbycsIG1lc3NhZ2UpO1xuICAgICAgICBpZiAodGhpcy5oYW5kbGVycy5sZW5ndGggPiAwKSBhd2FpdCB0aGlzLmV4ZWNIYW5kbGVyKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9IGVsc2UgdGhpcy56aXAgPSBudWxsO1xuICAgIHRoaXMuZW1pdCh0aGlzLmV2ZW50bmFtZXMuY29tcGxldGUsIG1lc3NhZ2UpO1xuICB9XG5cbiAgYXN5bmMgc2VuZENodW5rKHBhdGgsIHN0YXJ0ID0gMCwgY2h1bmtudW0gPSAwLCBjaHVua3NpemUgPSBNQVhTSVpFKSB7XG4gICAgY29uc29sZS5sb2coJ3NlbmQgY2h1bmsgJywgdGhpcy5nemlwcGVkKVxuICAgIGNvbnN0IGZpbGUgPSBhd2FpdCB0aGlzLmd6aXBwZWQuZ2V0RmlsZSgpO1xuICAgIGNvbnN0IGVuZCA9IE1hdGgubWluKHN0YXJ0ICsgY2h1bmtzaXplLCBmaWxlLnNpemUpO1xuICAgIGlmIChlbmQgPT09IGZpbGUuc2l6ZSkge1xuICAgICAgdGhpcy5zZW5kWmlwRmlsZShmaWxlLCBwYXRoLCBudWxsLCB0cnVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgcGFydGZpbGUgPSBmaWxlLnNsaWNlKHN0YXJ0LCBlbmQpO1xuICAgICAgcGFydGZpbGUubmFtZSA9IGNodW5rbnVtICsgJ18nICsgZmlsZS5uYW1lO1xuICAgICAgdGhpcy5zZW5kWmlwZmlsZShwYXJ0ZmlsZSwgcGF0aCwgKCkgPT4ge1xuICAgICAgICBzdGFydCArPSBlbmQ7XG4gICAgICAgIGNodW5rbnVtKys7XG5cbiAgICAgICAgaWYgKHN0YXJ0IDw9IGZpbGUuc2l6ZSkgdGhpcy5zZW5kQ2h1bmsocGF0aCwgc3RhcnQsIGNodW5rbnVtLCBjaHVua3NpemUpO1xuICAgICAgfSwgdHJ1ZSlcbiAgICB9XG4gICAgcmV0dXJuIGNodW5rbnVtO1xuICB9XG4gIGFzeW5jIGdldEZpbGUoZmlsZXN0cmVhbSA9IG51bGwpIHtcbiAgICBmaWxlc3RyZWFtID0gKGZpbGVzdHJlYW0gPT09IG51bGwpID8gdGhpcy5maWxlc3RyZWFtIDogZmlsZXN0cmVhbTtcbiAgICBjb25zdCBmaWxlID0gYXdhaXQgZmlsZXN0cmVhbS5nZXRGaWxlKCk7XG4gICAgcmV0dXJuIGZpbGU7XG4gIH1cbiAgYXN5bmMgc2VuZFppcEZpbGUoZmlsZSwgcGF0aCwgY2FsbGJhY2tjaHVuayA9IG51bGwsIGJpZ2ZpbGUgPSBmYWxzZSkge1xuICAgIGNvbnN0IG1lc3NhZ2UgPSB7XG4gICAgICBuYW1lOiB0aGlzLmV2ZW50bmFtZXMucGVuZGluZyxcbiAgICAgIHBhdGg6IHBhdGhcbiAgICB9XG4gICAgaWYgKGJpZ2ZpbGUpIG1lc3NhZ2UuYmlnZmlsZSA9IGZpbGUubmFtZTtcbiAgICB0aGlzLmVtaXQodGhpcy5ldmVudG5hbWVzLmNvbXBsZXRlLCBtZXNzYWdlKTtcbiAgICBjb25zdCBmb3JtZGF0YSA9IG5ldyBGb3JtRGF0YSgpO1xuICAgIHBhdGggPSBwYXRoICsgKChwYXRoLnNsaWNlKC0xKSA9PT0gZGlyc2VwYXJhdG9yKSA/IGBgIDogZGlyc2VwYXJhdG9yKSArIGZpbGUubmFtZTtcbiAgICBmb3JtZGF0YS5hcHBlbmQoJ3BhdGgnLCBwYXRoKTtcbiAgICBmb3JtZGF0YS5hcHBlbmQoJ2ZpbGUnLCBmaWxlLCBmaWxlLm5hbWUpO1xuICAgIGlmICh0aGlzLnBhcnQpIGZvcm1kYXRhLmFwcGVuZCgncGFydCcsIHRoaXMucGFydCk7XG4gICAgZWxzZSBpZiAoY2FsbGJhY2tjaHVuayAhPT0gbnVsbCkgZm9ybWRhdGEuYXBwZW5kKCdpc2NodW5rJywgdHJ1ZSk7XG4gICAgZmV0Y2godGhpcy5vcHRpb25zLnVwbG9hZHVybCwge1xuICAgICAgLy8gIG1vZGU6ICdjb3JzJyxcbiAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICBjcmVkZW50aWFsczogXCJpbmNsdWRlXCIsXG4gICAgICBib2R5OiBmb3JtZGF0YSxcbiAgICB9KS50aGVuKGFzeW5jIChyZXNwb25zZSkgPT4ge1xuICAgICAgY29uc29sZS5sb2coJ3Jlc3BvbnNlLS0tLS0tLS0tLS0tLS0tLS0tLS0tLScsIHJlc3BvbnNlKTtcbiAgICAgIGNvbnNvbGUubG9nKCdjYWxsYmFja2NodW5rLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLScsIGNhbGxiYWNrY2h1bmspXG4gICAgICBtZXNzYWdlLnBhdGggPSBwYXRoO1xuICAgICAgaWYgKHJlc3BvbnNlLnN0YXR1cyAhPT0gMjAwKSB7XG4gICAgICAgIHRoaXMub25FcnJvcih0aGlzLmV2ZW50bmFtZXMuZXJyb3IsIG1lc3NhZ2UpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoY2FsbGJhY2tjaHVuayAhPT0gbnVsbCkge1xuICAgICAgICBhd2FpdCBjYWxsYmFja2NodW5rKCk7XG4gICAgICB9IGVsc2UgYXdhaXQgdGhpcy5lbmRGZXRjaChtZXNzYWdlKTtcbiAgICB9KTtcbiAgfVxufSJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/modules/files/js-dirtozip.js\n")}}]);