/*! For license information please see src_modules_files_js-dirtozip_js.js.LICENSE.txt */
"use strict";(self.webpackChunk=self.webpackChunk||[]).push([["src_modules_files_js-dirtozip_js"],{"./src/modules/files/js-dirtozip.js":(module,__webpack_exports__,__webpack_require__)=>{eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   JsDirToZip: () => (/* binding */ JsDirToZip)\n/* harmony export */ });\n/* harmony import */ var _modules_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../modules/utils.js */ \"./src/modules/utils.js\");\n/* harmony import */ var fflate__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! fflate */ \"./node_modules/fflate/esm/browser.js\");\n/* harmony import */ var _modules_module_event_emitter_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../modules/module-event-emitter.js */ \"./src/modules/module-event-emitter.js\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_modules_module_event_emitter_js__WEBPACK_IMPORTED_MODULE_1__]);\n_modules_module_event_emitter_js__WEBPACK_IMPORTED_MODULE_1__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];\n\n\n\n\n\nconst already_compressed = new Set([\n  'zip', 'gz', 'png', 'jpg', 'jpeg', 'pdf', 'doc', 'docx', 'ppt', 'pptx',\n  'xls', 'xlsx', 'heic', 'heif', '7z', 'bz2', 'rar', 'gif', 'webp', 'webm',\n  'mp4', 'mov', 'mp3', 'aifc'\n]);\nconst accept = '.tsv,.png,.jpg, .jpeg,.zip,.gz,.7z,.bz2';\nconst MAXSIZE = 1073741824; //4294967296; //// 3221225472; // 2147483648;\nfunction JsDirToZip(options = {}) {\n  const eventnames = {\n    ready: 'ready',\n    follow: 'follow',\n    complete: 'complete',\n    endreaddir: 'endreaddir',\n    gzip: 'gzip',\n    endzip: 'endzip',\n    sendfile: 'sendfile',\n    bigfile: 'bigfile',\n    terminate: 'terminate',\n    pending: 'pending',\n    errorfile: 'errorfile',\n    counter: 'counter',\n    reject: 'reject',\n    message: 'message',\n    error: 'error',\n    init: 'init'\n  };\n  let jsScanDir, properties;\n  const defaultOptions = {\n    uploadurl: '/gui/files/upload',\n    largefile: MAXSIZE,\n    accept: accept.split(',')\n  }\n  // uses https://developer.mozilla.org/en-US/docs/Web/API/File_System_API/Origin_private_file_system\n  //# alternative (not supported in Safari) for .createWritable\n  options = { ...defaultOptions,\n    ...options\n  };\n  // other module receiving events\n  const _listener = (options.listener) ? options.listener : uuid;\n  Object.freeze(options);\n  const uuid = (0,_modules_utils_js__WEBPACK_IMPORTED_MODULE_0__.generate_uuid)();\n  init();\n\n  function init() {\n    properties = initProps();\n    _modules_module_event_emitter_js__WEBPACK_IMPORTED_MODULE_1__.ModuleEventEmitter.on(eventnames.init, async (e) => {\n      //  if (!e.bigfile && !e.part) {\n      if (isActive() === false) {\n        await reset();\n        _modules_module_event_emitter_js__WEBPACK_IMPORTED_MODULE_1__.ModuleEventEmitter.emit(eventnames.complete, {\n          name: eventnames.ready\n        }, _listener);\n        properties.endreaddir = false;\n      } else console.log('partly finshed ', e);\n    }, uuid);\n    _modules_module_event_emitter_js__WEBPACK_IMPORTED_MODULE_1__.ModuleEventEmitter.on(eventnames.endzip, (e) => {\n      if (!e.bigfile && properties.zip) properties.zip.end();\n      else if (e.bigfile && properties.gzipped) console.log('--gzipped end', properties.gzipped);\n      console.log('endzip%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%');\n      const message = buildMessage(e, {\n        name: eventnames.sendfile,\n      });\n      _modules_module_event_emitter_js__WEBPACK_IMPORTED_MODULE_1__.ModuleEventEmitter.emit(eventnames.complete, message, _listener);\n    }, uuid);\n    _modules_module_event_emitter_js__WEBPACK_IMPORTED_MODULE_1__.ModuleEventEmitter.on(eventnames.sendfile, async (e) => {\n      const file = (e.bigfile) ? await properties.gzipped.getFile(): await getFile();\n      if (e.bigfile) {\n        const path = (e.path ? e.path : '').replace(e.bigfile, '');\n        sendChunk(path);\n      } else sendZipFile(file, (e.path ? e.path : ''), null);\n    }, uuid);\n    _modules_module_event_emitter_js__WEBPACK_IMPORTED_MODULE_1__.ModuleEventEmitter.on(eventnames.endreaddir, (e) => {\n      properties.endreaddir = true;\n      checkProcessed(e);\n    }, uuid);\n    _modules_module_event_emitter_js__WEBPACK_IMPORTED_MODULE_1__.ModuleEventEmitter.on(eventnames.counter, async (e) => {\n      properties.endcounter = false;\n      properties.counter[e.name] += 1;\n      _modules_module_event_emitter_js__WEBPACK_IMPORTED_MODULE_1__.ModuleEventEmitter.emit(eventnames.counter, e, _listener);\n      if (e.name === 'zip' && properties.counter.scan === properties.counter.zip) {\n        properties.endcounter = true;\n        checkProcessed(e);\n      }\n      if (e.name === 'zip' && properties.callback) await properties.callback();\n    }, uuid);\n\n  }\n\n  function initProps() {\n    return {\n      zip: null,\n      zipname: null,\n      filestream: null,\n      streamhandle: null,\n      gzipped: null,\n      sizetozip: 0,\n      part: 0,\n      follow: null,\n      endcounter: false,\n      endreaddir: false,\n      callback: null,\n      pos: 0,\n      counter: {\n        scan: 0,\n        zip: 0,\n        reject: 0\n      },\n      handlers: []\n    }\n  }\n  async function reset() {\n    properties = initProps();\n    await initStorage();\n  }\n\n  function isActive() {\n    return (properties.zip !== null || properties.follow !== null || properties.gzipped !== null || properties.endreaddir !== true);\n  }\n  async function initZip() {\n    properties.pos = 0;\n    properties.sizetozip = 0;\n    console.log('==================newzip');\n    properties.zip = new fflate__WEBPACK_IMPORTED_MODULE_2__.Zip((error, chunk, final) => {\n      if (error) {\n        console.log('error', error);\n        return false;\n      } else {\n        properties.streamhandle.write(chunk, {\n          at: self.pos\n        });\n        properties.pos += chunk.length;\n        if (final) {\n          properties.streamhandle.close();\n          console.log('final-----------------------------*******************************-', properties.pos);\n\n        }\n\n      }\n    });\n    // hack for memory usage\n    zipOnData();\n\n    if (properties.follow) await properties.follow();\n  }\n\n  function checkProcessed(e) {\n    if (properties.endreaddir === true && properties.endcounter === true) {\n      const message = buildMessage(e, {\n       name: eventnames.endzip\n      });\n      _modules_module_event_emitter_js__WEBPACK_IMPORTED_MODULE_1__.ModuleEventEmitter.emit(eventnames.complete, message, _listener);\n    }\n  }\n\n  function zipOnData(zip = null) {\n    zip = (zip === null) ? properties.zip : zip;\n    const ondata = zip.ondata;\n    zip.ondata = (error, data, final) => {\n      ondata(error, data, final);\n      if (final) {\n        zip.d = null;\n        zip.u.at(-1).d = null; // Object created in `zip.add()`\n      }\n    }\n  }\n\n  function buildMessage(e, message = {}) {\n    if (e.hasOwnProperty(\"part\")) {\n      message.part = e.part;\n    } else properties.part = 0;\n    if (e.hasOwnProperty(\"bigfile\")) message.bigfile = e.bigfile;\n    if (e.hasOwnProperty(\"path\")) message.path = e.path;\n    return message;\n  }\n  async function quotaEstimate() {\n    if (navigator && navigator.storage && navigator.storage.estimate) {\n      navigator.storage.estimate().then((quota) => {\n        const percentageUsed = ((quota.usage / quota.quota) * 100).toFixed(2);\n        const remaining = (0,_modules_utils_js__WEBPACK_IMPORTED_MODULE_0__.format_bytes)(quota.quota - quota.usage);\n        _modules_module_event_emitter_js__WEBPACK_IMPORTED_MODULE_1__.ModuleEventEmitter.emit(eventnames.message, {\n          id: \"quota\",\n          name: \"console\",\n          message: \"you've used \" + percentageUsed + \"% of the available storage (\" + remaining + \").\",\n        }, _listener);\n      });\n    }\n  }\n\n  async function initStorage() {\n    if (navigator && navigator.storage && navigator.storage.estimate) {\n      await cleanStorage();\n      quotaEstimate();\n    } else _modules_module_event_emitter_js__WEBPACK_IMPORTED_MODULE_1__.ModuleEventEmitter.emit(eventnames.message, {\n      name: \"error\",\n      message: \"no navigator storage\"\n    }, uuid);\n  }\n  async function createLocalStream(name, accept = {\n    'application/zip': ['.zip'],\n  }) {\n    const root = await navigator.storage.getDirectory();\n    const opts = {\n      types: [{\n        description: 'Temp file',\n        accept: accept,\n      }, ],\n      create: true\n    };\n    const filestream = await root.getFileHandle(name, opts);\n    const streamhandle = await filestream.createWritable();\n    return {\n      filestream,\n      streamhandle\n    };\n  }\n  async function scanCommon(zipname, options = {}) {\n    properties.endreaddir = false;\n    if (properties.zip === null) {\n      zipname = zipname.split(_modules_utils_js__WEBPACK_IMPORTED_MODULE_0__.dirseparator)[0];\n      zipname = (zipname.trim() === ``) ? 'temp' : zipname;\n      const type = (options && options.type) ? options.type : '.zip';\n      properties.zipname = ((options.zipname) ? options.zipname : zipname) + type; //\n      const zipinstorage = await searchStorage(properties.zipname);\n      if (zipinstorage) properties.zipname = '1_' + properties.zipname;\n      const {\n        filestream,\n        streamhandle\n      } = await createLocalStream(properties.zipname);\n      properties.filestream = filestream;\n      properties.streamhandle = streamhandle;\n      let size = 0;\n      properties.part = 0;\n      await initZip();\n      if (!jsScanDir) {\n        const {\n          JsScanDir\n        } = await __webpack_require__.e(/*! import() */ \"src_modules_files_js-scandir_js\").then(__webpack_require__.bind(__webpack_require__, /*! ../files/js-scandir.js */ \"./src/modules/files/js-scandir.js\"));\n        const process_file = async (entry, callback) => {\n          if (acceptFile(entry)) {\n            properties.callback = callback;\n            await processFile(entry);\n          } else rejectFile(entry, callback);\n        }\n        jsScanDir = JsScanDir(process_file);\n      }\n    }\n  }\n\n  async function scanBrowse(pick, options = {}) {\n    const entries = (pick instanceof FileList) ? Array.from(pick) : (pick.kind === \"directory\") ? await Array.fromAsync(pick.values()): (Array.isArray(pick)) ? pick : [pick];\n    const name = entries[0].name;\n    let relpath = (pick instanceof FileList) ? entries[0].webkitRelativePath : null;\n    relpath = (relpath) ? relpath.split(_modules_utils_js__WEBPACK_IMPORTED_MODULE_0__.dirseparator) : [``];\n    if (relpath.length) relpath.pop();\n    relpath = relpath.join(_modules_utils_js__WEBPACK_IMPORTED_MODULE_0__.dirseparator)\n    const path = (pick instanceof FileList) ? relpath : (pick.kind === \"directory\") ? pick.name : ``;\n    await scanCommon(path, options);\n    await jsScanDir.processEntries(entries, path, () => {\n      dirComplete();\n    });\n  }\n\n  async function scanHandle(dropped, options = {}) {\n    await scanCommon(dropped.name, options);\n    if (dropped.isDirectory === true) {\n      await jsScanDir.readDirectory(dropped, () => {\n        dirComplete();\n      });\n    } else if (dropped.isFile === true) {\n      await jsScanDir.processFile(dropped, () => {\n        dirComplete();\n      });\n    }\n  }\n\n  function dirComplete() {\n    _modules_module_event_emitter_js__WEBPACK_IMPORTED_MODULE_1__.ModuleEventEmitter.emit(eventnames.endreaddir, {\n      name: eventnames.endreaddir\n    }, uuid);\n  }\n\n  function addHandler(handler) {\n    properties.handlers.push(handler);\n  }\n\n  async function execHandler() {\n    // serie\n    if (properties.handlers.length > 0) {\n      const handler = properties.handlers.shift();\n      await handler();\n    }\n    return;\n  }\n  async function gzipBigFile(file, filepath) {\n    if (properties.gzipped !== null) {\n      await addHandler(async () => {\n        await gzipBigFile(file, filepath);\n      });\n      return;\n    }\n    let dt = Date.now();\n    filepath = (filepath.indexOf(_modules_utils_js__WEBPACK_IMPORTED_MODULE_0__.dirseparator) === 0) ? filepath.substr(1) : filepath;\n    /*filepath = filepath.split(dirseparator);\n    filepath.pop();\n    filepath = filepath.join(dirseparator);*/\n    const ext = file.name.slice(file.name.lastIndexOf('.') + 1);\n    if (already_compressed.has(ext)) {\n      properties.gzipped = file;\n      _modules_module_event_emitter_js__WEBPACK_IMPORTED_MODULE_1__.ModuleEventEmitter.emit(eventnames.counter, {\n        name: 'zip',\n        path: filepath,\n        size: file.size\n      }, uuid);\n      _modules_module_event_emitter_js__WEBPACK_IMPORTED_MODULE_1__.ModuleEventEmitter.emit(eventnames.complete, {\n        name: eventnames.bigfile,\n        bigfile: file.name,\n        path: filepath,\n      }, _listener);\n    } else {\n      let zipname = file.name + '.gz';\n      _modules_module_event_emitter_js__WEBPACK_IMPORTED_MODULE_1__.ModuleEventEmitter.emit(eventnames.complete, {\n        name: eventnames.gzip,\n        bigfile: file.name,\n        path: filepath,\n        size: file.size\n      }, _listener);\n      const {\n        filestream,\n        streamhandle\n      } = await createLocalStream(zipname, {\n        'application/gzip': ['.gz'],\n      });\n      let pos = 0;\n\n      const gzipped = new fflate__WEBPACK_IMPORTED_MODULE_2__.AsyncGzip({\n        level: 6,\n        filename: filepath\n      });\n      gzipped.ondata = (err, data, final) => {\n        if (err) {\n          console.log('gzip err', err);\n          onError(eventnames.errorfile, {\n            bigfile: file.name,\n            path: filepath,\n            size: file.size\n          });\n        } else {\n          streamhandle.write(data, {\n            at: pos\n          });\n          pos += data.length;\n\n          if (final) {\n            console.log('final BIGFILE%%%%%%%%%%%%%%%%%%%%' + eventnames.bigfile, filepath)\n\n            console.log('timetogzzip', (Date.now() - dt) / 1000);\n\n            streamhandle.close();\n            properties.gzipped = filestream;\n            _modules_module_event_emitter_js__WEBPACK_IMPORTED_MODULE_1__.ModuleEventEmitter.emit(eventnames.counter, {\n              name: 'zip',\n              path: filepath,\n              size: file.size\n            }, uuid);\n            _modules_module_event_emitter_js__WEBPACK_IMPORTED_MODULE_1__.ModuleEventEmitter.emit(eventnames.complete, {\n              name: eventnames.bigfile,\n              bigfile: file.name,\n              path: filepath\n            }, _listener);\n          }\n        }\n      };\n      const count = false;\n      await readFile(file, filepath, gzipped, count);\n    }\n\n\n  }\n  async function partZip() {\n    properties.part += 1;\n    _modules_module_event_emitter_js__WEBPACK_IMPORTED_MODULE_1__.ModuleEventEmitter.emit(eventnames.complete, {\n     name: eventnames.endzip,\n      part: properties.part\n    }, _listener);\n  }\n  async function readFile(file, filepath, zippedstream, count = true) {\n    const reader = file.stream().getReader();\n    let pause = false;\n    /*  onBackpressure(zippedstream, this.streamhandle, should_apply_backpressure => {\n        if (should_apply_backpressure) pause = true;\n        else if (pause) pause = false;\n      });*/\n    while (true) {\n      const {\n        done,\n        value\n      } = await reader.read();\n      if (done) {\n        zippedstream.push(new Uint8Array(0), true);\n        if (count === true) _modules_module_event_emitter_js__WEBPACK_IMPORTED_MODULE_1__.ModuleEventEmitter.emit(eventnames.counter, {\n          name: 'zip',\n          path: filepath,\n          size: (zippedstream.size) ? zippedstream.size : file.size\n        }, uuid);\n        break;\n      }\n      zippedstream.push(value);\n    }\n  }\n\n  async function zipStream(file, filepath) {\n    const ext = filepath.slice(filepath.lastIndexOf('.') + 1);\n    const iscompressed = already_compressed.has(ext);\n    const zippedstream = (iscompressed) ? new fflate__WEBPACK_IMPORTED_MODULE_2__.ZipPassThrough(filepath) : file.size > options.largefile ?\n      new fflate__WEBPACK_IMPORTED_MODULE_2__.AsyncZipDeflate(filepath, {\n        level: 6,\n      }) : new fflate__WEBPACK_IMPORTED_MODULE_2__.ZipDeflate(filepath, {\n        level: 6\n      });\n    properties.zip.add(zippedstream);\n    await readFile(file, filepath, zippedstream);\n  }\n\n  async function addFileToZipStream(file, filepath, count = true) {\n    if (count === true) _modules_module_event_emitter_js__WEBPACK_IMPORTED_MODULE_1__.ModuleEventEmitter.emit(eventnames.counter, {\n      name: 'scan',\n      path: filepath,\n      size: file.size\n    }, uuid);\n    properties.follow = null;\n    // check file size > max post size\n    if (file.size >= MAXSIZE) {\n      gzipBigFile(file, filepath);\n    } else {\n      // check zip file size > total zip size\n      properties.sizetozip += file.size;\n      if (properties.sizetozip >= MAXSIZE) {\n        properties.follow = async () => {\n          await zipStream(file, filepath);\n        }\n        partZip();\n      } else {\n        await zipStream(file, filepath);\n      }\n    }\n  }\n\n  function acceptFile(entry) {\n    const filepath = entry.name;\n    const ext = filepath.slice(filepath.lastIndexOf('.') + 1);\n    return accept.includes(ext);\n  }\n\n  function rejectFile(file, callback = null) {\n    const path = (file.fullPath) ? file.fullPath : file.webkitRelativePath;\n    properties.counter.reject += 1;\n    _modules_module_event_emitter_js__WEBPACK_IMPORTED_MODULE_1__.ModuleEventEmitter.emit(eventnames.reject, {\n      name: eventnames.reject,\n      path: path,\n    }, _listener);\n    if (callback !== null) callback();\n  }\n  async function processFile(entry) {\n    const path = (entry.fullPath) ? entry.fullPath : entry.webkitRelativePath;\n    entry.file(async file => {\n      await addFileToZipStream(file, path);\n    });\n  }\n\n  function onError(action, message = null) {\n    message = (message) ? message : {};\n    switch (action) {\n      case eventnames.init:\n        message.name = eventnames.init;\n        break;\n      case eventnames.errorfile:\n        console.log('errorfile', message);\n      default:\n        message.name = eventnames.follow;\n        break;\n    }\n    _modules_module_event_emitter_js__WEBPACK_IMPORTED_MODULE_1__.ModuleEventEmitter.emit(eventnames.error, message, _listener);\n  }\n  async function searchStorage(search) {\n    const entry = await navigator.storage.getDirectory();\n    for await (const [key, value] of entry.entries()) {\n      if (search === key) {\n        return true;\n        break;\n      }\n    }\n    return false;\n  }\n  async function cleanStorage(entry = null) {\n    entry = (entry) ? entry : await navigator.storage.getDirectory();\n    for await (const [key, value] of entry.entries()) {\n      try {\n        await entry.removeEntry(key);\n        console.log(' Success remove storage ', key);\n      } catch (error) {\n        console.log(' error remove storage ' + key, error);\n      }\n    }\n\n  }\n\n  async function endFetch(message, clean = false) {\n    message.name = eventnames.terminate;\n    if (properties.follow) {\n      properties.streamhandle = await properties.filestream.createWritable();\n      message.name = eventnames.follow;\n      _modules_module_event_emitter_js__WEBPACK_IMPORTED_MODULE_1__.ModuleEventEmitter.emit(eventnames.follow, message, _listener)\n      await initZip();\n      return;\n    } else if (message.hasOwnProperty(\"bigfile\") && message.bigfile !== false) {\n      properties.gzipped = null;\n\n      if (properties.handlers.length > 0) {\n        message.name = eventnames.follow;\n        _modules_module_event_emitter_js__WEBPACK_IMPORTED_MODULE_1__.ModuleEventEmitter.emit(eventnames.follow, message, _listener);\n        console.log(' handlers to do', message);\n        if (properties.handlers.length > 0) await execHandler();\n        return;\n      }\n    } else properties.zip = null;\n    _modules_module_event_emitter_js__WEBPACK_IMPORTED_MODULE_1__.ModuleEventEmitter.emit(eventnames.complete, message, _listener);\n  }\n\n  async function sendChunk(path, start = 0, chunknum = 0, chunksize = MAXSIZE) {\n    console.log('send chunk ', properties.gzipped)\n    const file = await properties.gzipped.getFile();\n    const end = Math.min(start + chunksize, file.size);\n    if (end === file.size) {\n     await sendZipFile(file, path, null, true);\n    } else {\n      const partfile = file.slice(start, end);\n      partfile.name = chunknum + '_' + file.name;\n      await sendZipfile(partfile, path, async () => {\n        start += end;\n        chunknum++;\n\n        if (start <= file.size) await sendChunk(path, start, chunknum, chunksize);\n      }, true)\n    }\n    return chunknum;\n  }\n  async function getFile(filestream = null) {\n    filestream = (filestream === null) ? properties.filestream : filestream;\n    const file = await filestream.getFile();\n    return file;\n  }\n  async function sendZipFile(file, path, callbackchunk = null, bigfile = false) {\n    const message = {\n      name: eventnames.pending,\n      path: path\n    }\n    if (bigfile) message.bigfile = file.name;\n    _modules_module_event_emitter_js__WEBPACK_IMPORTED_MODULE_1__.ModuleEventEmitter.emit(eventnames.complete, message, _listener);\n    const formdata = new FormData();\n    path = path + ((path.slice(-1) === _modules_utils_js__WEBPACK_IMPORTED_MODULE_0__.dirseparator) ? `` : _modules_utils_js__WEBPACK_IMPORTED_MODULE_0__.dirseparator) + file.name;\n    formdata.append('path', path);\n    formdata.append('file', file, file.name);\n    if (properties.part) formdata.append('part', properties.part);\n    else if (callbackchunk !== null) formdata.append('ischunk', true);\n    fetch(options.uploadurl, {\n      //  mode: 'cors',\n      method: \"POST\",\n      credentials: \"include\",\n      body: formdata,\n    }).then(async (response) => {\n      console.log('response----------------------', response);\n      console.log('callbackchunk-------------------------------', callbackchunk)\n      message.path = path;\n      if (response.status !== 200) {\n        onError(eventnames.error, message);\n        return;\n      }\n      if (callbackchunk !== null) { console.log('callbackchunk not null')\n        await callbackchunk();\n      } else await endFetch(message);\n    });\n  }\n  return {\n    uuid,\n    eventnames,\n    scanBrowse,\n    scanHandle,\n    quotaEstimate\n  }\n}\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvbW9kdWxlcy9maWxlcy9qcy1kaXJ0b3ppcC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQWE7QUFNbUI7O0FBUWhCO0FBRytCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixjQUFjLGlCQUFpQjtBQUNwRCxnQ0FBZ0M7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxnRUFBYTtBQUM1Qjs7QUFFQTtBQUNBO0FBQ0EsSUFBSSxnRkFBa0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0EsUUFBUSxnRkFBa0I7QUFDMUI7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxRQUFRO0FBQ1IsS0FBSztBQUNMLElBQUksZ0ZBQWtCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTSxnRkFBa0I7QUFDeEIsS0FBSztBQUNMLElBQUksZ0ZBQWtCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSLEtBQUs7QUFDTCxJQUFJLGdGQUFrQjtBQUN0QjtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUksZ0ZBQWtCO0FBQ3RCO0FBQ0E7QUFDQSxNQUFNLGdGQUFrQjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsdUNBQUc7QUFDNUI7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU0sZ0ZBQWtCO0FBQ3hCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBOztBQUVBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsK0RBQVk7QUFDdEMsUUFBUSxnRkFBa0I7QUFDMUI7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxLQUFLLGdGQUFrQjtBQUM3QjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRDtBQUNqRDtBQUNBO0FBQ0EsOEJBQThCLDJEQUFZO0FBQzFDO0FBQ0E7QUFDQSxtRkFBbUY7QUFDbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxRQUFRLCtMQUFnQztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDhDQUE4QztBQUM5QztBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsMkRBQVk7QUFDcEQ7QUFDQSwyQkFBMkIsMkRBQVk7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUEsaURBQWlEO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQSxJQUFJLGdGQUFrQjtBQUN0QjtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQywyREFBWTtBQUM3QztBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBLE1BQU0sZ0ZBQWtCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNLGdGQUFrQjtBQUN4QjtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0EsTUFBTSxnRkFBa0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsT0FBTztBQUNQOztBQUVBLDBCQUEwQiw2Q0FBUztBQUNuQztBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFVBQVU7QUFDVjtBQUNBO0FBQ0EsV0FBVztBQUNYOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLFlBQVksZ0ZBQWtCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixZQUFZLGdGQUFrQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLGdGQUFrQjtBQUN0QjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTyxFQUFFO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLDRCQUE0QixnRkFBa0I7QUFDOUM7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsOENBQThDLGtEQUFjO0FBQzVELFVBQVUsbURBQWU7QUFDekI7QUFDQSxPQUFPLFFBQVEsOENBQVU7QUFDekI7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0Esd0JBQXdCLGdGQUFrQjtBQUMxQztBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLGdGQUFrQjtBQUN0QjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLGdGQUFrQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxnRkFBa0I7QUFDeEI7QUFDQTtBQUNBLE1BQU07QUFDTjs7QUFFQTtBQUNBO0FBQ0EsUUFBUSxnRkFBa0I7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sSUFBSSxnRkFBa0I7QUFDdEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksZ0ZBQWtCO0FBQ3RCO0FBQ0EsdUNBQXVDLDJEQUFZLFNBQVMsMkRBQVk7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0EsUUFBUTtBQUNSLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy9tb2R1bGVzL2ZpbGVzL2pzLWRpcnRvemlwLmpzPzg1MzgiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuaW1wb3J0IHtcbiAgZmV0Y2hTZXR0aW5ncyxcbiAgZm9ybWF0X2J5dGVzLFxuICBkaXJzZXBhcmF0b3IsXG4gIGdlbmVyYXRlX3V1aWRcbn0gZnJvbSAnLi4vLi4vbW9kdWxlcy91dGlscy5qcyc7XG5cbmltcG9ydCB7XG4gIEFzeW5jR3ppcCxcbiAgWmlwLFxuICBBc3luY1ppcERlZmxhdGUsXG4gIFppcFBhc3NUaHJvdWdoLFxuICBaaXBEZWZsYXRlLFxufSBmcm9tICdmZmxhdGUnO1xuaW1wb3J0IHtcbiAgTW9kdWxlRXZlbnRFbWl0dGVyXG59IGZyb20gJy4uLy4uL21vZHVsZXMvbW9kdWxlLWV2ZW50LWVtaXR0ZXIuanMnO1xuY29uc3QgYWxyZWFkeV9jb21wcmVzc2VkID0gbmV3IFNldChbXG4gICd6aXAnLCAnZ3onLCAncG5nJywgJ2pwZycsICdqcGVnJywgJ3BkZicsICdkb2MnLCAnZG9jeCcsICdwcHQnLCAncHB0eCcsXG4gICd4bHMnLCAneGxzeCcsICdoZWljJywgJ2hlaWYnLCAnN3onLCAnYnoyJywgJ3JhcicsICdnaWYnLCAnd2VicCcsICd3ZWJtJyxcbiAgJ21wNCcsICdtb3YnLCAnbXAzJywgJ2FpZmMnXG5dKTtcbmNvbnN0IGFjY2VwdCA9ICcudHN2LC5wbmcsLmpwZywgLmpwZWcsLnppcCwuZ3osLjd6LC5iejInO1xuY29uc3QgTUFYU0laRSA9IDEwNzM3NDE4MjQ7IC8vNDI5NDk2NzI5NjsgLy8vLyAzMjIxMjI1NDcyOyAvLyAyMTQ3NDgzNjQ4O1xuZXhwb3J0IGZ1bmN0aW9uIEpzRGlyVG9aaXAob3B0aW9ucyA9IHt9KSB7XG4gIGNvbnN0IGV2ZW50bmFtZXMgPSB7XG4gICAgcmVhZHk6ICdyZWFkeScsXG4gICAgZm9sbG93OiAnZm9sbG93JyxcbiAgICBjb21wbGV0ZTogJ2NvbXBsZXRlJyxcbiAgICBlbmRyZWFkZGlyOiAnZW5kcmVhZGRpcicsXG4gICAgZ3ppcDogJ2d6aXAnLFxuICAgIGVuZHppcDogJ2VuZHppcCcsXG4gICAgc2VuZGZpbGU6ICdzZW5kZmlsZScsXG4gICAgYmlnZmlsZTogJ2JpZ2ZpbGUnLFxuICAgIHRlcm1pbmF0ZTogJ3Rlcm1pbmF0ZScsXG4gICAgcGVuZGluZzogJ3BlbmRpbmcnLFxuICAgIGVycm9yZmlsZTogJ2Vycm9yZmlsZScsXG4gICAgY291bnRlcjogJ2NvdW50ZXInLFxuICAgIHJlamVjdDogJ3JlamVjdCcsXG4gICAgbWVzc2FnZTogJ21lc3NhZ2UnLFxuICAgIGVycm9yOiAnZXJyb3InLFxuICAgIGluaXQ6ICdpbml0J1xuICB9O1xuICBsZXQganNTY2FuRGlyLCBwcm9wZXJ0aWVzO1xuICBjb25zdCBkZWZhdWx0T3B0aW9ucyA9IHtcbiAgICB1cGxvYWR1cmw6ICcvZ3VpL2ZpbGVzL3VwbG9hZCcsXG4gICAgbGFyZ2VmaWxlOiBNQVhTSVpFLFxuICAgIGFjY2VwdDogYWNjZXB0LnNwbGl0KCcsJylcbiAgfVxuICAvLyB1c2VzIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9GaWxlX1N5c3RlbV9BUEkvT3JpZ2luX3ByaXZhdGVfZmlsZV9zeXN0ZW1cbiAgLy8jIGFsdGVybmF0aXZlIChub3Qgc3VwcG9ydGVkIGluIFNhZmFyaSkgZm9yIC5jcmVhdGVXcml0YWJsZVxuICBvcHRpb25zID0geyAuLi5kZWZhdWx0T3B0aW9ucyxcbiAgICAuLi5vcHRpb25zXG4gIH07XG4gIC8vIG90aGVyIG1vZHVsZSByZWNlaXZpbmcgZXZlbnRzXG4gIGNvbnN0IF9saXN0ZW5lciA9IChvcHRpb25zLmxpc3RlbmVyKSA/IG9wdGlvbnMubGlzdGVuZXIgOiB1dWlkO1xuICBPYmplY3QuZnJlZXplKG9wdGlvbnMpO1xuICBjb25zdCB1dWlkID0gZ2VuZXJhdGVfdXVpZCgpO1xuICBpbml0KCk7XG5cbiAgZnVuY3Rpb24gaW5pdCgpIHtcbiAgICBwcm9wZXJ0aWVzID0gaW5pdFByb3BzKCk7XG4gICAgTW9kdWxlRXZlbnRFbWl0dGVyLm9uKGV2ZW50bmFtZXMuaW5pdCwgYXN5bmMgKGUpID0+IHtcbiAgICAgIC8vICBpZiAoIWUuYmlnZmlsZSAmJiAhZS5wYXJ0KSB7XG4gICAgICBpZiAoaXNBY3RpdmUoKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgYXdhaXQgcmVzZXQoKTtcbiAgICAgICAgTW9kdWxlRXZlbnRFbWl0dGVyLmVtaXQoZXZlbnRuYW1lcy5jb21wbGV0ZSwge1xuICAgICAgICAgIG5hbWU6IGV2ZW50bmFtZXMucmVhZHlcbiAgICAgICAgfSwgX2xpc3RlbmVyKTtcbiAgICAgICAgcHJvcGVydGllcy5lbmRyZWFkZGlyID0gZmFsc2U7XG4gICAgICB9IGVsc2UgY29uc29sZS5sb2coJ3BhcnRseSBmaW5zaGVkICcsIGUpO1xuICAgIH0sIHV1aWQpO1xuICAgIE1vZHVsZUV2ZW50RW1pdHRlci5vbihldmVudG5hbWVzLmVuZHppcCwgKGUpID0+IHtcbiAgICAgIGlmICghZS5iaWdmaWxlICYmIHByb3BlcnRpZXMuemlwKSBwcm9wZXJ0aWVzLnppcC5lbmQoKTtcbiAgICAgIGVsc2UgaWYgKGUuYmlnZmlsZSAmJiBwcm9wZXJ0aWVzLmd6aXBwZWQpIGNvbnNvbGUubG9nKCctLWd6aXBwZWQgZW5kJywgcHJvcGVydGllcy5nemlwcGVkKTtcbiAgICAgIGNvbnNvbGUubG9nKCdlbmR6aXAlJSUlJSUlJSUlJSUlJSUlJSUlJSUlJSUlJSUlJSUlJSUlJyk7XG4gICAgICBjb25zdCBtZXNzYWdlID0gYnVpbGRNZXNzYWdlKGUsIHtcbiAgICAgICAgbmFtZTogZXZlbnRuYW1lcy5zZW5kZmlsZSxcbiAgICAgIH0pO1xuICAgICAgTW9kdWxlRXZlbnRFbWl0dGVyLmVtaXQoZXZlbnRuYW1lcy5jb21wbGV0ZSwgbWVzc2FnZSwgX2xpc3RlbmVyKTtcbiAgICB9LCB1dWlkKTtcbiAgICBNb2R1bGVFdmVudEVtaXR0ZXIub24oZXZlbnRuYW1lcy5zZW5kZmlsZSwgYXN5bmMgKGUpID0+IHtcbiAgICAgIGNvbnN0IGZpbGUgPSAoZS5iaWdmaWxlKSA/IGF3YWl0IHByb3BlcnRpZXMuZ3ppcHBlZC5nZXRGaWxlKCk6IGF3YWl0IGdldEZpbGUoKTtcbiAgICAgIGlmIChlLmJpZ2ZpbGUpIHtcbiAgICAgICAgY29uc3QgcGF0aCA9IChlLnBhdGggPyBlLnBhdGggOiAnJykucmVwbGFjZShlLmJpZ2ZpbGUsICcnKTtcbiAgICAgICAgc2VuZENodW5rKHBhdGgpO1xuICAgICAgfSBlbHNlIHNlbmRaaXBGaWxlKGZpbGUsIChlLnBhdGggPyBlLnBhdGggOiAnJyksIG51bGwpO1xuICAgIH0sIHV1aWQpO1xuICAgIE1vZHVsZUV2ZW50RW1pdHRlci5vbihldmVudG5hbWVzLmVuZHJlYWRkaXIsIChlKSA9PiB7XG4gICAgICBwcm9wZXJ0aWVzLmVuZHJlYWRkaXIgPSB0cnVlO1xuICAgICAgY2hlY2tQcm9jZXNzZWQoZSk7XG4gICAgfSwgdXVpZCk7XG4gICAgTW9kdWxlRXZlbnRFbWl0dGVyLm9uKGV2ZW50bmFtZXMuY291bnRlciwgYXN5bmMgKGUpID0+IHtcbiAgICAgIHByb3BlcnRpZXMuZW5kY291bnRlciA9IGZhbHNlO1xuICAgICAgcHJvcGVydGllcy5jb3VudGVyW2UubmFtZV0gKz0gMTtcbiAgICAgIE1vZHVsZUV2ZW50RW1pdHRlci5lbWl0KGV2ZW50bmFtZXMuY291bnRlciwgZSwgX2xpc3RlbmVyKTtcbiAgICAgIGlmIChlLm5hbWUgPT09ICd6aXAnICYmIHByb3BlcnRpZXMuY291bnRlci5zY2FuID09PSBwcm9wZXJ0aWVzLmNvdW50ZXIuemlwKSB7XG4gICAgICAgIHByb3BlcnRpZXMuZW5kY291bnRlciA9IHRydWU7XG4gICAgICAgIGNoZWNrUHJvY2Vzc2VkKGUpO1xuICAgICAgfVxuICAgICAgaWYgKGUubmFtZSA9PT0gJ3ppcCcgJiYgcHJvcGVydGllcy5jYWxsYmFjaykgYXdhaXQgcHJvcGVydGllcy5jYWxsYmFjaygpO1xuICAgIH0sIHV1aWQpO1xuXG4gIH1cblxuICBmdW5jdGlvbiBpbml0UHJvcHMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHppcDogbnVsbCxcbiAgICAgIHppcG5hbWU6IG51bGwsXG4gICAgICBmaWxlc3RyZWFtOiBudWxsLFxuICAgICAgc3RyZWFtaGFuZGxlOiBudWxsLFxuICAgICAgZ3ppcHBlZDogbnVsbCxcbiAgICAgIHNpemV0b3ppcDogMCxcbiAgICAgIHBhcnQ6IDAsXG4gICAgICBmb2xsb3c6IG51bGwsXG4gICAgICBlbmRjb3VudGVyOiBmYWxzZSxcbiAgICAgIGVuZHJlYWRkaXI6IGZhbHNlLFxuICAgICAgY2FsbGJhY2s6IG51bGwsXG4gICAgICBwb3M6IDAsXG4gICAgICBjb3VudGVyOiB7XG4gICAgICAgIHNjYW46IDAsXG4gICAgICAgIHppcDogMCxcbiAgICAgICAgcmVqZWN0OiAwXG4gICAgICB9LFxuICAgICAgaGFuZGxlcnM6IFtdXG4gICAgfVxuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIHJlc2V0KCkge1xuICAgIHByb3BlcnRpZXMgPSBpbml0UHJvcHMoKTtcbiAgICBhd2FpdCBpbml0U3RvcmFnZSgpO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNBY3RpdmUoKSB7XG4gICAgcmV0dXJuIChwcm9wZXJ0aWVzLnppcCAhPT0gbnVsbCB8fCBwcm9wZXJ0aWVzLmZvbGxvdyAhPT0gbnVsbCB8fCBwcm9wZXJ0aWVzLmd6aXBwZWQgIT09IG51bGwgfHwgcHJvcGVydGllcy5lbmRyZWFkZGlyICE9PSB0cnVlKTtcbiAgfVxuICBhc3luYyBmdW5jdGlvbiBpbml0WmlwKCkge1xuICAgIHByb3BlcnRpZXMucG9zID0gMDtcbiAgICBwcm9wZXJ0aWVzLnNpemV0b3ppcCA9IDA7XG4gICAgY29uc29sZS5sb2coJz09PT09PT09PT09PT09PT09PW5ld3ppcCcpO1xuICAgIHByb3BlcnRpZXMuemlwID0gbmV3IFppcCgoZXJyb3IsIGNodW5rLCBmaW5hbCkgPT4ge1xuICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdlcnJvcicsIGVycm9yKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcHJvcGVydGllcy5zdHJlYW1oYW5kbGUud3JpdGUoY2h1bmssIHtcbiAgICAgICAgICBhdDogc2VsZi5wb3NcbiAgICAgICAgfSk7XG4gICAgICAgIHByb3BlcnRpZXMucG9zICs9IGNodW5rLmxlbmd0aDtcbiAgICAgICAgaWYgKGZpbmFsKSB7XG4gICAgICAgICAgcHJvcGVydGllcy5zdHJlYW1oYW5kbGUuY2xvc2UoKTtcbiAgICAgICAgICBjb25zb2xlLmxvZygnZmluYWwtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiotJywgcHJvcGVydGllcy5wb3MpO1xuXG4gICAgICAgIH1cblxuICAgICAgfVxuICAgIH0pO1xuICAgIC8vIGhhY2sgZm9yIG1lbW9yeSB1c2FnZVxuICAgIHppcE9uRGF0YSgpO1xuXG4gICAgaWYgKHByb3BlcnRpZXMuZm9sbG93KSBhd2FpdCBwcm9wZXJ0aWVzLmZvbGxvdygpO1xuICB9XG5cbiAgZnVuY3Rpb24gY2hlY2tQcm9jZXNzZWQoZSkge1xuICAgIGlmIChwcm9wZXJ0aWVzLmVuZHJlYWRkaXIgPT09IHRydWUgJiYgcHJvcGVydGllcy5lbmRjb3VudGVyID09PSB0cnVlKSB7XG4gICAgICBjb25zdCBtZXNzYWdlID0gYnVpbGRNZXNzYWdlKGUsIHtcbiAgICAgICBuYW1lOiBldmVudG5hbWVzLmVuZHppcFxuICAgICAgfSk7XG4gICAgICBNb2R1bGVFdmVudEVtaXR0ZXIuZW1pdChldmVudG5hbWVzLmNvbXBsZXRlLCBtZXNzYWdlLCBfbGlzdGVuZXIpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHppcE9uRGF0YSh6aXAgPSBudWxsKSB7XG4gICAgemlwID0gKHppcCA9PT0gbnVsbCkgPyBwcm9wZXJ0aWVzLnppcCA6IHppcDtcbiAgICBjb25zdCBvbmRhdGEgPSB6aXAub25kYXRhO1xuICAgIHppcC5vbmRhdGEgPSAoZXJyb3IsIGRhdGEsIGZpbmFsKSA9PiB7XG4gICAgICBvbmRhdGEoZXJyb3IsIGRhdGEsIGZpbmFsKTtcbiAgICAgIGlmIChmaW5hbCkge1xuICAgICAgICB6aXAuZCA9IG51bGw7XG4gICAgICAgIHppcC51LmF0KC0xKS5kID0gbnVsbDsgLy8gT2JqZWN0IGNyZWF0ZWQgaW4gYHppcC5hZGQoKWBcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBidWlsZE1lc3NhZ2UoZSwgbWVzc2FnZSA9IHt9KSB7XG4gICAgaWYgKGUuaGFzT3duUHJvcGVydHkoXCJwYXJ0XCIpKSB7XG4gICAgICBtZXNzYWdlLnBhcnQgPSBlLnBhcnQ7XG4gICAgfSBlbHNlIHByb3BlcnRpZXMucGFydCA9IDA7XG4gICAgaWYgKGUuaGFzT3duUHJvcGVydHkoXCJiaWdmaWxlXCIpKSBtZXNzYWdlLmJpZ2ZpbGUgPSBlLmJpZ2ZpbGU7XG4gICAgaWYgKGUuaGFzT3duUHJvcGVydHkoXCJwYXRoXCIpKSBtZXNzYWdlLnBhdGggPSBlLnBhdGg7XG4gICAgcmV0dXJuIG1lc3NhZ2U7XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gcXVvdGFFc3RpbWF0ZSgpIHtcbiAgICBpZiAobmF2aWdhdG9yICYmIG5hdmlnYXRvci5zdG9yYWdlICYmIG5hdmlnYXRvci5zdG9yYWdlLmVzdGltYXRlKSB7XG4gICAgICBuYXZpZ2F0b3Iuc3RvcmFnZS5lc3RpbWF0ZSgpLnRoZW4oKHF1b3RhKSA9PiB7XG4gICAgICAgIGNvbnN0IHBlcmNlbnRhZ2VVc2VkID0gKChxdW90YS51c2FnZSAvIHF1b3RhLnF1b3RhKSAqIDEwMCkudG9GaXhlZCgyKTtcbiAgICAgICAgY29uc3QgcmVtYWluaW5nID0gZm9ybWF0X2J5dGVzKHF1b3RhLnF1b3RhIC0gcXVvdGEudXNhZ2UpO1xuICAgICAgICBNb2R1bGVFdmVudEVtaXR0ZXIuZW1pdChldmVudG5hbWVzLm1lc3NhZ2UsIHtcbiAgICAgICAgICBpZDogXCJxdW90YVwiLFxuICAgICAgICAgIG5hbWU6IFwiY29uc29sZVwiLFxuICAgICAgICAgIG1lc3NhZ2U6IFwieW91J3ZlIHVzZWQgXCIgKyBwZXJjZW50YWdlVXNlZCArIFwiJSBvZiB0aGUgYXZhaWxhYmxlIHN0b3JhZ2UgKFwiICsgcmVtYWluaW5nICsgXCIpLlwiLFxuICAgICAgICB9LCBfbGlzdGVuZXIpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgYXN5bmMgZnVuY3Rpb24gaW5pdFN0b3JhZ2UoKSB7XG4gICAgaWYgKG5hdmlnYXRvciAmJiBuYXZpZ2F0b3Iuc3RvcmFnZSAmJiBuYXZpZ2F0b3Iuc3RvcmFnZS5lc3RpbWF0ZSkge1xuICAgICAgYXdhaXQgY2xlYW5TdG9yYWdlKCk7XG4gICAgICBxdW90YUVzdGltYXRlKCk7XG4gICAgfSBlbHNlIE1vZHVsZUV2ZW50RW1pdHRlci5lbWl0KGV2ZW50bmFtZXMubWVzc2FnZSwge1xuICAgICAgbmFtZTogXCJlcnJvclwiLFxuICAgICAgbWVzc2FnZTogXCJubyBuYXZpZ2F0b3Igc3RvcmFnZVwiXG4gICAgfSwgdXVpZCk7XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gY3JlYXRlTG9jYWxTdHJlYW0obmFtZSwgYWNjZXB0ID0ge1xuICAgICdhcHBsaWNhdGlvbi96aXAnOiBbJy56aXAnXSxcbiAgfSkge1xuICAgIGNvbnN0IHJvb3QgPSBhd2FpdCBuYXZpZ2F0b3Iuc3RvcmFnZS5nZXREaXJlY3RvcnkoKTtcbiAgICBjb25zdCBvcHRzID0ge1xuICAgICAgdHlwZXM6IFt7XG4gICAgICAgIGRlc2NyaXB0aW9uOiAnVGVtcCBmaWxlJyxcbiAgICAgICAgYWNjZXB0OiBhY2NlcHQsXG4gICAgICB9LCBdLFxuICAgICAgY3JlYXRlOiB0cnVlXG4gICAgfTtcbiAgICBjb25zdCBmaWxlc3RyZWFtID0gYXdhaXQgcm9vdC5nZXRGaWxlSGFuZGxlKG5hbWUsIG9wdHMpO1xuICAgIGNvbnN0IHN0cmVhbWhhbmRsZSA9IGF3YWl0IGZpbGVzdHJlYW0uY3JlYXRlV3JpdGFibGUoKTtcbiAgICByZXR1cm4ge1xuICAgICAgZmlsZXN0cmVhbSxcbiAgICAgIHN0cmVhbWhhbmRsZVxuICAgIH07XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gc2NhbkNvbW1vbih6aXBuYW1lLCBvcHRpb25zID0ge30pIHtcbiAgICBwcm9wZXJ0aWVzLmVuZHJlYWRkaXIgPSBmYWxzZTtcbiAgICBpZiAocHJvcGVydGllcy56aXAgPT09IG51bGwpIHtcbiAgICAgIHppcG5hbWUgPSB6aXBuYW1lLnNwbGl0KGRpcnNlcGFyYXRvcilbMF07XG4gICAgICB6aXBuYW1lID0gKHppcG5hbWUudHJpbSgpID09PSBgYCkgPyAndGVtcCcgOiB6aXBuYW1lO1xuICAgICAgY29uc3QgdHlwZSA9IChvcHRpb25zICYmIG9wdGlvbnMudHlwZSkgPyBvcHRpb25zLnR5cGUgOiAnLnppcCc7XG4gICAgICBwcm9wZXJ0aWVzLnppcG5hbWUgPSAoKG9wdGlvbnMuemlwbmFtZSkgPyBvcHRpb25zLnppcG5hbWUgOiB6aXBuYW1lKSArIHR5cGU7IC8vXG4gICAgICBjb25zdCB6aXBpbnN0b3JhZ2UgPSBhd2FpdCBzZWFyY2hTdG9yYWdlKHByb3BlcnRpZXMuemlwbmFtZSk7XG4gICAgICBpZiAoemlwaW5zdG9yYWdlKSBwcm9wZXJ0aWVzLnppcG5hbWUgPSAnMV8nICsgcHJvcGVydGllcy56aXBuYW1lO1xuICAgICAgY29uc3Qge1xuICAgICAgICBmaWxlc3RyZWFtLFxuICAgICAgICBzdHJlYW1oYW5kbGVcbiAgICAgIH0gPSBhd2FpdCBjcmVhdGVMb2NhbFN0cmVhbShwcm9wZXJ0aWVzLnppcG5hbWUpO1xuICAgICAgcHJvcGVydGllcy5maWxlc3RyZWFtID0gZmlsZXN0cmVhbTtcbiAgICAgIHByb3BlcnRpZXMuc3RyZWFtaGFuZGxlID0gc3RyZWFtaGFuZGxlO1xuICAgICAgbGV0IHNpemUgPSAwO1xuICAgICAgcHJvcGVydGllcy5wYXJ0ID0gMDtcbiAgICAgIGF3YWl0IGluaXRaaXAoKTtcbiAgICAgIGlmICghanNTY2FuRGlyKSB7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICBKc1NjYW5EaXJcbiAgICAgICAgfSA9IGF3YWl0IGltcG9ydCgnLi4vZmlsZXMvanMtc2NhbmRpci5qcycpO1xuICAgICAgICBjb25zdCBwcm9jZXNzX2ZpbGUgPSBhc3luYyAoZW50cnksIGNhbGxiYWNrKSA9PiB7XG4gICAgICAgICAgaWYgKGFjY2VwdEZpbGUoZW50cnkpKSB7XG4gICAgICAgICAgICBwcm9wZXJ0aWVzLmNhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgICAgICAgICBhd2FpdCBwcm9jZXNzRmlsZShlbnRyeSk7XG4gICAgICAgICAgfSBlbHNlIHJlamVjdEZpbGUoZW50cnksIGNhbGxiYWNrKTtcbiAgICAgICAgfVxuICAgICAgICBqc1NjYW5EaXIgPSBKc1NjYW5EaXIocHJvY2Vzc19maWxlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBhc3luYyBmdW5jdGlvbiBzY2FuQnJvd3NlKHBpY2ssIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IGVudHJpZXMgPSAocGljayBpbnN0YW5jZW9mIEZpbGVMaXN0KSA/IEFycmF5LmZyb20ocGljaykgOiAocGljay5raW5kID09PSBcImRpcmVjdG9yeVwiKSA/IGF3YWl0IEFycmF5LmZyb21Bc3luYyhwaWNrLnZhbHVlcygpKTogKEFycmF5LmlzQXJyYXkocGljaykpID8gcGljayA6IFtwaWNrXTtcbiAgICBjb25zdCBuYW1lID0gZW50cmllc1swXS5uYW1lO1xuICAgIGxldCByZWxwYXRoID0gKHBpY2sgaW5zdGFuY2VvZiBGaWxlTGlzdCkgPyBlbnRyaWVzWzBdLndlYmtpdFJlbGF0aXZlUGF0aCA6IG51bGw7XG4gICAgcmVscGF0aCA9IChyZWxwYXRoKSA/IHJlbHBhdGguc3BsaXQoZGlyc2VwYXJhdG9yKSA6IFtgYF07XG4gICAgaWYgKHJlbHBhdGgubGVuZ3RoKSByZWxwYXRoLnBvcCgpO1xuICAgIHJlbHBhdGggPSByZWxwYXRoLmpvaW4oZGlyc2VwYXJhdG9yKVxuICAgIGNvbnN0IHBhdGggPSAocGljayBpbnN0YW5jZW9mIEZpbGVMaXN0KSA/IHJlbHBhdGggOiAocGljay5raW5kID09PSBcImRpcmVjdG9yeVwiKSA/IHBpY2submFtZSA6IGBgO1xuICAgIGF3YWl0IHNjYW5Db21tb24ocGF0aCwgb3B0aW9ucyk7XG4gICAgYXdhaXQganNTY2FuRGlyLnByb2Nlc3NFbnRyaWVzKGVudHJpZXMsIHBhdGgsICgpID0+IHtcbiAgICAgIGRpckNvbXBsZXRlKCk7XG4gICAgfSk7XG4gIH1cblxuICBhc3luYyBmdW5jdGlvbiBzY2FuSGFuZGxlKGRyb3BwZWQsIG9wdGlvbnMgPSB7fSkge1xuICAgIGF3YWl0IHNjYW5Db21tb24oZHJvcHBlZC5uYW1lLCBvcHRpb25zKTtcbiAgICBpZiAoZHJvcHBlZC5pc0RpcmVjdG9yeSA9PT0gdHJ1ZSkge1xuICAgICAgYXdhaXQganNTY2FuRGlyLnJlYWREaXJlY3RvcnkoZHJvcHBlZCwgKCkgPT4ge1xuICAgICAgICBkaXJDb21wbGV0ZSgpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChkcm9wcGVkLmlzRmlsZSA9PT0gdHJ1ZSkge1xuICAgICAgYXdhaXQganNTY2FuRGlyLnByb2Nlc3NGaWxlKGRyb3BwZWQsICgpID0+IHtcbiAgICAgICAgZGlyQ29tcGxldGUoKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGRpckNvbXBsZXRlKCkge1xuICAgIE1vZHVsZUV2ZW50RW1pdHRlci5lbWl0KGV2ZW50bmFtZXMuZW5kcmVhZGRpciwge1xuICAgICAgbmFtZTogZXZlbnRuYW1lcy5lbmRyZWFkZGlyXG4gICAgfSwgdXVpZCk7XG4gIH1cblxuICBmdW5jdGlvbiBhZGRIYW5kbGVyKGhhbmRsZXIpIHtcbiAgICBwcm9wZXJ0aWVzLmhhbmRsZXJzLnB1c2goaGFuZGxlcik7XG4gIH1cblxuICBhc3luYyBmdW5jdGlvbiBleGVjSGFuZGxlcigpIHtcbiAgICAvLyBzZXJpZVxuICAgIGlmIChwcm9wZXJ0aWVzLmhhbmRsZXJzLmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnN0IGhhbmRsZXIgPSBwcm9wZXJ0aWVzLmhhbmRsZXJzLnNoaWZ0KCk7XG4gICAgICBhd2FpdCBoYW5kbGVyKCk7XG4gICAgfVxuICAgIHJldHVybjtcbiAgfVxuICBhc3luYyBmdW5jdGlvbiBnemlwQmlnRmlsZShmaWxlLCBmaWxlcGF0aCkge1xuICAgIGlmIChwcm9wZXJ0aWVzLmd6aXBwZWQgIT09IG51bGwpIHtcbiAgICAgIGF3YWl0IGFkZEhhbmRsZXIoYXN5bmMgKCkgPT4ge1xuICAgICAgICBhd2FpdCBnemlwQmlnRmlsZShmaWxlLCBmaWxlcGF0aCk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbGV0IGR0ID0gRGF0ZS5ub3coKTtcbiAgICBmaWxlcGF0aCA9IChmaWxlcGF0aC5pbmRleE9mKGRpcnNlcGFyYXRvcikgPT09IDApID8gZmlsZXBhdGguc3Vic3RyKDEpIDogZmlsZXBhdGg7XG4gICAgLypmaWxlcGF0aCA9IGZpbGVwYXRoLnNwbGl0KGRpcnNlcGFyYXRvcik7XG4gICAgZmlsZXBhdGgucG9wKCk7XG4gICAgZmlsZXBhdGggPSBmaWxlcGF0aC5qb2luKGRpcnNlcGFyYXRvcik7Ki9cbiAgICBjb25zdCBleHQgPSBmaWxlLm5hbWUuc2xpY2UoZmlsZS5uYW1lLmxhc3RJbmRleE9mKCcuJykgKyAxKTtcbiAgICBpZiAoYWxyZWFkeV9jb21wcmVzc2VkLmhhcyhleHQpKSB7XG4gICAgICBwcm9wZXJ0aWVzLmd6aXBwZWQgPSBmaWxlO1xuICAgICAgTW9kdWxlRXZlbnRFbWl0dGVyLmVtaXQoZXZlbnRuYW1lcy5jb3VudGVyLCB7XG4gICAgICAgIG5hbWU6ICd6aXAnLFxuICAgICAgICBwYXRoOiBmaWxlcGF0aCxcbiAgICAgICAgc2l6ZTogZmlsZS5zaXplXG4gICAgICB9LCB1dWlkKTtcbiAgICAgIE1vZHVsZUV2ZW50RW1pdHRlci5lbWl0KGV2ZW50bmFtZXMuY29tcGxldGUsIHtcbiAgICAgICAgbmFtZTogZXZlbnRuYW1lcy5iaWdmaWxlLFxuICAgICAgICBiaWdmaWxlOiBmaWxlLm5hbWUsXG4gICAgICAgIHBhdGg6IGZpbGVwYXRoLFxuICAgICAgfSwgX2xpc3RlbmVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IHppcG5hbWUgPSBmaWxlLm5hbWUgKyAnLmd6JztcbiAgICAgIE1vZHVsZUV2ZW50RW1pdHRlci5lbWl0KGV2ZW50bmFtZXMuY29tcGxldGUsIHtcbiAgICAgICAgbmFtZTogZXZlbnRuYW1lcy5nemlwLFxuICAgICAgICBiaWdmaWxlOiBmaWxlLm5hbWUsXG4gICAgICAgIHBhdGg6IGZpbGVwYXRoLFxuICAgICAgICBzaXplOiBmaWxlLnNpemVcbiAgICAgIH0sIF9saXN0ZW5lcik7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGZpbGVzdHJlYW0sXG4gICAgICAgIHN0cmVhbWhhbmRsZVxuICAgICAgfSA9IGF3YWl0IGNyZWF0ZUxvY2FsU3RyZWFtKHppcG5hbWUsIHtcbiAgICAgICAgJ2FwcGxpY2F0aW9uL2d6aXAnOiBbJy5neiddLFxuICAgICAgfSk7XG4gICAgICBsZXQgcG9zID0gMDtcblxuICAgICAgY29uc3QgZ3ppcHBlZCA9IG5ldyBBc3luY0d6aXAoe1xuICAgICAgICBsZXZlbDogNixcbiAgICAgICAgZmlsZW5hbWU6IGZpbGVwYXRoXG4gICAgICB9KTtcbiAgICAgIGd6aXBwZWQub25kYXRhID0gKGVyciwgZGF0YSwgZmluYWwpID0+IHtcbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgIGNvbnNvbGUubG9nKCdnemlwIGVycicsIGVycik7XG4gICAgICAgICAgb25FcnJvcihldmVudG5hbWVzLmVycm9yZmlsZSwge1xuICAgICAgICAgICAgYmlnZmlsZTogZmlsZS5uYW1lLFxuICAgICAgICAgICAgcGF0aDogZmlsZXBhdGgsXG4gICAgICAgICAgICBzaXplOiBmaWxlLnNpemVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdHJlYW1oYW5kbGUud3JpdGUoZGF0YSwge1xuICAgICAgICAgICAgYXQ6IHBvc1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHBvcyArPSBkYXRhLmxlbmd0aDtcblxuICAgICAgICAgIGlmIChmaW5hbCkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ2ZpbmFsIEJJR0ZJTEUlJSUlJSUlJSUlJSUlJSUlJSUlJScgKyBldmVudG5hbWVzLmJpZ2ZpbGUsIGZpbGVwYXRoKVxuXG4gICAgICAgICAgICBjb25zb2xlLmxvZygndGltZXRvZ3p6aXAnLCAoRGF0ZS5ub3coKSAtIGR0KSAvIDEwMDApO1xuXG4gICAgICAgICAgICBzdHJlYW1oYW5kbGUuY2xvc2UoKTtcbiAgICAgICAgICAgIHByb3BlcnRpZXMuZ3ppcHBlZCA9IGZpbGVzdHJlYW07XG4gICAgICAgICAgICBNb2R1bGVFdmVudEVtaXR0ZXIuZW1pdChldmVudG5hbWVzLmNvdW50ZXIsIHtcbiAgICAgICAgICAgICAgbmFtZTogJ3ppcCcsXG4gICAgICAgICAgICAgIHBhdGg6IGZpbGVwYXRoLFxuICAgICAgICAgICAgICBzaXplOiBmaWxlLnNpemVcbiAgICAgICAgICAgIH0sIHV1aWQpO1xuICAgICAgICAgICAgTW9kdWxlRXZlbnRFbWl0dGVyLmVtaXQoZXZlbnRuYW1lcy5jb21wbGV0ZSwge1xuICAgICAgICAgICAgICBuYW1lOiBldmVudG5hbWVzLmJpZ2ZpbGUsXG4gICAgICAgICAgICAgIGJpZ2ZpbGU6IGZpbGUubmFtZSxcbiAgICAgICAgICAgICAgcGF0aDogZmlsZXBhdGhcbiAgICAgICAgICAgIH0sIF9saXN0ZW5lcik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgY29uc3QgY291bnQgPSBmYWxzZTtcbiAgICAgIGF3YWl0IHJlYWRGaWxlKGZpbGUsIGZpbGVwYXRoLCBnemlwcGVkLCBjb3VudCk7XG4gICAgfVxuXG5cbiAgfVxuICBhc3luYyBmdW5jdGlvbiBwYXJ0WmlwKCkge1xuICAgIHByb3BlcnRpZXMucGFydCArPSAxO1xuICAgIE1vZHVsZUV2ZW50RW1pdHRlci5lbWl0KGV2ZW50bmFtZXMuY29tcGxldGUsIHtcbiAgICAgbmFtZTogZXZlbnRuYW1lcy5lbmR6aXAsXG4gICAgICBwYXJ0OiBwcm9wZXJ0aWVzLnBhcnRcbiAgICB9LCBfbGlzdGVuZXIpO1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIHJlYWRGaWxlKGZpbGUsIGZpbGVwYXRoLCB6aXBwZWRzdHJlYW0sIGNvdW50ID0gdHJ1ZSkge1xuICAgIGNvbnN0IHJlYWRlciA9IGZpbGUuc3RyZWFtKCkuZ2V0UmVhZGVyKCk7XG4gICAgbGV0IHBhdXNlID0gZmFsc2U7XG4gICAgLyogIG9uQmFja3ByZXNzdXJlKHppcHBlZHN0cmVhbSwgdGhpcy5zdHJlYW1oYW5kbGUsIHNob3VsZF9hcHBseV9iYWNrcHJlc3N1cmUgPT4ge1xuICAgICAgICBpZiAoc2hvdWxkX2FwcGx5X2JhY2twcmVzc3VyZSkgcGF1c2UgPSB0cnVlO1xuICAgICAgICBlbHNlIGlmIChwYXVzZSkgcGF1c2UgPSBmYWxzZTtcbiAgICAgIH0pOyovXG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgZG9uZSxcbiAgICAgICAgdmFsdWVcbiAgICAgIH0gPSBhd2FpdCByZWFkZXIucmVhZCgpO1xuICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgemlwcGVkc3RyZWFtLnB1c2gobmV3IFVpbnQ4QXJyYXkoMCksIHRydWUpO1xuICAgICAgICBpZiAoY291bnQgPT09IHRydWUpIE1vZHVsZUV2ZW50RW1pdHRlci5lbWl0KGV2ZW50bmFtZXMuY291bnRlciwge1xuICAgICAgICAgIG5hbWU6ICd6aXAnLFxuICAgICAgICAgIHBhdGg6IGZpbGVwYXRoLFxuICAgICAgICAgIHNpemU6ICh6aXBwZWRzdHJlYW0uc2l6ZSkgPyB6aXBwZWRzdHJlYW0uc2l6ZSA6IGZpbGUuc2l6ZVxuICAgICAgICB9LCB1dWlkKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICB6aXBwZWRzdHJlYW0ucHVzaCh2YWx1ZSk7XG4gICAgfVxuICB9XG5cbiAgYXN5bmMgZnVuY3Rpb24gemlwU3RyZWFtKGZpbGUsIGZpbGVwYXRoKSB7XG4gICAgY29uc3QgZXh0ID0gZmlsZXBhdGguc2xpY2UoZmlsZXBhdGgubGFzdEluZGV4T2YoJy4nKSArIDEpO1xuICAgIGNvbnN0IGlzY29tcHJlc3NlZCA9IGFscmVhZHlfY29tcHJlc3NlZC5oYXMoZXh0KTtcbiAgICBjb25zdCB6aXBwZWRzdHJlYW0gPSAoaXNjb21wcmVzc2VkKSA/IG5ldyBaaXBQYXNzVGhyb3VnaChmaWxlcGF0aCkgOiBmaWxlLnNpemUgPiBvcHRpb25zLmxhcmdlZmlsZSA/XG4gICAgICBuZXcgQXN5bmNaaXBEZWZsYXRlKGZpbGVwYXRoLCB7XG4gICAgICAgIGxldmVsOiA2LFxuICAgICAgfSkgOiBuZXcgWmlwRGVmbGF0ZShmaWxlcGF0aCwge1xuICAgICAgICBsZXZlbDogNlxuICAgICAgfSk7XG4gICAgcHJvcGVydGllcy56aXAuYWRkKHppcHBlZHN0cmVhbSk7XG4gICAgYXdhaXQgcmVhZEZpbGUoZmlsZSwgZmlsZXBhdGgsIHppcHBlZHN0cmVhbSk7XG4gIH1cblxuICBhc3luYyBmdW5jdGlvbiBhZGRGaWxlVG9aaXBTdHJlYW0oZmlsZSwgZmlsZXBhdGgsIGNvdW50ID0gdHJ1ZSkge1xuICAgIGlmIChjb3VudCA9PT0gdHJ1ZSkgTW9kdWxlRXZlbnRFbWl0dGVyLmVtaXQoZXZlbnRuYW1lcy5jb3VudGVyLCB7XG4gICAgICBuYW1lOiAnc2NhbicsXG4gICAgICBwYXRoOiBmaWxlcGF0aCxcbiAgICAgIHNpemU6IGZpbGUuc2l6ZVxuICAgIH0sIHV1aWQpO1xuICAgIHByb3BlcnRpZXMuZm9sbG93ID0gbnVsbDtcbiAgICAvLyBjaGVjayBmaWxlIHNpemUgPiBtYXggcG9zdCBzaXplXG4gICAgaWYgKGZpbGUuc2l6ZSA+PSBNQVhTSVpFKSB7XG4gICAgICBnemlwQmlnRmlsZShmaWxlLCBmaWxlcGF0aCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGNoZWNrIHppcCBmaWxlIHNpemUgPiB0b3RhbCB6aXAgc2l6ZVxuICAgICAgcHJvcGVydGllcy5zaXpldG96aXAgKz0gZmlsZS5zaXplO1xuICAgICAgaWYgKHByb3BlcnRpZXMuc2l6ZXRvemlwID49IE1BWFNJWkUpIHtcbiAgICAgICAgcHJvcGVydGllcy5mb2xsb3cgPSBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgYXdhaXQgemlwU3RyZWFtKGZpbGUsIGZpbGVwYXRoKTtcbiAgICAgICAgfVxuICAgICAgICBwYXJ0WmlwKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhd2FpdCB6aXBTdHJlYW0oZmlsZSwgZmlsZXBhdGgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGFjY2VwdEZpbGUoZW50cnkpIHtcbiAgICBjb25zdCBmaWxlcGF0aCA9IGVudHJ5Lm5hbWU7XG4gICAgY29uc3QgZXh0ID0gZmlsZXBhdGguc2xpY2UoZmlsZXBhdGgubGFzdEluZGV4T2YoJy4nKSArIDEpO1xuICAgIHJldHVybiBhY2NlcHQuaW5jbHVkZXMoZXh0KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlamVjdEZpbGUoZmlsZSwgY2FsbGJhY2sgPSBudWxsKSB7XG4gICAgY29uc3QgcGF0aCA9IChmaWxlLmZ1bGxQYXRoKSA/IGZpbGUuZnVsbFBhdGggOiBmaWxlLndlYmtpdFJlbGF0aXZlUGF0aDtcbiAgICBwcm9wZXJ0aWVzLmNvdW50ZXIucmVqZWN0ICs9IDE7XG4gICAgTW9kdWxlRXZlbnRFbWl0dGVyLmVtaXQoZXZlbnRuYW1lcy5yZWplY3QsIHtcbiAgICAgIG5hbWU6IGV2ZW50bmFtZXMucmVqZWN0LFxuICAgICAgcGF0aDogcGF0aCxcbiAgICB9LCBfbGlzdGVuZXIpO1xuICAgIGlmIChjYWxsYmFjayAhPT0gbnVsbCkgY2FsbGJhY2soKTtcbiAgfVxuICBhc3luYyBmdW5jdGlvbiBwcm9jZXNzRmlsZShlbnRyeSkge1xuICAgIGNvbnN0IHBhdGggPSAoZW50cnkuZnVsbFBhdGgpID8gZW50cnkuZnVsbFBhdGggOiBlbnRyeS53ZWJraXRSZWxhdGl2ZVBhdGg7XG4gICAgZW50cnkuZmlsZShhc3luYyBmaWxlID0+IHtcbiAgICAgIGF3YWl0IGFkZEZpbGVUb1ppcFN0cmVhbShmaWxlLCBwYXRoKTtcbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG9uRXJyb3IoYWN0aW9uLCBtZXNzYWdlID0gbnVsbCkge1xuICAgIG1lc3NhZ2UgPSAobWVzc2FnZSkgPyBtZXNzYWdlIDoge307XG4gICAgc3dpdGNoIChhY3Rpb24pIHtcbiAgICAgIGNhc2UgZXZlbnRuYW1lcy5pbml0OlxuICAgICAgICBtZXNzYWdlLm5hbWUgPSBldmVudG5hbWVzLmluaXQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBldmVudG5hbWVzLmVycm9yZmlsZTpcbiAgICAgICAgY29uc29sZS5sb2coJ2Vycm9yZmlsZScsIG1lc3NhZ2UpO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgbWVzc2FnZS5uYW1lID0gZXZlbnRuYW1lcy5mb2xsb3c7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBNb2R1bGVFdmVudEVtaXR0ZXIuZW1pdChldmVudG5hbWVzLmVycm9yLCBtZXNzYWdlLCBfbGlzdGVuZXIpO1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIHNlYXJjaFN0b3JhZ2Uoc2VhcmNoKSB7XG4gICAgY29uc3QgZW50cnkgPSBhd2FpdCBuYXZpZ2F0b3Iuc3RvcmFnZS5nZXREaXJlY3RvcnkoKTtcbiAgICBmb3IgYXdhaXQgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBlbnRyeS5lbnRyaWVzKCkpIHtcbiAgICAgIGlmIChzZWFyY2ggPT09IGtleSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBhc3luYyBmdW5jdGlvbiBjbGVhblN0b3JhZ2UoZW50cnkgPSBudWxsKSB7XG4gICAgZW50cnkgPSAoZW50cnkpID8gZW50cnkgOiBhd2FpdCBuYXZpZ2F0b3Iuc3RvcmFnZS5nZXREaXJlY3RvcnkoKTtcbiAgICBmb3IgYXdhaXQgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBlbnRyeS5lbnRyaWVzKCkpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGF3YWl0IGVudHJ5LnJlbW92ZUVudHJ5KGtleSk7XG4gICAgICAgIGNvbnNvbGUubG9nKCcgU3VjY2VzcyByZW1vdmUgc3RvcmFnZSAnLCBrZXkpO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5sb2coJyBlcnJvciByZW1vdmUgc3RvcmFnZSAnICsga2V5LCBlcnJvcik7XG4gICAgICB9XG4gICAgfVxuXG4gIH1cblxuICBhc3luYyBmdW5jdGlvbiBlbmRGZXRjaChtZXNzYWdlLCBjbGVhbiA9IGZhbHNlKSB7XG4gICAgbWVzc2FnZS5uYW1lID0gZXZlbnRuYW1lcy50ZXJtaW5hdGU7XG4gICAgaWYgKHByb3BlcnRpZXMuZm9sbG93KSB7XG4gICAgICBwcm9wZXJ0aWVzLnN0cmVhbWhhbmRsZSA9IGF3YWl0IHByb3BlcnRpZXMuZmlsZXN0cmVhbS5jcmVhdGVXcml0YWJsZSgpO1xuICAgICAgbWVzc2FnZS5uYW1lID0gZXZlbnRuYW1lcy5mb2xsb3c7XG4gICAgICBNb2R1bGVFdmVudEVtaXR0ZXIuZW1pdChldmVudG5hbWVzLmZvbGxvdywgbWVzc2FnZSwgX2xpc3RlbmVyKVxuICAgICAgYXdhaXQgaW5pdFppcCgpO1xuICAgICAgcmV0dXJuO1xuICAgIH0gZWxzZSBpZiAobWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcImJpZ2ZpbGVcIikgJiYgbWVzc2FnZS5iaWdmaWxlICE9PSBmYWxzZSkge1xuICAgICAgcHJvcGVydGllcy5nemlwcGVkID0gbnVsbDtcblxuICAgICAgaWYgKHByb3BlcnRpZXMuaGFuZGxlcnMubGVuZ3RoID4gMCkge1xuICAgICAgICBtZXNzYWdlLm5hbWUgPSBldmVudG5hbWVzLmZvbGxvdztcbiAgICAgICAgTW9kdWxlRXZlbnRFbWl0dGVyLmVtaXQoZXZlbnRuYW1lcy5mb2xsb3csIG1lc3NhZ2UsIF9saXN0ZW5lcik7XG4gICAgICAgIGNvbnNvbGUubG9nKCcgaGFuZGxlcnMgdG8gZG8nLCBtZXNzYWdlKTtcbiAgICAgICAgaWYgKHByb3BlcnRpZXMuaGFuZGxlcnMubGVuZ3RoID4gMCkgYXdhaXQgZXhlY0hhbmRsZXIoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH0gZWxzZSBwcm9wZXJ0aWVzLnppcCA9IG51bGw7XG4gICAgTW9kdWxlRXZlbnRFbWl0dGVyLmVtaXQoZXZlbnRuYW1lcy5jb21wbGV0ZSwgbWVzc2FnZSwgX2xpc3RlbmVyKTtcbiAgfVxuXG4gIGFzeW5jIGZ1bmN0aW9uIHNlbmRDaHVuayhwYXRoLCBzdGFydCA9IDAsIGNodW5rbnVtID0gMCwgY2h1bmtzaXplID0gTUFYU0laRSkge1xuICAgIGNvbnNvbGUubG9nKCdzZW5kIGNodW5rICcsIHByb3BlcnRpZXMuZ3ppcHBlZClcbiAgICBjb25zdCBmaWxlID0gYXdhaXQgcHJvcGVydGllcy5nemlwcGVkLmdldEZpbGUoKTtcbiAgICBjb25zdCBlbmQgPSBNYXRoLm1pbihzdGFydCArIGNodW5rc2l6ZSwgZmlsZS5zaXplKTtcbiAgICBpZiAoZW5kID09PSBmaWxlLnNpemUpIHtcbiAgICAgYXdhaXQgc2VuZFppcEZpbGUoZmlsZSwgcGF0aCwgbnVsbCwgdHJ1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHBhcnRmaWxlID0gZmlsZS5zbGljZShzdGFydCwgZW5kKTtcbiAgICAgIHBhcnRmaWxlLm5hbWUgPSBjaHVua251bSArICdfJyArIGZpbGUubmFtZTtcbiAgICAgIGF3YWl0IHNlbmRaaXBmaWxlKHBhcnRmaWxlLCBwYXRoLCBhc3luYyAoKSA9PiB7XG4gICAgICAgIHN0YXJ0ICs9IGVuZDtcbiAgICAgICAgY2h1bmtudW0rKztcblxuICAgICAgICBpZiAoc3RhcnQgPD0gZmlsZS5zaXplKSBhd2FpdCBzZW5kQ2h1bmsocGF0aCwgc3RhcnQsIGNodW5rbnVtLCBjaHVua3NpemUpO1xuICAgICAgfSwgdHJ1ZSlcbiAgICB9XG4gICAgcmV0dXJuIGNodW5rbnVtO1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIGdldEZpbGUoZmlsZXN0cmVhbSA9IG51bGwpIHtcbiAgICBmaWxlc3RyZWFtID0gKGZpbGVzdHJlYW0gPT09IG51bGwpID8gcHJvcGVydGllcy5maWxlc3RyZWFtIDogZmlsZXN0cmVhbTtcbiAgICBjb25zdCBmaWxlID0gYXdhaXQgZmlsZXN0cmVhbS5nZXRGaWxlKCk7XG4gICAgcmV0dXJuIGZpbGU7XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gc2VuZFppcEZpbGUoZmlsZSwgcGF0aCwgY2FsbGJhY2tjaHVuayA9IG51bGwsIGJpZ2ZpbGUgPSBmYWxzZSkge1xuICAgIGNvbnN0IG1lc3NhZ2UgPSB7XG4gICAgICBuYW1lOiBldmVudG5hbWVzLnBlbmRpbmcsXG4gICAgICBwYXRoOiBwYXRoXG4gICAgfVxuICAgIGlmIChiaWdmaWxlKSBtZXNzYWdlLmJpZ2ZpbGUgPSBmaWxlLm5hbWU7XG4gICAgTW9kdWxlRXZlbnRFbWl0dGVyLmVtaXQoZXZlbnRuYW1lcy5jb21wbGV0ZSwgbWVzc2FnZSwgX2xpc3RlbmVyKTtcbiAgICBjb25zdCBmb3JtZGF0YSA9IG5ldyBGb3JtRGF0YSgpO1xuICAgIHBhdGggPSBwYXRoICsgKChwYXRoLnNsaWNlKC0xKSA9PT0gZGlyc2VwYXJhdG9yKSA/IGBgIDogZGlyc2VwYXJhdG9yKSArIGZpbGUubmFtZTtcbiAgICBmb3JtZGF0YS5hcHBlbmQoJ3BhdGgnLCBwYXRoKTtcbiAgICBmb3JtZGF0YS5hcHBlbmQoJ2ZpbGUnLCBmaWxlLCBmaWxlLm5hbWUpO1xuICAgIGlmIChwcm9wZXJ0aWVzLnBhcnQpIGZvcm1kYXRhLmFwcGVuZCgncGFydCcsIHByb3BlcnRpZXMucGFydCk7XG4gICAgZWxzZSBpZiAoY2FsbGJhY2tjaHVuayAhPT0gbnVsbCkgZm9ybWRhdGEuYXBwZW5kKCdpc2NodW5rJywgdHJ1ZSk7XG4gICAgZmV0Y2gob3B0aW9ucy51cGxvYWR1cmwsIHtcbiAgICAgIC8vICBtb2RlOiAnY29ycycsXG4gICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgY3JlZGVudGlhbHM6IFwiaW5jbHVkZVwiLFxuICAgICAgYm9keTogZm9ybWRhdGEsXG4gICAgfSkudGhlbihhc3luYyAocmVzcG9uc2UpID0+IHtcbiAgICAgIGNvbnNvbGUubG9nKCdyZXNwb25zZS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0nLCByZXNwb25zZSk7XG4gICAgICBjb25zb2xlLmxvZygnY2FsbGJhY2tjaHVuay0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0nLCBjYWxsYmFja2NodW5rKVxuICAgICAgbWVzc2FnZS5wYXRoID0gcGF0aDtcbiAgICAgIGlmIChyZXNwb25zZS5zdGF0dXMgIT09IDIwMCkge1xuICAgICAgICBvbkVycm9yKGV2ZW50bmFtZXMuZXJyb3IsIG1lc3NhZ2UpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoY2FsbGJhY2tjaHVuayAhPT0gbnVsbCkgeyBjb25zb2xlLmxvZygnY2FsbGJhY2tjaHVuayBub3QgbnVsbCcpXG4gICAgICAgIGF3YWl0IGNhbGxiYWNrY2h1bmsoKTtcbiAgICAgIH0gZWxzZSBhd2FpdCBlbmRGZXRjaChtZXNzYWdlKTtcbiAgICB9KTtcbiAgfVxuICByZXR1cm4ge1xuICAgIHV1aWQsXG4gICAgZXZlbnRuYW1lcyxcbiAgICBzY2FuQnJvd3NlLFxuICAgIHNjYW5IYW5kbGUsXG4gICAgcXVvdGFFc3RpbWF0ZVxuICB9XG59Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/modules/files/js-dirtozip.js\n")}}]);