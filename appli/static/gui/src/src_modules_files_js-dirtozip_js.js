/*! For license information please see src_modules_files_js-dirtozip_js.js.LICENSE.txt */
"use strict";(self.webpackChunk=self.webpackChunk||[]).push([["src_modules_files_js-dirtozip_js"],{"./src/modules/files/js-dirtozip.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   JsDirToZip: () => (/* binding */ JsDirToZip)\n/* harmony export */ });\n/* harmony import */ var _modules_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../modules/utils.js */ \"./src/modules/utils.js\");\n/* harmony import */ var fflate__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! fflate */ \"./node_modules/fflate/esm/browser.js\");\n\n\n\n\nconst already_compressed = new Set([\n  'zip', 'gz', 'png', 'jpg', 'jpeg', 'pdf', 'doc', 'docx', 'ppt', 'pptx',\n  'xls', 'xlsx', 'heic', 'heif', '7z', 'bz2', 'rar', 'gif', 'webp', 'webm',\n  'mp4', 'mov', 'mp3', 'aifc'\n]);\nconst accept = '.tsv,.png,.jpg, .jpeg,.zip,.gz,.7z,.bz2';\nlet instance = null;\nconst MAXSIZE = 1073741824; ////maxfilesize: 1073741824,\nclass JsDirToZip {\n  _events = {};\n  eventnames = {\n    ready: 'ready',\n    endzip: 'endzip',\n    complete: 'complete',\n    endreaddir: 'endreaddir',\n    gzip: 'gzipfile',\n    sendfile: 'sendfile',\n    bigfile: 'bigfile',\n    terminate: 'terminate',\n    pending: 'pending',\n    getfile: 'getzipfile',\n    counter: 'counter',\n    message: 'message',\n    error: 'error'\n  }\n  zip = null;\n  zipname = null;\n  filestream = null;\n  streamhandle = null;\n  gzipped = null;\n  sizetozip = 0;\n  part = 0;\n  continue = null;\n  counter = {\n    scan: 0,\n    zip: 0\n  }\n  constructor(options = {}) {\n    if (instance) return instance;\n    const defaultOptions = {\n      uploadurl: '/gui/files/upload',\n      largefile: 4194304,\n      accept: accept.split(',')\n    }\n    this.options = { ...defaultOptions,\n      ...options\n    };\n    console.log('thisopts', this.options)\n\n    this.init();\n\n    instance = this;\n    return instance;\n  }\n  init() {\n    (0,_modules_utils_js__WEBPACK_IMPORTED_MODULE_0__.add_custom_events)(this);\n    this.initStorage();\n    this.on(this.eventnames.ready, () => {\n      console.log('ready')\n    });\n  }\n  reset() {\n    console.log('reset');\n    this.zip = null;\n    this.zipname = null;\n    this.filestream = null;\n    this.streamhandle = null;\n    this.gzipped = null;\n    this.sizetozip = 0;\n    this.part = 0;\n    this.continue = null;\n    this.initStorage();\n  }\n  async initZip() {\n    console.log('initzip')\n    const self = this;\n    this.pos = 0;\n    this.sizetozip = 0;\n    this.zip = new fflate__WEBPACK_IMPORTED_MODULE_1__.Zip((error, chunk, final) => {\n      if (error) {\n        console.log('error', error);\n        return false;\n      } else {\n        self.streamhandle.write(chunk, {\n          at: self.pos\n        });\n        self.pos += chunk.length;\n        if (final) {\n          self.streamhandle.close();\n          console.log('final-----------------------------*******************************-', self.pos);\n\n        }\n\n      }\n    });\n    /*  const fflToRS = fflateStream =>\n        new ReadableStream({\n          start(controller) {\n            // Push to the ReadableStream whenever the fflate\n            // stream gets data\n            fflateStream.ondata = (err, data, final) => {\n              if (err) controller.error(err);\n              else {\n                controller.enqueue(data);\n                // End the stream on the final chunk\n                if (final) {\n                  controller.close();\n                  console.log('final-----------------------------******************************-');\n                }\n              }\n            }\n          },\n          cancel() {\n            // We can stop working if the stream is cancelled\n            // This may happen if the user cancels the download\n            fflateStream.terminate();\n          }\n        });\n      const zipstream = fflToRS(this.zip);\n      zipstream.pipeTo(self.streamhandle);*/\n    if (this.continue) await this.continue();\n    else {\n      // events\n      this.on(this.eventnames.endzip, (e) => {\n        if (!e.bigfile && this.zip) {\n\n          this.zip.end();\n          console.log('zipend', this.zip)\n          console.log('fstrem', this.filestream)\n        } else if (e.bigfile && this.gzipped) console.log('-------------------------gzipped end ', this.gzipped)\n        const message = {\n          name: this.eventnames.sendfile\n        };\n        if (e.part) {\n          message[\"part\"] = e.part;\n        } else this.part = 0;\n        if (e.hasOwnProperty(\"bigfile\")) message[\"bigfile\"] = e.bigfile;\n        if (e.hasOwnProperty(\"path\")) message[\"path\"] = e.path;\n        console.log('endzip%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%', e)\n        this.emit(this.eventnames.complete, message);\n      });\n\n      this.on(this.eventnames.sendfile, async (e) => {\n        console.log('eventsendfile', e)\n        let file = (e.bigfile) ? await this.getFile(this.gzipped): await this.getFile();\n        console.log('sendfile', file)\n        /* if (e.bigfile) this.sendChunk((e.path ? e.path : ''));\n          else */\n        this.sendZipFile(file, (e.path ? e.path : ''), null, (e.bigfile ? e.bigfile : false));\n      });\n      this.on(this.eventnames.bigfile, (e) => {\n        console.log('onsendchunk', e)\n        this.sendChunk((e.path ? e.path : ''));\n      });\n      this.on(this.eventnames.endreaddir, (e) => {\n        this.endreaddir = true;\n        console.log('endreaddir', this.counter)\n        if (this.counter.scan === this.counter.zip) {\n          console.log(this.endreaddir, this.counter)\n          console.log('endzip', this.zip)\n          this.emit(this.eventnames.complete, {\n            name: this.eventnames.endzip\n          });\n        }\n      });\n      this.on(this.eventnames.counter, async (e) => {\n        this.counter[e.name] += 1;\n        if (this.counter.scan === this.counter.zip) console.log('this end', this.endreaddir)\n\n        if (e.name === 'zip' && this.callback) await this.callback();\n      });\n    }\n  }\n  async initStorage() {\n    if (navigator && navigator.storage && navigator.storage.estimate) {\n      await this.cleanStorage();\n      this.emit(this.eventnames.ready);\n      navigator.storage.estimate().then((quota) => {\n        const percentageUsed = (quota.usage / quota.quota) * 100;\n        const remaining = quota.quota - quota.usage;\n        this.emit(this.eventnames.message, {\n          name: \"console\",\n          message: \"You can write up to \" + remaining + \" more bytes.\"\n        });\n        this.emit(this.eventnames.message, {\n          name: \"console\",\n          message: \"you've used \" + percentageUsed + \"% of the available storage.\"\n        });\n      });\n    } else this.emit(this.eventnames.message, {\n      name: \"error\",\n      message: \"no navigator storage\"\n    });\n  }\n  async createLocalStream(name, accept = {\n    'application/zip': ['.zip'],\n  }) {\n    const root = await navigator.storage.getDirectory();\n    const opts = {\n      types: [{\n        description: 'Temp file',\n        accept: accept,\n      }, ],\n      create: true\n    };\n    const filestream = await root.getFileHandle(name, opts);\n    const streamhandle = await filestream.createWritable();\n    return {\n      filestream,\n      streamhandle\n    };\n  }\n\n  async scanHandle(dir, options = {}) {\n    console.log('this.zip', this.zip)\n    if (this.zip === null) {\n      const type = (options && options.type) ? options.type : '.zip';\n      this.zipname = ((options.zipname) ? options.zipname : dir.name) + type; //\n\n      const {\n        filestream,\n        streamhandle\n      } = await this.createLocalStream(this.zipname);\n      console.log('streamhandle', streamhandle)\n      this.filestream = filestream;\n      this.streamhandle = streamhandle;\n      let size = 0;\n      this.part = 0;\n      await this.initZip();\n      const zip = this.zip;\n      if (!this.jsScanDir) {\n        const {\n          JsScanDir\n        } = await __webpack_require__.e(/*! import() */ \"src_modules_files_js-scandir_js\").then(__webpack_require__.bind(__webpack_require__, /*! ../files/js-scandir.js */ \"./src/modules/files/js-scandir.js\"));\n        this.jsScanDir = new JsScanDir();\n      }\n      this.jsScanDir.processFile = async (entry, callback) => {\n        this.callback = callback;\n        await this.processFile(entry);\n\n      };\n    }\n    this.endreaddir = false;\n    this.counter.scan = this.counter.zip = 0;\n    await this.jsScanDir.readDirectory(dir, () => {\n      this.emit(this.eventnames.endreaddir);\n    });\n\n  }\n  async sendBigFile(file, filepath) {\n    console.log('sendbigfilepath', filepath)\n    this.dt = Date.now();\n    filepath = (filepath.indexOf('/') === 0) ? filepath.substr(1) : filepath;\n    /*let filepath = file.webkitRelativePath;\n    filepath = (filepath === '') ? dirname + '/' + file.name : filepath;*/\n    const ext = file.name.slice(file.name.lastIndexOf('.') + 1);\n    if (already_compressed.has(ext)) {\n      this.gzipped = file;\n      this.emit(this.eventnames.counter, {\n        name: 'zip',\n        filepath: filepath,\n        size: file.size\n      });\n      this.emit(this.eventnames.complete, {\n        name: this.eventnames.bigfile,\n        bigfile: filepath\n      });\n    } else {\n      this.emit(this.eventnames.gzip, {\n        name: this.eventnames.gzip,\n        bigfile: filepath,\n        size: file.size\n      });\n      let zipname = file.name.split(ext);\n      zipname.pop();\n      zipname = zipname.join(ext) + 'gz';\n      console.log('bigfile ext=' + ext, zipname)\n      const {\n        filestream,\n        streamhandle\n      } = await this.createLocalStream(zipname, {\n        'application/gzip': ['.gz'],\n      });\n      let pos = 0;\n      const selfi = this;\n      const gzipped = new fflate__WEBPACK_IMPORTED_MODULE_1__.Gzip({\n        level: 9,\n        filename: filepath\n      });\n      gzipped.ondata = (data, final) => {\n        if (final) {\n          console.log('final BIGFILE%%%%%%%%%%%%%%%%%%%%' + selfi.eventnames.bigfile, filepath)\n          selfi.emit(selfi.eventnames.complete, {\n            name: selfi.eventnames.bigfile,\n            bigfile: filepath\n\n          });\n\n          streamhandle.close();\n          console.log('timetozip', (Date.now() - this.dt) / 1000)\n          selfi.gzipped = filestream;\n          console.log('big file *******************' + filepath, selfi.gzipped);\n\n        } else {\n          streamhandle.write(data, {\n            at: pos\n          });\n          pos += data.length;\n        }\n      };\n      await this.readFile(file, filepath, gzipped);\n    }\n\n\n  }\n  async partZip() {\n    this.part += 1;\n    this.emit(this.eventnames.complete, {\n      name: this.eventnames.endzip,\n      part: this.part\n    });\n  }\n  async readFile(file, filepath, zippedstream) {\n    const self = this;\n    const reader = file.stream().getReader();\n    let pause = false;\n    /*  onBackpressure(zippedstream, this.streamhandle, should_apply_backpressure => {\n        if (should_apply_backpressure) pause = true;\n        else if (pause) pause = false;\n      });*/\n    while (true) {\n      const {\n        done,\n        value\n      } = await reader.read();\n      if (done) {\n        zippedstream.push(new Uint8Array(0), true);\n        self.emit(self.eventnames.counter, {\n          name: 'zip',\n          filepath: filepath,\n          size: (zippedstream.size) ? zippedstream.size : file.size\n        });\n        break;\n      }\n      zippedstream.push(value);\n    }\n  }\n  async zipStream(file, filepath) {\n    const self = this;\n    const ext = filepath.slice(filepath.lastIndexOf('.') + 1);\n    const iscompressed = already_compressed.has(ext);\n    const zippedstream = (iscompressed) ? new fflate__WEBPACK_IMPORTED_MODULE_1__.ZipPassThrough(filepath) : file.size > this.options.largefile ?\n      new fflate__WEBPACK_IMPORTED_MODULE_1__.AsyncZipDeflate(filepath, {\n        level: 6,\n      }) : new fflate__WEBPACK_IMPORTED_MODULE_1__.ZipDeflate(filepath, {\n        level: 6\n      });\n    this.zip.add(zippedstream);\n    /*zippedstream.ondata = (err, data, final) => {\n      if (err) {\n        console.log('err async', err);\n      } else if (final === true) {\n        console.log('final', zippedstream)\n        self.emit(self.eventnames.counter, {\n          name: 'zip',\n          filepath: filepath,\n          size: (zippedstream.size) ? zippedstream.size : file.size\n        });\n\n      } else {\n        self.streamhandle.write(data, {\n          at: self.pos\n        });\n        self.pos += data.length;\n      }\n    }*/\n    //  console.log(zippedstream instanceof(AsyncZipDeflate), zippedstream.ondata);\n    await this.readFile(file, filepath, zippedstream);\n  }\n  async processFile(entry) {\n    const self = this;\n    const filepath = entry.fullPath;\n    const ext = filepath.slice(filepath.lastIndexOf('.') + 1);\n    if (this.options.accept.includes(ext)) {\n      console.log('reject', filepath);\n      return;\n    }\n    if (entry.isDirectory) {\n      console.log('zipdir', this.callback)\n      if (this.callback !== null) await this.callback();\n    } else {\n      entry.file(async file => {\n        this.emit(this.eventnames.counter, {\n          name: 'scan',\n          filepath: filepath,\n          size: file.size\n        });\n        this.continue = null;\n        // check file size > max post size\n        if (file.size >= MAXSIZE) {\n          await this.sendBigFile(file, filepath);\n        } else {\n          // check zip file size > total zip size\n          this.sizetozip += file.size;\n          if (this.sizetozip >= MAXSIZE) {\n            this.continue = async () => {\n              await this.zipStream(file, filepath);\n            }\n            this.partZip();\n          } else {\n            await this.zipStream(file, filepath);\n          }\n        }\n      });\n\n    }\n  }\n  onError() {\n    this.cleanStorage();\n    this.emit(this.eventnames.error, {\n      name: \"reload\"\n    });\n  }\n  async cleanStorage(entry = null) {\n    entry = (entry) ? entry : await navigator.storage.getDirectory();\n    for await (const [key, value] of entry.entries()) {\n      console.log('keyval', {\n        key,\n        value\n      });\n      await entry.removeEntry(key);\n    }\n\n  }\n\n  async endFetch(message, clean = false) {\n    message.name = this.eventnames.terminate;\n    if (message.hasOwnProperty(\"bigfile\") && message.bigfile !== \"\" &&\n      message.bigfile !== false && message.bigfile !== null) {\n      message[\"bigfile\"] = this.gzipped.name;\n      this.gzipped = null;\n    } else {\n      if (this.continue) {\n        this.streamhandle = await this.filestream.createWritable();\n        await this.initZip();\n      } else this.reset();\n      if (this.continue === null && clean === true) await this.cleanStorage();\n    }\n    this.emit(this.eventnames.complete, message);\n    console.log('continue', this.continue)\n  }\n\n  async sendChunk(path, start = 0, chunknum = 0, chunksize = MAXSIZE) {\n    console.log('send chunk ', this.gzipped)\n    console.log('chunkpath', path)\n    const file = (this.gzipped) ? await this.getFile(this.gzipped): await this.getFile();\n    console.log('file', file)\n    path = path.split('/');\n    path.pop();\n    path = path.join('/');\n    const end = Math.min(start + chunksize, file.size);\n    console.log('end---', end)\n    if (end === file.size) {\n\n      this.sendZipFile(file, path, null, true);\n    } else {\n      const partfile = file.slice(start, end);\n      partfile.name = chunknum + '_' + file.name;\n      this.sendZipfile(partfile, path, () => {\n        start += end;\n        chunknum++;\n\n        if (start <= file.size) this.sendChunk(path, start, chunknum, chunksize);\n      }, true)\n    }\n    return chunknum;\n  }\n  async getFile(filestream = null) {\n    filestream = (filestream === null) ? this.filestream : filestream;\n    const file = await filestream.getFile();\n    return file;\n  }\n  async sendZipFile(file, path, callbackchunk = null, isbigfile = false) {\n    console.log('sendzipfile------------_______________________' + isbigfile, file)\n    const message = (isbigfile) ? {\n      bigfile: file.name\n    } : {};\n    this.emit(this.eventnames.pending, message);\n    console.log('file', file)\n    console.log('callbackchunk---sendzip', callbackchunk)\n    const formdata = new FormData();\n    formdata.append('tag', 'ecotaxa_import');\n    formdata.append('path', path + file.name);\n    formdata.append('file', file, file.name);\n    if (this.part) formdata.append('part', this.part);\n    else if (callbackchunk !== null) formdata.append('ischunk', true);\n    fetch(this.options.uploadurl, {\n      //  mode: 'cors',\n      method: \"POST\",\n      credentials: \"include\",\n      body: formdata,\n    }).then(async (response) => {\n      console.log('response----------------------', response);\n      console.log('callbackchunk-------------------------------', callbackchunk)\n      if (callbackchunk !== null) {\n        await callbackchunk();\n      } else await this.endFetch(message);\n    });\n  }\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvbW9kdWxlcy9maWxlcy9qcy1kaXJ0b3ppcC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBYTtBQUltQjs7QUFRaEI7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDckI7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxvRUFBaUI7QUFDckI7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQix1Q0FBRztBQUN0QjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBLDhFQUE4RTs7QUFFOUU7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxRQUFRLCtMQUFnQztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0VBQXdFO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLDBCQUEwQix3Q0FBSTtBQUM5QjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxXQUFXOztBQUVYO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTyxFQUFFO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxrREFBYztBQUM1RCxVQUFVLG1EQUFlO0FBQ3pCO0FBQ0EsT0FBTyxRQUFRLDhDQUFVO0FBQ3pCO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVULFFBQVE7QUFDUjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUixLQUFLO0FBQ0w7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy9tb2R1bGVzL2ZpbGVzL2pzLWRpcnRvemlwLmpzPzg1MzgiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuaW1wb3J0IHtcbiAgYWRkX2N1c3RvbV9ldmVudHMsXG4gIGZldGNoU2V0dGluZ3Ncbn0gZnJvbSAnLi4vLi4vbW9kdWxlcy91dGlscy5qcyc7XG5cbmltcG9ydCB7XG4gIEd6aXAsXG4gIFppcCxcbiAgQXN5bmNaaXBEZWZsYXRlLFxuICBaaXBQYXNzVGhyb3VnaCxcbiAgWmlwRGVmbGF0ZSxcbn0gZnJvbSAnZmZsYXRlJztcbmNvbnN0IGFscmVhZHlfY29tcHJlc3NlZCA9IG5ldyBTZXQoW1xuICAnemlwJywgJ2d6JywgJ3BuZycsICdqcGcnLCAnanBlZycsICdwZGYnLCAnZG9jJywgJ2RvY3gnLCAncHB0JywgJ3BwdHgnLFxuICAneGxzJywgJ3hsc3gnLCAnaGVpYycsICdoZWlmJywgJzd6JywgJ2J6MicsICdyYXInLCAnZ2lmJywgJ3dlYnAnLCAnd2VibScsXG4gICdtcDQnLCAnbW92JywgJ21wMycsICdhaWZjJ1xuXSk7XG5jb25zdCBhY2NlcHQgPSAnLnRzdiwucG5nLC5qcGcsIC5qcGVnLC56aXAsLmd6LC43eiwuYnoyJztcbmxldCBpbnN0YW5jZSA9IG51bGw7XG5jb25zdCBNQVhTSVpFID0gMTA3Mzc0MTgyNDsgLy8vL21heGZpbGVzaXplOiAxMDczNzQxODI0LFxuZXhwb3J0IGNsYXNzIEpzRGlyVG9aaXAge1xuICBfZXZlbnRzID0ge307XG4gIGV2ZW50bmFtZXMgPSB7XG4gICAgcmVhZHk6ICdyZWFkeScsXG4gICAgZW5kemlwOiAnZW5kemlwJyxcbiAgICBjb21wbGV0ZTogJ2NvbXBsZXRlJyxcbiAgICBlbmRyZWFkZGlyOiAnZW5kcmVhZGRpcicsXG4gICAgZ3ppcDogJ2d6aXBmaWxlJyxcbiAgICBzZW5kZmlsZTogJ3NlbmRmaWxlJyxcbiAgICBiaWdmaWxlOiAnYmlnZmlsZScsXG4gICAgdGVybWluYXRlOiAndGVybWluYXRlJyxcbiAgICBwZW5kaW5nOiAncGVuZGluZycsXG4gICAgZ2V0ZmlsZTogJ2dldHppcGZpbGUnLFxuICAgIGNvdW50ZXI6ICdjb3VudGVyJyxcbiAgICBtZXNzYWdlOiAnbWVzc2FnZScsXG4gICAgZXJyb3I6ICdlcnJvcidcbiAgfVxuICB6aXAgPSBudWxsO1xuICB6aXBuYW1lID0gbnVsbDtcbiAgZmlsZXN0cmVhbSA9IG51bGw7XG4gIHN0cmVhbWhhbmRsZSA9IG51bGw7XG4gIGd6aXBwZWQgPSBudWxsO1xuICBzaXpldG96aXAgPSAwO1xuICBwYXJ0ID0gMDtcbiAgY29udGludWUgPSBudWxsO1xuICBjb3VudGVyID0ge1xuICAgIHNjYW46IDAsXG4gICAgemlwOiAwXG4gIH1cbiAgY29uc3RydWN0b3Iob3B0aW9ucyA9IHt9KSB7XG4gICAgaWYgKGluc3RhbmNlKSByZXR1cm4gaW5zdGFuY2U7XG4gICAgY29uc3QgZGVmYXVsdE9wdGlvbnMgPSB7XG4gICAgICB1cGxvYWR1cmw6ICcvZ3VpL2ZpbGVzL3VwbG9hZCcsXG4gICAgICBsYXJnZWZpbGU6IDQxOTQzMDQsXG4gICAgICBhY2NlcHQ6IGFjY2VwdC5zcGxpdCgnLCcpXG4gICAgfVxuICAgIHRoaXMub3B0aW9ucyA9IHsgLi4uZGVmYXVsdE9wdGlvbnMsXG4gICAgICAuLi5vcHRpb25zXG4gICAgfTtcbiAgICBjb25zb2xlLmxvZygndGhpc29wdHMnLCB0aGlzLm9wdGlvbnMpXG5cbiAgICB0aGlzLmluaXQoKTtcblxuICAgIGluc3RhbmNlID0gdGhpcztcbiAgICByZXR1cm4gaW5zdGFuY2U7XG4gIH1cbiAgaW5pdCgpIHtcbiAgICBhZGRfY3VzdG9tX2V2ZW50cyh0aGlzKTtcbiAgICB0aGlzLmluaXRTdG9yYWdlKCk7XG4gICAgdGhpcy5vbih0aGlzLmV2ZW50bmFtZXMucmVhZHksICgpID0+IHtcbiAgICAgIGNvbnNvbGUubG9nKCdyZWFkeScpXG4gICAgfSk7XG4gIH1cbiAgcmVzZXQoKSB7XG4gICAgY29uc29sZS5sb2coJ3Jlc2V0Jyk7XG4gICAgdGhpcy56aXAgPSBudWxsO1xuICAgIHRoaXMuemlwbmFtZSA9IG51bGw7XG4gICAgdGhpcy5maWxlc3RyZWFtID0gbnVsbDtcbiAgICB0aGlzLnN0cmVhbWhhbmRsZSA9IG51bGw7XG4gICAgdGhpcy5nemlwcGVkID0gbnVsbDtcbiAgICB0aGlzLnNpemV0b3ppcCA9IDA7XG4gICAgdGhpcy5wYXJ0ID0gMDtcbiAgICB0aGlzLmNvbnRpbnVlID0gbnVsbDtcbiAgICB0aGlzLmluaXRTdG9yYWdlKCk7XG4gIH1cbiAgYXN5bmMgaW5pdFppcCgpIHtcbiAgICBjb25zb2xlLmxvZygnaW5pdHppcCcpXG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgdGhpcy5wb3MgPSAwO1xuICAgIHRoaXMuc2l6ZXRvemlwID0gMDtcbiAgICB0aGlzLnppcCA9IG5ldyBaaXAoKGVycm9yLCBjaHVuaywgZmluYWwpID0+IHtcbiAgICAgIGlmIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmxvZygnZXJyb3InLCBlcnJvcik7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNlbGYuc3RyZWFtaGFuZGxlLndyaXRlKGNodW5rLCB7XG4gICAgICAgICAgYXQ6IHNlbGYucG9zXG4gICAgICAgIH0pO1xuICAgICAgICBzZWxmLnBvcyArPSBjaHVuay5sZW5ndGg7XG4gICAgICAgIGlmIChmaW5hbCkge1xuICAgICAgICAgIHNlbGYuc3RyZWFtaGFuZGxlLmNsb3NlKCk7XG4gICAgICAgICAgY29uc29sZS5sb2coJ2ZpbmFsLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqLScsIHNlbGYucG9zKTtcblxuICAgICAgICB9XG5cbiAgICAgIH1cbiAgICB9KTtcbiAgICAvKiAgY29uc3QgZmZsVG9SUyA9IGZmbGF0ZVN0cmVhbSA9PlxuICAgICAgICBuZXcgUmVhZGFibGVTdHJlYW0oe1xuICAgICAgICAgIHN0YXJ0KGNvbnRyb2xsZXIpIHtcbiAgICAgICAgICAgIC8vIFB1c2ggdG8gdGhlIFJlYWRhYmxlU3RyZWFtIHdoZW5ldmVyIHRoZSBmZmxhdGVcbiAgICAgICAgICAgIC8vIHN0cmVhbSBnZXRzIGRhdGFcbiAgICAgICAgICAgIGZmbGF0ZVN0cmVhbS5vbmRhdGEgPSAoZXJyLCBkYXRhLCBmaW5hbCkgPT4ge1xuICAgICAgICAgICAgICBpZiAoZXJyKSBjb250cm9sbGVyLmVycm9yKGVycik7XG4gICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShkYXRhKTtcbiAgICAgICAgICAgICAgICAvLyBFbmQgdGhlIHN0cmVhbSBvbiB0aGUgZmluYWwgY2h1bmtcbiAgICAgICAgICAgICAgICBpZiAoZmluYWwpIHtcbiAgICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuY2xvc2UoKTtcbiAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdmaW5hbC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqLScpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgICAgY2FuY2VsKCkge1xuICAgICAgICAgICAgLy8gV2UgY2FuIHN0b3Agd29ya2luZyBpZiB0aGUgc3RyZWFtIGlzIGNhbmNlbGxlZFxuICAgICAgICAgICAgLy8gVGhpcyBtYXkgaGFwcGVuIGlmIHRoZSB1c2VyIGNhbmNlbHMgdGhlIGRvd25sb2FkXG4gICAgICAgICAgICBmZmxhdGVTdHJlYW0udGVybWluYXRlKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIGNvbnN0IHppcHN0cmVhbSA9IGZmbFRvUlModGhpcy56aXApO1xuICAgICAgemlwc3RyZWFtLnBpcGVUbyhzZWxmLnN0cmVhbWhhbmRsZSk7Ki9cbiAgICBpZiAodGhpcy5jb250aW51ZSkgYXdhaXQgdGhpcy5jb250aW51ZSgpO1xuICAgIGVsc2Uge1xuICAgICAgLy8gZXZlbnRzXG4gICAgICB0aGlzLm9uKHRoaXMuZXZlbnRuYW1lcy5lbmR6aXAsIChlKSA9PiB7XG4gICAgICAgIGlmICghZS5iaWdmaWxlICYmIHRoaXMuemlwKSB7XG5cbiAgICAgICAgICB0aGlzLnppcC5lbmQoKTtcbiAgICAgICAgICBjb25zb2xlLmxvZygnemlwZW5kJywgdGhpcy56aXApXG4gICAgICAgICAgY29uc29sZS5sb2coJ2ZzdHJlbScsIHRoaXMuZmlsZXN0cmVhbSlcbiAgICAgICAgfSBlbHNlIGlmIChlLmJpZ2ZpbGUgJiYgdGhpcy5nemlwcGVkKSBjb25zb2xlLmxvZygnLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLWd6aXBwZWQgZW5kICcsIHRoaXMuZ3ppcHBlZClcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IHtcbiAgICAgICAgICBuYW1lOiB0aGlzLmV2ZW50bmFtZXMuc2VuZGZpbGVcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKGUucGFydCkge1xuICAgICAgICAgIG1lc3NhZ2VbXCJwYXJ0XCJdID0gZS5wYXJ0O1xuICAgICAgICB9IGVsc2UgdGhpcy5wYXJ0ID0gMDtcbiAgICAgICAgaWYgKGUuaGFzT3duUHJvcGVydHkoXCJiaWdmaWxlXCIpKSBtZXNzYWdlW1wiYmlnZmlsZVwiXSA9IGUuYmlnZmlsZTtcbiAgICAgICAgaWYgKGUuaGFzT3duUHJvcGVydHkoXCJwYXRoXCIpKSBtZXNzYWdlW1wicGF0aFwiXSA9IGUucGF0aDtcbiAgICAgICAgY29uc29sZS5sb2coJ2VuZHppcCUlJSUlJSUlJSUlJSUlJSUlJSUlJSUlJSUlJSUlJSUlJSUnLCBlKVxuICAgICAgICB0aGlzLmVtaXQodGhpcy5ldmVudG5hbWVzLmNvbXBsZXRlLCBtZXNzYWdlKTtcbiAgICAgIH0pO1xuXG4gICAgICB0aGlzLm9uKHRoaXMuZXZlbnRuYW1lcy5zZW5kZmlsZSwgYXN5bmMgKGUpID0+IHtcbiAgICAgICAgY29uc29sZS5sb2coJ2V2ZW50c2VuZGZpbGUnLCBlKVxuICAgICAgICBsZXQgZmlsZSA9IChlLmJpZ2ZpbGUpID8gYXdhaXQgdGhpcy5nZXRGaWxlKHRoaXMuZ3ppcHBlZCk6IGF3YWl0IHRoaXMuZ2V0RmlsZSgpO1xuICAgICAgICBjb25zb2xlLmxvZygnc2VuZGZpbGUnLCBmaWxlKVxuICAgICAgICAvKiBpZiAoZS5iaWdmaWxlKSB0aGlzLnNlbmRDaHVuaygoZS5wYXRoID8gZS5wYXRoIDogJycpKTtcbiAgICAgICAgICBlbHNlICovXG4gICAgICAgIHRoaXMuc2VuZFppcEZpbGUoZmlsZSwgKGUucGF0aCA/IGUucGF0aCA6ICcnKSwgbnVsbCwgKGUuYmlnZmlsZSA/IGUuYmlnZmlsZSA6IGZhbHNlKSk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMub24odGhpcy5ldmVudG5hbWVzLmJpZ2ZpbGUsIChlKSA9PiB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdvbnNlbmRjaHVuaycsIGUpXG4gICAgICAgIHRoaXMuc2VuZENodW5rKChlLnBhdGggPyBlLnBhdGggOiAnJykpO1xuICAgICAgfSk7XG4gICAgICB0aGlzLm9uKHRoaXMuZXZlbnRuYW1lcy5lbmRyZWFkZGlyLCAoZSkgPT4ge1xuICAgICAgICB0aGlzLmVuZHJlYWRkaXIgPSB0cnVlO1xuICAgICAgICBjb25zb2xlLmxvZygnZW5kcmVhZGRpcicsIHRoaXMuY291bnRlcilcbiAgICAgICAgaWYgKHRoaXMuY291bnRlci5zY2FuID09PSB0aGlzLmNvdW50ZXIuemlwKSB7XG4gICAgICAgICAgY29uc29sZS5sb2codGhpcy5lbmRyZWFkZGlyLCB0aGlzLmNvdW50ZXIpXG4gICAgICAgICAgY29uc29sZS5sb2coJ2VuZHppcCcsIHRoaXMuemlwKVxuICAgICAgICAgIHRoaXMuZW1pdCh0aGlzLmV2ZW50bmFtZXMuY29tcGxldGUsIHtcbiAgICAgICAgICAgIG5hbWU6IHRoaXMuZXZlbnRuYW1lcy5lbmR6aXBcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICB0aGlzLm9uKHRoaXMuZXZlbnRuYW1lcy5jb3VudGVyLCBhc3luYyAoZSkgPT4ge1xuICAgICAgICB0aGlzLmNvdW50ZXJbZS5uYW1lXSArPSAxO1xuICAgICAgICBpZiAodGhpcy5jb3VudGVyLnNjYW4gPT09IHRoaXMuY291bnRlci56aXApIGNvbnNvbGUubG9nKCd0aGlzIGVuZCcsIHRoaXMuZW5kcmVhZGRpcilcblxuICAgICAgICBpZiAoZS5uYW1lID09PSAnemlwJyAmJiB0aGlzLmNhbGxiYWNrKSBhd2FpdCB0aGlzLmNhbGxiYWNrKCk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgYXN5bmMgaW5pdFN0b3JhZ2UoKSB7XG4gICAgaWYgKG5hdmlnYXRvciAmJiBuYXZpZ2F0b3Iuc3RvcmFnZSAmJiBuYXZpZ2F0b3Iuc3RvcmFnZS5lc3RpbWF0ZSkge1xuICAgICAgYXdhaXQgdGhpcy5jbGVhblN0b3JhZ2UoKTtcbiAgICAgIHRoaXMuZW1pdCh0aGlzLmV2ZW50bmFtZXMucmVhZHkpO1xuICAgICAgbmF2aWdhdG9yLnN0b3JhZ2UuZXN0aW1hdGUoKS50aGVuKChxdW90YSkgPT4ge1xuICAgICAgICBjb25zdCBwZXJjZW50YWdlVXNlZCA9IChxdW90YS51c2FnZSAvIHF1b3RhLnF1b3RhKSAqIDEwMDtcbiAgICAgICAgY29uc3QgcmVtYWluaW5nID0gcXVvdGEucXVvdGEgLSBxdW90YS51c2FnZTtcbiAgICAgICAgdGhpcy5lbWl0KHRoaXMuZXZlbnRuYW1lcy5tZXNzYWdlLCB7XG4gICAgICAgICAgbmFtZTogXCJjb25zb2xlXCIsXG4gICAgICAgICAgbWVzc2FnZTogXCJZb3UgY2FuIHdyaXRlIHVwIHRvIFwiICsgcmVtYWluaW5nICsgXCIgbW9yZSBieXRlcy5cIlxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5lbWl0KHRoaXMuZXZlbnRuYW1lcy5tZXNzYWdlLCB7XG4gICAgICAgICAgbmFtZTogXCJjb25zb2xlXCIsXG4gICAgICAgICAgbWVzc2FnZTogXCJ5b3UndmUgdXNlZCBcIiArIHBlcmNlbnRhZ2VVc2VkICsgXCIlIG9mIHRoZSBhdmFpbGFibGUgc3RvcmFnZS5cIlxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB0aGlzLmVtaXQodGhpcy5ldmVudG5hbWVzLm1lc3NhZ2UsIHtcbiAgICAgIG5hbWU6IFwiZXJyb3JcIixcbiAgICAgIG1lc3NhZ2U6IFwibm8gbmF2aWdhdG9yIHN0b3JhZ2VcIlxuICAgIH0pO1xuICB9XG4gIGFzeW5jIGNyZWF0ZUxvY2FsU3RyZWFtKG5hbWUsIGFjY2VwdCA9IHtcbiAgICAnYXBwbGljYXRpb24vemlwJzogWycuemlwJ10sXG4gIH0pIHtcbiAgICBjb25zdCByb290ID0gYXdhaXQgbmF2aWdhdG9yLnN0b3JhZ2UuZ2V0RGlyZWN0b3J5KCk7XG4gICAgY29uc3Qgb3B0cyA9IHtcbiAgICAgIHR5cGVzOiBbe1xuICAgICAgICBkZXNjcmlwdGlvbjogJ1RlbXAgZmlsZScsXG4gICAgICAgIGFjY2VwdDogYWNjZXB0LFxuICAgICAgfSwgXSxcbiAgICAgIGNyZWF0ZTogdHJ1ZVxuICAgIH07XG4gICAgY29uc3QgZmlsZXN0cmVhbSA9IGF3YWl0IHJvb3QuZ2V0RmlsZUhhbmRsZShuYW1lLCBvcHRzKTtcbiAgICBjb25zdCBzdHJlYW1oYW5kbGUgPSBhd2FpdCBmaWxlc3RyZWFtLmNyZWF0ZVdyaXRhYmxlKCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGZpbGVzdHJlYW0sXG4gICAgICBzdHJlYW1oYW5kbGVcbiAgICB9O1xuICB9XG5cbiAgYXN5bmMgc2NhbkhhbmRsZShkaXIsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnNvbGUubG9nKCd0aGlzLnppcCcsIHRoaXMuemlwKVxuICAgIGlmICh0aGlzLnppcCA9PT0gbnVsbCkge1xuICAgICAgY29uc3QgdHlwZSA9IChvcHRpb25zICYmIG9wdGlvbnMudHlwZSkgPyBvcHRpb25zLnR5cGUgOiAnLnppcCc7XG4gICAgICB0aGlzLnppcG5hbWUgPSAoKG9wdGlvbnMuemlwbmFtZSkgPyBvcHRpb25zLnppcG5hbWUgOiBkaXIubmFtZSkgKyB0eXBlOyAvL1xuXG4gICAgICBjb25zdCB7XG4gICAgICAgIGZpbGVzdHJlYW0sXG4gICAgICAgIHN0cmVhbWhhbmRsZVxuICAgICAgfSA9IGF3YWl0IHRoaXMuY3JlYXRlTG9jYWxTdHJlYW0odGhpcy56aXBuYW1lKTtcbiAgICAgIGNvbnNvbGUubG9nKCdzdHJlYW1oYW5kbGUnLCBzdHJlYW1oYW5kbGUpXG4gICAgICB0aGlzLmZpbGVzdHJlYW0gPSBmaWxlc3RyZWFtO1xuICAgICAgdGhpcy5zdHJlYW1oYW5kbGUgPSBzdHJlYW1oYW5kbGU7XG4gICAgICBsZXQgc2l6ZSA9IDA7XG4gICAgICB0aGlzLnBhcnQgPSAwO1xuICAgICAgYXdhaXQgdGhpcy5pbml0WmlwKCk7XG4gICAgICBjb25zdCB6aXAgPSB0aGlzLnppcDtcbiAgICAgIGlmICghdGhpcy5qc1NjYW5EaXIpIHtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIEpzU2NhbkRpclxuICAgICAgICB9ID0gYXdhaXQgaW1wb3J0KCcuLi9maWxlcy9qcy1zY2FuZGlyLmpzJyk7XG4gICAgICAgIHRoaXMuanNTY2FuRGlyID0gbmV3IEpzU2NhbkRpcigpO1xuICAgICAgfVxuICAgICAgdGhpcy5qc1NjYW5EaXIucHJvY2Vzc0ZpbGUgPSBhc3luYyAoZW50cnksIGNhbGxiYWNrKSA9PiB7XG4gICAgICAgIHRoaXMuY2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICAgICAgYXdhaXQgdGhpcy5wcm9jZXNzRmlsZShlbnRyeSk7XG5cbiAgICAgIH07XG4gICAgfVxuICAgIHRoaXMuZW5kcmVhZGRpciA9IGZhbHNlO1xuICAgIHRoaXMuY291bnRlci5zY2FuID0gdGhpcy5jb3VudGVyLnppcCA9IDA7XG4gICAgYXdhaXQgdGhpcy5qc1NjYW5EaXIucmVhZERpcmVjdG9yeShkaXIsICgpID0+IHtcbiAgICAgIHRoaXMuZW1pdCh0aGlzLmV2ZW50bmFtZXMuZW5kcmVhZGRpcik7XG4gICAgfSk7XG5cbiAgfVxuICBhc3luYyBzZW5kQmlnRmlsZShmaWxlLCBmaWxlcGF0aCkge1xuICAgIGNvbnNvbGUubG9nKCdzZW5kYmlnZmlsZXBhdGgnLCBmaWxlcGF0aClcbiAgICB0aGlzLmR0ID0gRGF0ZS5ub3coKTtcbiAgICBmaWxlcGF0aCA9IChmaWxlcGF0aC5pbmRleE9mKCcvJykgPT09IDApID8gZmlsZXBhdGguc3Vic3RyKDEpIDogZmlsZXBhdGg7XG4gICAgLypsZXQgZmlsZXBhdGggPSBmaWxlLndlYmtpdFJlbGF0aXZlUGF0aDtcbiAgICBmaWxlcGF0aCA9IChmaWxlcGF0aCA9PT0gJycpID8gZGlybmFtZSArICcvJyArIGZpbGUubmFtZSA6IGZpbGVwYXRoOyovXG4gICAgY29uc3QgZXh0ID0gZmlsZS5uYW1lLnNsaWNlKGZpbGUubmFtZS5sYXN0SW5kZXhPZignLicpICsgMSk7XG4gICAgaWYgKGFscmVhZHlfY29tcHJlc3NlZC5oYXMoZXh0KSkge1xuICAgICAgdGhpcy5nemlwcGVkID0gZmlsZTtcbiAgICAgIHRoaXMuZW1pdCh0aGlzLmV2ZW50bmFtZXMuY291bnRlciwge1xuICAgICAgICBuYW1lOiAnemlwJyxcbiAgICAgICAgZmlsZXBhdGg6IGZpbGVwYXRoLFxuICAgICAgICBzaXplOiBmaWxlLnNpemVcbiAgICAgIH0pO1xuICAgICAgdGhpcy5lbWl0KHRoaXMuZXZlbnRuYW1lcy5jb21wbGV0ZSwge1xuICAgICAgICBuYW1lOiB0aGlzLmV2ZW50bmFtZXMuYmlnZmlsZSxcbiAgICAgICAgYmlnZmlsZTogZmlsZXBhdGhcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmVtaXQodGhpcy5ldmVudG5hbWVzLmd6aXAsIHtcbiAgICAgICAgbmFtZTogdGhpcy5ldmVudG5hbWVzLmd6aXAsXG4gICAgICAgIGJpZ2ZpbGU6IGZpbGVwYXRoLFxuICAgICAgICBzaXplOiBmaWxlLnNpemVcbiAgICAgIH0pO1xuICAgICAgbGV0IHppcG5hbWUgPSBmaWxlLm5hbWUuc3BsaXQoZXh0KTtcbiAgICAgIHppcG5hbWUucG9wKCk7XG4gICAgICB6aXBuYW1lID0gemlwbmFtZS5qb2luKGV4dCkgKyAnZ3onO1xuICAgICAgY29uc29sZS5sb2coJ2JpZ2ZpbGUgZXh0PScgKyBleHQsIHppcG5hbWUpXG4gICAgICBjb25zdCB7XG4gICAgICAgIGZpbGVzdHJlYW0sXG4gICAgICAgIHN0cmVhbWhhbmRsZVxuICAgICAgfSA9IGF3YWl0IHRoaXMuY3JlYXRlTG9jYWxTdHJlYW0oemlwbmFtZSwge1xuICAgICAgICAnYXBwbGljYXRpb24vZ3ppcCc6IFsnLmd6J10sXG4gICAgICB9KTtcbiAgICAgIGxldCBwb3MgPSAwO1xuICAgICAgY29uc3Qgc2VsZmkgPSB0aGlzO1xuICAgICAgY29uc3QgZ3ppcHBlZCA9IG5ldyBHemlwKHtcbiAgICAgICAgbGV2ZWw6IDksXG4gICAgICAgIGZpbGVuYW1lOiBmaWxlcGF0aFxuICAgICAgfSk7XG4gICAgICBnemlwcGVkLm9uZGF0YSA9IChkYXRhLCBmaW5hbCkgPT4ge1xuICAgICAgICBpZiAoZmluYWwpIHtcbiAgICAgICAgICBjb25zb2xlLmxvZygnZmluYWwgQklHRklMRSUlJSUlJSUlJSUlJSUlJSUlJSUlJyArIHNlbGZpLmV2ZW50bmFtZXMuYmlnZmlsZSwgZmlsZXBhdGgpXG4gICAgICAgICAgc2VsZmkuZW1pdChzZWxmaS5ldmVudG5hbWVzLmNvbXBsZXRlLCB7XG4gICAgICAgICAgICBuYW1lOiBzZWxmaS5ldmVudG5hbWVzLmJpZ2ZpbGUsXG4gICAgICAgICAgICBiaWdmaWxlOiBmaWxlcGF0aFxuXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBzdHJlYW1oYW5kbGUuY2xvc2UoKTtcbiAgICAgICAgICBjb25zb2xlLmxvZygndGltZXRvemlwJywgKERhdGUubm93KCkgLSB0aGlzLmR0KSAvIDEwMDApXG4gICAgICAgICAgc2VsZmkuZ3ppcHBlZCA9IGZpbGVzdHJlYW07XG4gICAgICAgICAgY29uc29sZS5sb2coJ2JpZyBmaWxlICoqKioqKioqKioqKioqKioqKionICsgZmlsZXBhdGgsIHNlbGZpLmd6aXBwZWQpO1xuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3RyZWFtaGFuZGxlLndyaXRlKGRhdGEsIHtcbiAgICAgICAgICAgIGF0OiBwb3NcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBwb3MgKz0gZGF0YS5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBhd2FpdCB0aGlzLnJlYWRGaWxlKGZpbGUsIGZpbGVwYXRoLCBnemlwcGVkKTtcbiAgICB9XG5cblxuICB9XG4gIGFzeW5jIHBhcnRaaXAoKSB7XG4gICAgdGhpcy5wYXJ0ICs9IDE7XG4gICAgdGhpcy5lbWl0KHRoaXMuZXZlbnRuYW1lcy5jb21wbGV0ZSwge1xuICAgICAgbmFtZTogdGhpcy5ldmVudG5hbWVzLmVuZHppcCxcbiAgICAgIHBhcnQ6IHRoaXMucGFydFxuICAgIH0pO1xuICB9XG4gIGFzeW5jIHJlYWRGaWxlKGZpbGUsIGZpbGVwYXRoLCB6aXBwZWRzdHJlYW0pIHtcbiAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICBjb25zdCByZWFkZXIgPSBmaWxlLnN0cmVhbSgpLmdldFJlYWRlcigpO1xuICAgIGxldCBwYXVzZSA9IGZhbHNlO1xuICAgIC8qICBvbkJhY2twcmVzc3VyZSh6aXBwZWRzdHJlYW0sIHRoaXMuc3RyZWFtaGFuZGxlLCBzaG91bGRfYXBwbHlfYmFja3ByZXNzdXJlID0+IHtcbiAgICAgICAgaWYgKHNob3VsZF9hcHBseV9iYWNrcHJlc3N1cmUpIHBhdXNlID0gdHJ1ZTtcbiAgICAgICAgZWxzZSBpZiAocGF1c2UpIHBhdXNlID0gZmFsc2U7XG4gICAgICB9KTsqL1xuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGRvbmUsXG4gICAgICAgIHZhbHVlXG4gICAgICB9ID0gYXdhaXQgcmVhZGVyLnJlYWQoKTtcbiAgICAgIGlmIChkb25lKSB7XG4gICAgICAgIHppcHBlZHN0cmVhbS5wdXNoKG5ldyBVaW50OEFycmF5KDApLCB0cnVlKTtcbiAgICAgICAgc2VsZi5lbWl0KHNlbGYuZXZlbnRuYW1lcy5jb3VudGVyLCB7XG4gICAgICAgICAgbmFtZTogJ3ppcCcsXG4gICAgICAgICAgZmlsZXBhdGg6IGZpbGVwYXRoLFxuICAgICAgICAgIHNpemU6ICh6aXBwZWRzdHJlYW0uc2l6ZSkgPyB6aXBwZWRzdHJlYW0uc2l6ZSA6IGZpbGUuc2l6ZVxuICAgICAgICB9KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICB6aXBwZWRzdHJlYW0ucHVzaCh2YWx1ZSk7XG4gICAgfVxuICB9XG4gIGFzeW5jIHppcFN0cmVhbShmaWxlLCBmaWxlcGF0aCkge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgIGNvbnN0IGV4dCA9IGZpbGVwYXRoLnNsaWNlKGZpbGVwYXRoLmxhc3RJbmRleE9mKCcuJykgKyAxKTtcbiAgICBjb25zdCBpc2NvbXByZXNzZWQgPSBhbHJlYWR5X2NvbXByZXNzZWQuaGFzKGV4dCk7XG4gICAgY29uc3QgemlwcGVkc3RyZWFtID0gKGlzY29tcHJlc3NlZCkgPyBuZXcgWmlwUGFzc1Rocm91Z2goZmlsZXBhdGgpIDogZmlsZS5zaXplID4gdGhpcy5vcHRpb25zLmxhcmdlZmlsZSA/XG4gICAgICBuZXcgQXN5bmNaaXBEZWZsYXRlKGZpbGVwYXRoLCB7XG4gICAgICAgIGxldmVsOiA2LFxuICAgICAgfSkgOiBuZXcgWmlwRGVmbGF0ZShmaWxlcGF0aCwge1xuICAgICAgICBsZXZlbDogNlxuICAgICAgfSk7XG4gICAgdGhpcy56aXAuYWRkKHppcHBlZHN0cmVhbSk7XG4gICAgLyp6aXBwZWRzdHJlYW0ub25kYXRhID0gKGVyciwgZGF0YSwgZmluYWwpID0+IHtcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgY29uc29sZS5sb2coJ2VyciBhc3luYycsIGVycik7XG4gICAgICB9IGVsc2UgaWYgKGZpbmFsID09PSB0cnVlKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdmaW5hbCcsIHppcHBlZHN0cmVhbSlcbiAgICAgICAgc2VsZi5lbWl0KHNlbGYuZXZlbnRuYW1lcy5jb3VudGVyLCB7XG4gICAgICAgICAgbmFtZTogJ3ppcCcsXG4gICAgICAgICAgZmlsZXBhdGg6IGZpbGVwYXRoLFxuICAgICAgICAgIHNpemU6ICh6aXBwZWRzdHJlYW0uc2l6ZSkgPyB6aXBwZWRzdHJlYW0uc2l6ZSA6IGZpbGUuc2l6ZVxuICAgICAgICB9KTtcblxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2VsZi5zdHJlYW1oYW5kbGUud3JpdGUoZGF0YSwge1xuICAgICAgICAgIGF0OiBzZWxmLnBvc1xuICAgICAgICB9KTtcbiAgICAgICAgc2VsZi5wb3MgKz0gZGF0YS5sZW5ndGg7XG4gICAgICB9XG4gICAgfSovXG4gICAgLy8gIGNvbnNvbGUubG9nKHppcHBlZHN0cmVhbSBpbnN0YW5jZW9mKEFzeW5jWmlwRGVmbGF0ZSksIHppcHBlZHN0cmVhbS5vbmRhdGEpO1xuICAgIGF3YWl0IHRoaXMucmVhZEZpbGUoZmlsZSwgZmlsZXBhdGgsIHppcHBlZHN0cmVhbSk7XG4gIH1cbiAgYXN5bmMgcHJvY2Vzc0ZpbGUoZW50cnkpIHtcbiAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICBjb25zdCBmaWxlcGF0aCA9IGVudHJ5LmZ1bGxQYXRoO1xuICAgIGNvbnN0IGV4dCA9IGZpbGVwYXRoLnNsaWNlKGZpbGVwYXRoLmxhc3RJbmRleE9mKCcuJykgKyAxKTtcbiAgICBpZiAodGhpcy5vcHRpb25zLmFjY2VwdC5pbmNsdWRlcyhleHQpKSB7XG4gICAgICBjb25zb2xlLmxvZygncmVqZWN0JywgZmlsZXBhdGgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoZW50cnkuaXNEaXJlY3RvcnkpIHtcbiAgICAgIGNvbnNvbGUubG9nKCd6aXBkaXInLCB0aGlzLmNhbGxiYWNrKVxuICAgICAgaWYgKHRoaXMuY2FsbGJhY2sgIT09IG51bGwpIGF3YWl0IHRoaXMuY2FsbGJhY2soKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZW50cnkuZmlsZShhc3luYyBmaWxlID0+IHtcbiAgICAgICAgdGhpcy5lbWl0KHRoaXMuZXZlbnRuYW1lcy5jb3VudGVyLCB7XG4gICAgICAgICAgbmFtZTogJ3NjYW4nLFxuICAgICAgICAgIGZpbGVwYXRoOiBmaWxlcGF0aCxcbiAgICAgICAgICBzaXplOiBmaWxlLnNpemVcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuY29udGludWUgPSBudWxsO1xuICAgICAgICAvLyBjaGVjayBmaWxlIHNpemUgPiBtYXggcG9zdCBzaXplXG4gICAgICAgIGlmIChmaWxlLnNpemUgPj0gTUFYU0laRSkge1xuICAgICAgICAgIGF3YWl0IHRoaXMuc2VuZEJpZ0ZpbGUoZmlsZSwgZmlsZXBhdGgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIGNoZWNrIHppcCBmaWxlIHNpemUgPiB0b3RhbCB6aXAgc2l6ZVxuICAgICAgICAgIHRoaXMuc2l6ZXRvemlwICs9IGZpbGUuc2l6ZTtcbiAgICAgICAgICBpZiAodGhpcy5zaXpldG96aXAgPj0gTUFYU0laRSkge1xuICAgICAgICAgICAgdGhpcy5jb250aW51ZSA9IGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgYXdhaXQgdGhpcy56aXBTdHJlYW0oZmlsZSwgZmlsZXBhdGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5wYXJ0WmlwKCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuemlwU3RyZWFtKGZpbGUsIGZpbGVwYXRoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgfVxuICB9XG4gIG9uRXJyb3IoKSB7XG4gICAgdGhpcy5jbGVhblN0b3JhZ2UoKTtcbiAgICB0aGlzLmVtaXQodGhpcy5ldmVudG5hbWVzLmVycm9yLCB7XG4gICAgICBuYW1lOiBcInJlbG9hZFwiXG4gICAgfSk7XG4gIH1cbiAgYXN5bmMgY2xlYW5TdG9yYWdlKGVudHJ5ID0gbnVsbCkge1xuICAgIGVudHJ5ID0gKGVudHJ5KSA/IGVudHJ5IDogYXdhaXQgbmF2aWdhdG9yLnN0b3JhZ2UuZ2V0RGlyZWN0b3J5KCk7XG4gICAgZm9yIGF3YWl0IChjb25zdCBba2V5LCB2YWx1ZV0gb2YgZW50cnkuZW50cmllcygpKSB7XG4gICAgICBjb25zb2xlLmxvZygna2V5dmFsJywge1xuICAgICAgICBrZXksXG4gICAgICAgIHZhbHVlXG4gICAgICB9KTtcbiAgICAgIGF3YWl0IGVudHJ5LnJlbW92ZUVudHJ5KGtleSk7XG4gICAgfVxuXG4gIH1cblxuICBhc3luYyBlbmRGZXRjaChtZXNzYWdlLCBjbGVhbiA9IGZhbHNlKSB7XG4gICAgbWVzc2FnZS5uYW1lID0gdGhpcy5ldmVudG5hbWVzLnRlcm1pbmF0ZTtcbiAgICBpZiAobWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcImJpZ2ZpbGVcIikgJiYgbWVzc2FnZS5iaWdmaWxlICE9PSBcIlwiICYmXG4gICAgICBtZXNzYWdlLmJpZ2ZpbGUgIT09IGZhbHNlICYmIG1lc3NhZ2UuYmlnZmlsZSAhPT0gbnVsbCkge1xuICAgICAgbWVzc2FnZVtcImJpZ2ZpbGVcIl0gPSB0aGlzLmd6aXBwZWQubmFtZTtcbiAgICAgIHRoaXMuZ3ppcHBlZCA9IG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh0aGlzLmNvbnRpbnVlKSB7XG4gICAgICAgIHRoaXMuc3RyZWFtaGFuZGxlID0gYXdhaXQgdGhpcy5maWxlc3RyZWFtLmNyZWF0ZVdyaXRhYmxlKCk7XG4gICAgICAgIGF3YWl0IHRoaXMuaW5pdFppcCgpO1xuICAgICAgfSBlbHNlIHRoaXMucmVzZXQoKTtcbiAgICAgIGlmICh0aGlzLmNvbnRpbnVlID09PSBudWxsICYmIGNsZWFuID09PSB0cnVlKSBhd2FpdCB0aGlzLmNsZWFuU3RvcmFnZSgpO1xuICAgIH1cbiAgICB0aGlzLmVtaXQodGhpcy5ldmVudG5hbWVzLmNvbXBsZXRlLCBtZXNzYWdlKTtcbiAgICBjb25zb2xlLmxvZygnY29udGludWUnLCB0aGlzLmNvbnRpbnVlKVxuICB9XG5cbiAgYXN5bmMgc2VuZENodW5rKHBhdGgsIHN0YXJ0ID0gMCwgY2h1bmtudW0gPSAwLCBjaHVua3NpemUgPSBNQVhTSVpFKSB7XG4gICAgY29uc29sZS5sb2coJ3NlbmQgY2h1bmsgJywgdGhpcy5nemlwcGVkKVxuICAgIGNvbnNvbGUubG9nKCdjaHVua3BhdGgnLCBwYXRoKVxuICAgIGNvbnN0IGZpbGUgPSAodGhpcy5nemlwcGVkKSA/IGF3YWl0IHRoaXMuZ2V0RmlsZSh0aGlzLmd6aXBwZWQpOiBhd2FpdCB0aGlzLmdldEZpbGUoKTtcbiAgICBjb25zb2xlLmxvZygnZmlsZScsIGZpbGUpXG4gICAgcGF0aCA9IHBhdGguc3BsaXQoJy8nKTtcbiAgICBwYXRoLnBvcCgpO1xuICAgIHBhdGggPSBwYXRoLmpvaW4oJy8nKTtcbiAgICBjb25zdCBlbmQgPSBNYXRoLm1pbihzdGFydCArIGNodW5rc2l6ZSwgZmlsZS5zaXplKTtcbiAgICBjb25zb2xlLmxvZygnZW5kLS0tJywgZW5kKVxuICAgIGlmIChlbmQgPT09IGZpbGUuc2l6ZSkge1xuXG4gICAgICB0aGlzLnNlbmRaaXBGaWxlKGZpbGUsIHBhdGgsIG51bGwsIHRydWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBwYXJ0ZmlsZSA9IGZpbGUuc2xpY2Uoc3RhcnQsIGVuZCk7XG4gICAgICBwYXJ0ZmlsZS5uYW1lID0gY2h1bmtudW0gKyAnXycgKyBmaWxlLm5hbWU7XG4gICAgICB0aGlzLnNlbmRaaXBmaWxlKHBhcnRmaWxlLCBwYXRoLCAoKSA9PiB7XG4gICAgICAgIHN0YXJ0ICs9IGVuZDtcbiAgICAgICAgY2h1bmtudW0rKztcblxuICAgICAgICBpZiAoc3RhcnQgPD0gZmlsZS5zaXplKSB0aGlzLnNlbmRDaHVuayhwYXRoLCBzdGFydCwgY2h1bmtudW0sIGNodW5rc2l6ZSk7XG4gICAgICB9LCB0cnVlKVxuICAgIH1cbiAgICByZXR1cm4gY2h1bmtudW07XG4gIH1cbiAgYXN5bmMgZ2V0RmlsZShmaWxlc3RyZWFtID0gbnVsbCkge1xuICAgIGZpbGVzdHJlYW0gPSAoZmlsZXN0cmVhbSA9PT0gbnVsbCkgPyB0aGlzLmZpbGVzdHJlYW0gOiBmaWxlc3RyZWFtO1xuICAgIGNvbnN0IGZpbGUgPSBhd2FpdCBmaWxlc3RyZWFtLmdldEZpbGUoKTtcbiAgICByZXR1cm4gZmlsZTtcbiAgfVxuICBhc3luYyBzZW5kWmlwRmlsZShmaWxlLCBwYXRoLCBjYWxsYmFja2NodW5rID0gbnVsbCwgaXNiaWdmaWxlID0gZmFsc2UpIHtcbiAgICBjb25zb2xlLmxvZygnc2VuZHppcGZpbGUtLS0tLS0tLS0tLS1fX19fX19fX19fX19fX19fX19fX19fXycgKyBpc2JpZ2ZpbGUsIGZpbGUpXG4gICAgY29uc3QgbWVzc2FnZSA9IChpc2JpZ2ZpbGUpID8ge1xuICAgICAgYmlnZmlsZTogZmlsZS5uYW1lXG4gICAgfSA6IHt9O1xuICAgIHRoaXMuZW1pdCh0aGlzLmV2ZW50bmFtZXMucGVuZGluZywgbWVzc2FnZSk7XG4gICAgY29uc29sZS5sb2coJ2ZpbGUnLCBmaWxlKVxuICAgIGNvbnNvbGUubG9nKCdjYWxsYmFja2NodW5rLS0tc2VuZHppcCcsIGNhbGxiYWNrY2h1bmspXG4gICAgY29uc3QgZm9ybWRhdGEgPSBuZXcgRm9ybURhdGEoKTtcbiAgICBmb3JtZGF0YS5hcHBlbmQoJ3RhZycsICdlY290YXhhX2ltcG9ydCcpO1xuICAgIGZvcm1kYXRhLmFwcGVuZCgncGF0aCcsIHBhdGggKyBmaWxlLm5hbWUpO1xuICAgIGZvcm1kYXRhLmFwcGVuZCgnZmlsZScsIGZpbGUsIGZpbGUubmFtZSk7XG4gICAgaWYgKHRoaXMucGFydCkgZm9ybWRhdGEuYXBwZW5kKCdwYXJ0JywgdGhpcy5wYXJ0KTtcbiAgICBlbHNlIGlmIChjYWxsYmFja2NodW5rICE9PSBudWxsKSBmb3JtZGF0YS5hcHBlbmQoJ2lzY2h1bmsnLCB0cnVlKTtcbiAgICBmZXRjaCh0aGlzLm9wdGlvbnMudXBsb2FkdXJsLCB7XG4gICAgICAvLyAgbW9kZTogJ2NvcnMnLFxuICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgIGNyZWRlbnRpYWxzOiBcImluY2x1ZGVcIixcbiAgICAgIGJvZHk6IGZvcm1kYXRhLFxuICAgIH0pLnRoZW4oYXN5bmMgKHJlc3BvbnNlKSA9PiB7XG4gICAgICBjb25zb2xlLmxvZygncmVzcG9uc2UtLS0tLS0tLS0tLS0tLS0tLS0tLS0tJywgcmVzcG9uc2UpO1xuICAgICAgY29uc29sZS5sb2coJ2NhbGxiYWNrY2h1bmstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tJywgY2FsbGJhY2tjaHVuaylcbiAgICAgIGlmIChjYWxsYmFja2NodW5rICE9PSBudWxsKSB7XG4gICAgICAgIGF3YWl0IGNhbGxiYWNrY2h1bmsoKTtcbiAgICAgIH0gZWxzZSBhd2FpdCB0aGlzLmVuZEZldGNoKG1lc3NhZ2UpO1xuICAgIH0pO1xuICB9XG59Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/modules/files/js-dirtozip.js\n")}}]);