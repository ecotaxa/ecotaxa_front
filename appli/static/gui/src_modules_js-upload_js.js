/*! For license information please see src_modules_js-upload_js.js.LICENSE.txt */
"use strict";(self.webpackChunk=self.webpackChunk||[]).push([["src_modules_js-upload_js"],{"./src/modules/form-submit.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"FormSubmit\": () => (/* binding */ FormSubmit)\n/* harmony export */ });\n/* harmony import */ var dompurify__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! dompurify */ \"./node_modules/dompurify/dist/purify.js\");\n/* harmony import */ var dompurify__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(dompurify__WEBPACK_IMPORTED_MODULE_0__);\n\n\nlet instance = null;\nconst formcss = {\n  invalid: 'invalid',\n  inputvalidate: 'input-validate'\n}\nclass FormSubmit {\n  handlers = [];\n  form = null;\n  listener = null;\n  constructor(form, options = {}) {\n    if (!instance) {\n      if (!form) return;\n      const defaultOptions = {};\n      this.options = Object.assign(defaultOptions, options);\n      this.form = form instanceof HTMLElement ? form : document.querySelector(form);\n      this.validateFields(true);\n      this.init();\n      instance = this;\n    }\n    return instance;\n  }\n  init() {\n    // init the form ( options like beforeunload etc...)\n    this.form.addEventListener('submit', async (e) => {\n      console.log('----------------formsubmit', e)\n      const res = await this.submitForm();\n      if (!res) e.preventDefault();\n      return res;\n    });\n    // check if there is a password confirm input\n    this.form.querySelectorAll('input[data-match]').forEach(input => {\n      //\n      const match = input.dataset.match;\n      if (!match) return;\n      const target = document.getElementById(match);\n      if (!target) return;\n      const invalid = (input.dataset.matchinvalid) ? input.dataset.matchinvalid : \"no match\";\n      const label = input.closest('label');\n      const check_match = (item, itemtarget) => {\n        if (item.value !== itemtarget.value) {\n          item.setCustomValidity(invalid);\n          itemtarget.setCustomValidity(invalid);\n          if (input != item) {\n            if (label) label.classList.add(formcss.invalid);\n            input.classList.add(formcss.inputvalidate);\n          }\n        } else {\n          item.setCustomValidity(\"\");\n          itemtarget.setCustomValidity(\"\");\n          item.dataset.invalid = '';\n          itemtarget.dataset.invalid = '';\n          if (input != item) {\n            if (label) label.classList.remove(formcss.invalid);\n            input.classList.remove(formcss.inputvalidate);\n\n          }\n        }\n        item.reportValidity();\n        itemtarget.reportValidity();\n        item.focus();\n      };\n      [input, target].forEach(item => {\n        item.addEventListener('keyup', (e) => {\n          const itemtarget = (item === input) ? target : input;\n          check_match(item, itemtarget);\n        });\n      });\n\n    });\n  }\n\n  validateField(field) {\n\n    const get_message = (field) => {\n      let message = 'invalid';\n      if (field.required) message = (field.dataset.required) ? field.dataset.required : ((this.form.dataset.required) ? this.form.dataset.required : 'invalid');\n      if (message === 'invalid') message = (field.dataset.invalid) ? field.dataset.invalid : ((this.form.dataset.invalid) ? this.form.dataset.invalid : 'invalid input');\n      return message;\n    }\n\n\n    field.value = dompurify__WEBPACK_IMPORTED_MODULE_0___default().sanitize(field.value);\n    const rep = field.checkValidity();\n    const label = field.closest('.form-box') ? field.closest('.form-box').querySelector('label') : null;\n\n    if (rep && label) label.classList.remove(formcss.invalid);\n\n    else if (!rep) {\n      if (label) {\n        label.dataset.invalid = get_message(field);\n        label.classList.add(formcss.invalid);\n      }\n\n    }\n\n    if (field.classList.contains('tomselected') && field.nextElementSibling) {\n      field.nextElementSibling.classList.add(formcss.inputvalidate);\n    } else field.classList.add(formcss.inputvalidate);\n\n    return rep;\n  }\n\n  validateFields(init = false) {\n\n    // todo: complete validation foreach field type\n    let resp = true;\n\n    this.form.querySelectorAll('input,textarea, select').forEach(field => {\n      if (init === true) {\n        if (!field.dataset.listen) {\n          ['change', 'blur'].forEach(evt => {\n            field.addEventListener(evt, (e) => {\n              this.validateField(e.currentTarget);\n            });\n          });\n          field.dataset.listen = true;\n        }\n      } else {\n        const rep = this.validateField(field);\n        resp = (resp && rep);\n      }\n\n\n    });\n    return resp;\n  }\n  addHandler(handler) {\n    this.handlers.push(handler);\n  }\n  fieldEnable() {\n    this.form.querySelectorAll('input[data-sub=\"enable\"]').forEach(input => {\n      input.removeAttribute('disabled');\n    });\n  }\n  async submitHandler() {\n    if (!this.validateFields()) return false;\n    if (this.handlers.length === 0) return true;\n    let resp = true;\n    // series\n    /*  for (const handler of this.handlers) {\n          const rep = await handler()\n          resp = (resp && rep)\n      }*/\n    // concurrent\n    await Promise.all(this.handlers.map(async handler => {\n      const rep = await handler();\n      resp = (resp && rep);\n    }));\n    if (resp === true) this.handlers = [];\n    console.log('resp', resp)\n    return resp;\n  }\n  async submitForm() {\n    if (this.validateFields(false)) {\n      const yessubmit = await this.submitHandler();\n      if (yessubmit) {\n        this.fieldEnable();\n        this.form.submit();\n      } else return false;\n    } else return false;\n  }\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvbW9kdWxlcy9mb3JtLXN1Ym1pdC5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBa0M7QUFDQTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTzs7QUFFUCxLQUFLO0FBQ0w7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQSxrQkFBa0IseURBQWtCO0FBQ3BDO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFdBQVc7QUFDWDtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7O0FBR0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSLE1BQU07QUFDTjtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vc3JjL21vZHVsZXMvZm9ybS1zdWJtaXQuanM/YzZiNyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgdmFsaWRhdG9yIGZyb20gJ3ZhbGlkYXRvcic7XG5pbXBvcnQgRE9NUHVyaWZ5IGZyb20gJ2RvbXB1cmlmeSc7XG5sZXQgaW5zdGFuY2UgPSBudWxsO1xuY29uc3QgZm9ybWNzcyA9IHtcbiAgaW52YWxpZDogJ2ludmFsaWQnLFxuICBpbnB1dHZhbGlkYXRlOiAnaW5wdXQtdmFsaWRhdGUnXG59XG5leHBvcnQgY2xhc3MgRm9ybVN1Ym1pdCB7XG4gIGhhbmRsZXJzID0gW107XG4gIGZvcm0gPSBudWxsO1xuICBsaXN0ZW5lciA9IG51bGw7XG4gIGNvbnN0cnVjdG9yKGZvcm0sIG9wdGlvbnMgPSB7fSkge1xuICAgIGlmICghaW5zdGFuY2UpIHtcbiAgICAgIGlmICghZm9ybSkgcmV0dXJuO1xuICAgICAgY29uc3QgZGVmYXVsdE9wdGlvbnMgPSB7fTtcbiAgICAgIHRoaXMub3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oZGVmYXVsdE9wdGlvbnMsIG9wdGlvbnMpO1xuICAgICAgdGhpcy5mb3JtID0gZm9ybSBpbnN0YW5jZW9mIEhUTUxFbGVtZW50ID8gZm9ybSA6IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoZm9ybSk7XG4gICAgICB0aGlzLnZhbGlkYXRlRmllbGRzKHRydWUpO1xuICAgICAgdGhpcy5pbml0KCk7XG4gICAgICBpbnN0YW5jZSA9IHRoaXM7XG4gICAgfVxuICAgIHJldHVybiBpbnN0YW5jZTtcbiAgfVxuICBpbml0KCkge1xuICAgIC8vIGluaXQgdGhlIGZvcm0gKCBvcHRpb25zIGxpa2UgYmVmb3JldW5sb2FkIGV0Yy4uLilcbiAgICB0aGlzLmZvcm0uYWRkRXZlbnRMaXN0ZW5lcignc3VibWl0JywgYXN5bmMgKGUpID0+IHtcbiAgICAgIGNvbnNvbGUubG9nKCctLS0tLS0tLS0tLS0tLS0tZm9ybXN1Ym1pdCcsIGUpXG4gICAgICBjb25zdCByZXMgPSBhd2FpdCB0aGlzLnN1Ym1pdEZvcm0oKTtcbiAgICAgIGlmICghcmVzKSBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICByZXR1cm4gcmVzO1xuICAgIH0pO1xuICAgIC8vIGNoZWNrIGlmIHRoZXJlIGlzIGEgcGFzc3dvcmQgY29uZmlybSBpbnB1dFxuICAgIHRoaXMuZm9ybS5xdWVyeVNlbGVjdG9yQWxsKCdpbnB1dFtkYXRhLW1hdGNoXScpLmZvckVhY2goaW5wdXQgPT4ge1xuICAgICAgLy9cbiAgICAgIGNvbnN0IG1hdGNoID0gaW5wdXQuZGF0YXNldC5tYXRjaDtcbiAgICAgIGlmICghbWF0Y2gpIHJldHVybjtcbiAgICAgIGNvbnN0IHRhcmdldCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKG1hdGNoKTtcbiAgICAgIGlmICghdGFyZ2V0KSByZXR1cm47XG4gICAgICBjb25zdCBpbnZhbGlkID0gKGlucHV0LmRhdGFzZXQubWF0Y2hpbnZhbGlkKSA/IGlucHV0LmRhdGFzZXQubWF0Y2hpbnZhbGlkIDogXCJubyBtYXRjaFwiO1xuICAgICAgY29uc3QgbGFiZWwgPSBpbnB1dC5jbG9zZXN0KCdsYWJlbCcpO1xuICAgICAgY29uc3QgY2hlY2tfbWF0Y2ggPSAoaXRlbSwgaXRlbXRhcmdldCkgPT4ge1xuICAgICAgICBpZiAoaXRlbS52YWx1ZSAhPT0gaXRlbXRhcmdldC52YWx1ZSkge1xuICAgICAgICAgIGl0ZW0uc2V0Q3VzdG9tVmFsaWRpdHkoaW52YWxpZCk7XG4gICAgICAgICAgaXRlbXRhcmdldC5zZXRDdXN0b21WYWxpZGl0eShpbnZhbGlkKTtcbiAgICAgICAgICBpZiAoaW5wdXQgIT0gaXRlbSkge1xuICAgICAgICAgICAgaWYgKGxhYmVsKSBsYWJlbC5jbGFzc0xpc3QuYWRkKGZvcm1jc3MuaW52YWxpZCk7XG4gICAgICAgICAgICBpbnB1dC5jbGFzc0xpc3QuYWRkKGZvcm1jc3MuaW5wdXR2YWxpZGF0ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGl0ZW0uc2V0Q3VzdG9tVmFsaWRpdHkoXCJcIik7XG4gICAgICAgICAgaXRlbXRhcmdldC5zZXRDdXN0b21WYWxpZGl0eShcIlwiKTtcbiAgICAgICAgICBpdGVtLmRhdGFzZXQuaW52YWxpZCA9ICcnO1xuICAgICAgICAgIGl0ZW10YXJnZXQuZGF0YXNldC5pbnZhbGlkID0gJyc7XG4gICAgICAgICAgaWYgKGlucHV0ICE9IGl0ZW0pIHtcbiAgICAgICAgICAgIGlmIChsYWJlbCkgbGFiZWwuY2xhc3NMaXN0LnJlbW92ZShmb3JtY3NzLmludmFsaWQpO1xuICAgICAgICAgICAgaW5wdXQuY2xhc3NMaXN0LnJlbW92ZShmb3JtY3NzLmlucHV0dmFsaWRhdGUpO1xuXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGl0ZW0ucmVwb3J0VmFsaWRpdHkoKTtcbiAgICAgICAgaXRlbXRhcmdldC5yZXBvcnRWYWxpZGl0eSgpO1xuICAgICAgICBpdGVtLmZvY3VzKCk7XG4gICAgICB9O1xuICAgICAgW2lucHV0LCB0YXJnZXRdLmZvckVhY2goaXRlbSA9PiB7XG4gICAgICAgIGl0ZW0uYWRkRXZlbnRMaXN0ZW5lcigna2V5dXAnLCAoZSkgPT4ge1xuICAgICAgICAgIGNvbnN0IGl0ZW10YXJnZXQgPSAoaXRlbSA9PT0gaW5wdXQpID8gdGFyZ2V0IDogaW5wdXQ7XG4gICAgICAgICAgY2hlY2tfbWF0Y2goaXRlbSwgaXRlbXRhcmdldCk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG5cbiAgICB9KTtcbiAgfVxuXG4gIHZhbGlkYXRlRmllbGQoZmllbGQpIHtcblxuICAgIGNvbnN0IGdldF9tZXNzYWdlID0gKGZpZWxkKSA9PiB7XG4gICAgICBsZXQgbWVzc2FnZSA9ICdpbnZhbGlkJztcbiAgICAgIGlmIChmaWVsZC5yZXF1aXJlZCkgbWVzc2FnZSA9IChmaWVsZC5kYXRhc2V0LnJlcXVpcmVkKSA/IGZpZWxkLmRhdGFzZXQucmVxdWlyZWQgOiAoKHRoaXMuZm9ybS5kYXRhc2V0LnJlcXVpcmVkKSA/IHRoaXMuZm9ybS5kYXRhc2V0LnJlcXVpcmVkIDogJ2ludmFsaWQnKTtcbiAgICAgIGlmIChtZXNzYWdlID09PSAnaW52YWxpZCcpIG1lc3NhZ2UgPSAoZmllbGQuZGF0YXNldC5pbnZhbGlkKSA/IGZpZWxkLmRhdGFzZXQuaW52YWxpZCA6ICgodGhpcy5mb3JtLmRhdGFzZXQuaW52YWxpZCkgPyB0aGlzLmZvcm0uZGF0YXNldC5pbnZhbGlkIDogJ2ludmFsaWQgaW5wdXQnKTtcbiAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH1cblxuXG4gICAgZmllbGQudmFsdWUgPSBET01QdXJpZnkuc2FuaXRpemUoZmllbGQudmFsdWUpO1xuICAgIGNvbnN0IHJlcCA9IGZpZWxkLmNoZWNrVmFsaWRpdHkoKTtcbiAgICBjb25zdCBsYWJlbCA9IGZpZWxkLmNsb3Nlc3QoJy5mb3JtLWJveCcpID8gZmllbGQuY2xvc2VzdCgnLmZvcm0tYm94JykucXVlcnlTZWxlY3RvcignbGFiZWwnKSA6IG51bGw7XG5cbiAgICBpZiAocmVwICYmIGxhYmVsKSBsYWJlbC5jbGFzc0xpc3QucmVtb3ZlKGZvcm1jc3MuaW52YWxpZCk7XG5cbiAgICBlbHNlIGlmICghcmVwKSB7XG4gICAgICBpZiAobGFiZWwpIHtcbiAgICAgICAgbGFiZWwuZGF0YXNldC5pbnZhbGlkID0gZ2V0X21lc3NhZ2UoZmllbGQpO1xuICAgICAgICBsYWJlbC5jbGFzc0xpc3QuYWRkKGZvcm1jc3MuaW52YWxpZCk7XG4gICAgICB9XG5cbiAgICB9XG5cbiAgICBpZiAoZmllbGQuY2xhc3NMaXN0LmNvbnRhaW5zKCd0b21zZWxlY3RlZCcpICYmIGZpZWxkLm5leHRFbGVtZW50U2libGluZykge1xuICAgICAgZmllbGQubmV4dEVsZW1lbnRTaWJsaW5nLmNsYXNzTGlzdC5hZGQoZm9ybWNzcy5pbnB1dHZhbGlkYXRlKTtcbiAgICB9IGVsc2UgZmllbGQuY2xhc3NMaXN0LmFkZChmb3JtY3NzLmlucHV0dmFsaWRhdGUpO1xuXG4gICAgcmV0dXJuIHJlcDtcbiAgfVxuXG4gIHZhbGlkYXRlRmllbGRzKGluaXQgPSBmYWxzZSkge1xuXG4gICAgLy8gdG9kbzogY29tcGxldGUgdmFsaWRhdGlvbiBmb3JlYWNoIGZpZWxkIHR5cGVcbiAgICBsZXQgcmVzcCA9IHRydWU7XG5cbiAgICB0aGlzLmZvcm0ucXVlcnlTZWxlY3RvckFsbCgnaW5wdXQsdGV4dGFyZWEsIHNlbGVjdCcpLmZvckVhY2goZmllbGQgPT4ge1xuICAgICAgaWYgKGluaXQgPT09IHRydWUpIHtcbiAgICAgICAgaWYgKCFmaWVsZC5kYXRhc2V0Lmxpc3Rlbikge1xuICAgICAgICAgIFsnY2hhbmdlJywgJ2JsdXInXS5mb3JFYWNoKGV2dCA9PiB7XG4gICAgICAgICAgICBmaWVsZC5hZGRFdmVudExpc3RlbmVyKGV2dCwgKGUpID0+IHtcbiAgICAgICAgICAgICAgdGhpcy52YWxpZGF0ZUZpZWxkKGUuY3VycmVudFRhcmdldCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBmaWVsZC5kYXRhc2V0Lmxpc3RlbiA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IHJlcCA9IHRoaXMudmFsaWRhdGVGaWVsZChmaWVsZCk7XG4gICAgICAgIHJlc3AgPSAocmVzcCAmJiByZXApO1xuICAgICAgfVxuXG5cbiAgICB9KTtcbiAgICByZXR1cm4gcmVzcDtcbiAgfVxuICBhZGRIYW5kbGVyKGhhbmRsZXIpIHtcbiAgICB0aGlzLmhhbmRsZXJzLnB1c2goaGFuZGxlcik7XG4gIH1cbiAgZmllbGRFbmFibGUoKSB7XG4gICAgdGhpcy5mb3JtLnF1ZXJ5U2VsZWN0b3JBbGwoJ2lucHV0W2RhdGEtc3ViPVwiZW5hYmxlXCJdJykuZm9yRWFjaChpbnB1dCA9PiB7XG4gICAgICBpbnB1dC5yZW1vdmVBdHRyaWJ1dGUoJ2Rpc2FibGVkJyk7XG4gICAgfSk7XG4gIH1cbiAgYXN5bmMgc3VibWl0SGFuZGxlcigpIHtcbiAgICBpZiAoIXRoaXMudmFsaWRhdGVGaWVsZHMoKSkgcmV0dXJuIGZhbHNlO1xuICAgIGlmICh0aGlzLmhhbmRsZXJzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHRydWU7XG4gICAgbGV0IHJlc3AgPSB0cnVlO1xuICAgIC8vIHNlcmllc1xuICAgIC8qICBmb3IgKGNvbnN0IGhhbmRsZXIgb2YgdGhpcy5oYW5kbGVycykge1xuICAgICAgICAgIGNvbnN0IHJlcCA9IGF3YWl0IGhhbmRsZXIoKVxuICAgICAgICAgIHJlc3AgPSAocmVzcCAmJiByZXApXG4gICAgICB9Ki9cbiAgICAvLyBjb25jdXJyZW50XG4gICAgYXdhaXQgUHJvbWlzZS5hbGwodGhpcy5oYW5kbGVycy5tYXAoYXN5bmMgaGFuZGxlciA9PiB7XG4gICAgICBjb25zdCByZXAgPSBhd2FpdCBoYW5kbGVyKCk7XG4gICAgICByZXNwID0gKHJlc3AgJiYgcmVwKTtcbiAgICB9KSk7XG4gICAgaWYgKHJlc3AgPT09IHRydWUpIHRoaXMuaGFuZGxlcnMgPSBbXTtcbiAgICBjb25zb2xlLmxvZygncmVzcCcsIHJlc3ApXG4gICAgcmV0dXJuIHJlc3A7XG4gIH1cbiAgYXN5bmMgc3VibWl0Rm9ybSgpIHtcbiAgICBpZiAodGhpcy52YWxpZGF0ZUZpZWxkcyhmYWxzZSkpIHtcbiAgICAgIGNvbnN0IHllc3N1Ym1pdCA9IGF3YWl0IHRoaXMuc3VibWl0SGFuZGxlcigpO1xuICAgICAgaWYgKHllc3N1Ym1pdCkge1xuICAgICAgICB0aGlzLmZpZWxkRW5hYmxlKCk7XG4gICAgICAgIHRoaXMuZm9ybS5zdWJtaXQoKTtcbiAgICAgIH0gZWxzZSByZXR1cm4gZmFsc2U7XG4gICAgfSBlbHNlIHJldHVybiBmYWxzZTtcbiAgfVxufSJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/modules/form-submit.js\n")},"./src/modules/js-upload.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"JsUpload\": () => (/* binding */ JsUpload)\n/* harmony export */ });\n/* harmony import */ var dompurify__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! dompurify */ \"./node_modules/dompurify/dist/purify.js\");\n/* harmony import */ var dompurify__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(dompurify__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var fflate__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! fflate */ \"./node_modules/fflate/esm/browser.js\");\n/* harmony import */ var _modules_form_submit_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../modules/form-submit.js */ \"./src/modules/form-submit.js\");\n/* harmony import */ var _modules_utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../modules/utils.js */ \"./src/modules/utils.js\");\n/* harmony import */ var _modules_modules_config_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../modules/modules-config.js */ \"./src/modules/modules-config.js\");\n\n\n\n\n\nconst already_compressed = new Set([\n  'zip', 'gz', 'png', 'jpg', 'jpeg', 'pdf', 'doc', 'docx', 'ppt', 'pptx',\n  'xls', 'xlsx', 'heic', 'heif', '7z', 'bz2', 'rar', 'gif', 'webp', 'webm',\n  'mp4', 'mov', 'mp3', 'aifc'\n]);\nconst accept = '.tsv,.png,.jpg, .jpeg,.zip,.gz,.7z,.bz2';\nconst largefile = 5000000;\nconst chunksize = 2000000;\nlet instance = null;\nconst defdir = \"ecotaxa_import\";\nclass JsUpload {\n  zipstream;\n  zipsize = 0;\n  pathname;\n  zipname;\n  counter = 0;\n  counterdisplay = null;\n  ziptrigger = null;\n  displaylist = null;\n  timer = 0;\n  targetdir = '';\n  dropzone;\n  constructor(container, callback = null, options = {}) {\n    if (instance) return instance;\n    container = (container instanceof HTMLElement) ? container : document.querySelector(container);\n    if (!container) return;\n    this.container = container;\n    this.callback = callback;\n    const defaultOptions = {\n      level: 0,\n      url: \"http://193.49.112.116:5001/gui/job/my_files/\",\n      filefield: 'file',\n      selector: {\n        makezip: '.makezip',\n        droptarget: '.droptarget',\n        trigger: '.trigger',\n        uploadfile: 'uploadfile',\n        formu: 'formupload',\n        stepper: 'stepper',\n        stepitem: 'stepper-item',\n        filetoload: 'file_to_load',\n        progress: \"progress-upload\"\n      },\n      display: {\n        dropzone: 'dropzone',\n        counter: 'counter',\n        size: 'sizetozip',\n        counterzipped: 'counterzipped',\n        sizezipped: 'sizezipped',\n        dirlist: 'dirlist',\n        boxtitle: 'boxtitle',\n        timer: 'timer'\n      },\n      css: {\n        enabled: 'enabled'\n      }\n    };\n\n    this.options = Object.assign(defaultOptions, options);\n\n    this.init(container);\n    instance = this;\n    return instance;\n  }\n\n  init(container) {\n    // create a filepicker depends on browser\n    this.dropzone = document.createElement('div');\n    this.dropzone.id = this.options.display.dropzone;\n    this.dropzone.innerHTML = `<input type=\"file\" class=\"hidden\"  name=\"${this.options.selector.uploadfile}\" id=\"${this.options.selector.uploadfile}\">\n            <div class=\"${this.options.selector.droptarget.slice(1)}\">\n            <div id=\"${this.options.display.boxtitle}\"><span class=\"${this.options.selector.trigger.slice(1)}\">${this.container.dataset.textbrowse}</span>  ${this.container.dataset.textdrop}</div>\n          </div><div><span id=\"${this.options.display.counter}\"></span>/<span id=\"${this.options.display.counterzipped}\"></span></div>\n          <div><span id=\"${this.options.display.size}\"></span>/<span id=\"${this.options.display.sizezipped}\"></span></div><div id=\"${this.options.display.timer}\"></div>\n          <div id=\"${this.options.selector.makezip.slice(1)}\" class=\"button ${this.options.selector.makezip.slice(1)} ${_modules_modules_config_js__WEBPACK_IMPORTED_MODULE_3__.css.hide} \"><div id=\"${this.options.selector.progress}\"></div>${container.dataset.ended}</div>`;\n    container.append(this.dropzone);\n    this.counterdisplay = document.getElementById(this.options.display.counter);\n    this.counterzippeddisplay = document.getElementById(this.options.display.counterzipped);\n    this.sizedisplay = document.getElementById(this.options.display.size);\n    this.sizezippeddisplay = document.getElementById(this.options.display.sizezipped);\n    this.ziptrigger = container.querySelector(this.options.selector.makezip);\n    this.displaylist = document.getElementById(this.options.display.dirlist);\n    const droptarget = this.container.querySelector(this.options.selector.droptarget);\n    droptarget.addEventListener('dragover', (e) => {\n      this.handleDragOver(e);\n    });\n    droptarget.addEventListener('drop', async (e) => {\n      this.handleDrop(e);\n\n    });\n    container.querySelector(this.options.selector.trigger).addEventListener('click', (e) => {\n      let datatransfer = e;\n      this.openDirDialog(accept, (e) => {\n        console.log('edrop', datatransfer)\n      });\n    });\n  }\n  attachDropzone(target) {\n    console.log('attch', target);\n    this.targetdir = (target.parentElement.dataset.name) ? target.parentElement.dataset.name : '';\n    console.log('targetdir', this.targetdir)\n    this.dropzone.classList.add(this.options.css.enabled);\n    console.log('att', this.dropzone);\n    target.append(this.dropzone);\n  }\n  detachDropzone() {\n    this.targetdir = null;\n    this.container.classList.remove(this.options.css.enabled);\n\n  }\n  openDirDialog(accept, callback) {\n    const input = document.createElement(\"input\");\n    input.type = \"file\";\n    input.directory = true;\n    input.multiple = true;\n    input.webkitdirectory = true;\n    input.allowdirs = true;\n    input.accept = accept;\n    input.addEventListener(\"change\", callback);\n    input.dispatchEvent(new MouseEvent(\"click\"));\n  }\n  handleDragOver(e) {\n    e.preventDefault();\n    e.dataTransfer.dropEffect = \"move\";\n  }\n\n  handleDrop(e) {\n    let dataTransfer;\n    if (e.dataTransfer) {\n      e.preventDefault();\n      dataTransfer = e.dataTransfer;\n    } else dataTransfer = e;\n    const items = [...((dataTransfer.items) ? dataTransfer.items : dataTransfer.files)];\n\n    for (let i = 0; i < items.length; i++) {\n      let item = items[i].webkitGetAsEntry();\n      if (item.isDirectory === true) {\n        this.enableDropzone(false);\n        const on_complete = (entries, zip, zipReadableStream, on_error) => {\n          this.timer = new Date();\n\n          console.log('item-------------------------------------', zip);\n          this.enableDropzone();\n\n          this.ziptrigger.classList.remove(_modules_modules_config_js__WEBPACK_IMPORTED_MODULE_3__.css.hide);\n          this.ziptrigger.addEventListener('click', (e) => {\n            console.log('upload click')\n            zip.end();\n            this.enableDropzone(false, true);\n            const zipResponse = new Response(zipReadableStream);\n            console.log('zipResp', zipResponse)\n            this.sendZip(zipResponse);\n          });\n        }\n        const on_error = (err) => {\n          console.log('err_read_dir', err);\n        }\n        this.zipname = item.name + '.zip';\n        this.pathname = item.fullPath.slice(1).split('.');\n        //this.pathname.pop();\n        this.readDirectory(item, on_complete, on_error);\n\n      } else if (item.isFile === true) {\n        // put directly in input file\n\n      }\n\n    }\n\n  }\n  stopOnError(err) {\n    console.log('err', err);\n  }\n\n  incrementCounter(size) {\n    this.counter++;\n    this.counterdisplay.textContent = this.counter;\n  }\n  decrementCounter(size) {\n    this.counter--;\n    this.counterdisplay.textContent = this.counter;\n  }\n\n  enableDropzone(enable = true, destroy = false) {\n    if (destroy) this.dropzone.classList.add(_modules_modules_config_js__WEBPACK_IMPORTED_MODULE_3__.css.hide);\n    if (enable) this.dropzone.classList.add(this.options.css.enabled);\n    else this.dropzone.classList.remove(this.options.css.enabled);\n\n  }\n  fileType(data) {\n    const mime_type = (signature) => {\n      switch (signature) {\n        case '89504E47':\n          return 'image/png';\n        case '47494638':\n          return 'image/gif';\n        case '25504446':\n          return 'application/pdf';\n        case 'FFD8FFDB':\n        case 'FFD8FFE0':\n        case 'FFD8FFE1':\n          return 'image/jpeg';\n        case '504B0304':\n          return 'application/zip';\n        case 'EFBBBF22':\n          return 'text/tsv'; //'text/tab-separated-values';\n        default:\n          console.log('unknownsign', signature)\n          return 'unknown';\n      }\n    }\n    const uint = new Uint8Array(data);\n    let bytes = []\n    for (let i = 0; i < 4; i++) {\n      bytes.push(uint[i].toString(16))\n    }\n    data = bytes.join('').toUpperCase();\n    return {\n      input: uint,\n      mimetype: mime_type(data)\n    };\n  }\n  fflToStream(fflateStream) {\n    const self = this\n    return new ReadableStream({\n      start(controller) {\n        fflateStream.ondata = (error, data, final) => {\n          if (error) {\n            controller.error(error);\n          } else {\n            self.zipsize += data.length;\n            controller.enqueue(data);\n            if (final) {\n              controller.close();\n\n            }\n          }\n        }\n      },\n      cancel() {\n        fflateStream.terminate();\n      }\n    });\n  }\n  //\n\n  async readDirectory(dir, oncomplete, onerror, zip, zipReadableStream) {\n    let errored = false;\n    let final = false;\n    let total = 0;\n    let direntries = [],\n      handlers = [];\n\n    const on_error = (err) => {\n      console.log('on_error', err)\n      if (!errored) {\n        errored = true;\n        onerror(err);\n      }\n    };\n    zip = zip ? zip : new fflate__WEBPACK_IMPORTED_MODULE_4__.Zip();\n    zipReadableStream = zipReadableStream ? zipReadableStream : this.fflToStream(zip);\n\n    fetch(this.options.url, (0,_modules_utils_js__WEBPACK_IMPORTED_MODULE_2__.fetchSettings)({\n      mode: 'cors',\n      method: 'POST',\n      body: zip,\n      headers: {\n        'Content-Type': 'Application/octet-stream',\n      },\n      duplex: 'half'\n    })).then(response => {\n      console.log('response', response);\n    });\n    const process_file = async (f, filename, callback) => {\n      this.incrementCounter(f.size);\n      this.addFileToZip(f, filename, zip, callback);\n\n    };\n    const process_serialize = async () => {\n      // series\n      if (handlers.length) {\n        const handler = handlers.shift();\n        await handler();\n        process_serialize();\n      }\n\n\n    }\n\n    const on_done = async (entries, zip, zipReadableStream, on_error) => {\n      if (entries.length) {\n        const entry = entries.shift();\n        if (entry.isFile) {\n          const callback = () => {\n\n            console.log('entrieslengthleft ', entries.length)\n\n            if (!entries.length && handlers.length) {\n              console.log('serialize')\n              process_serialize();\n            }\n            if (final && !entries.length) {\n              console.log('oncomplete');\n              oncomplete([], zip, zipReadableStream, on_error);\n            } else on_done(entries, zip, zipReadableStream, on_error);\n          }\n          entry.file(f => process_file(f, entry.fullPath.slice(1), callback)); //\n\n        } else if (entry.isDirectory) handlers.push(async () => {\n          this.readDirectory(entry, on_done, on_error, zip, zipReadableStream);\n\n        });\n      }\n    }\n\n    const reader = dir.createReader();\n    const on_read = async (entries) => {\n      if (!entries.length && !errored) {\n        if (!direntries.length) oncomplete([], zip, zipReadableStream, on_error);\n        else final = true;\n      } else await reader.readEntries(on_read, on_error);\n      direntries = [...direntries, ...entries];\n      if (final) on_done(direntries, zip, zipReadableStream, on_error);\n    }\n    reader.readEntries(on_read, on_error);\n\n  }\n\n  compressionLevel(name) {\n    if (!name) {\n      console.log('name', name);\n      return -1;\n    }\n    let ext = name.split('.');\n    ext = (ext.length > 1) ? ext[ext.length - 1] : ext[0];\n    return (already_compressed.find(ex => (ex === ext))) ? 2 : this.options.level;\n  }\n\n  sendZip(response) {\n    //  const filestream = new WritableStream();\n    //  const writer = filestream.getWriter();\n    //\n    let chunkcounter;\n\n    const numchunks = Math.round(this.zipsize / chunksize);\n    const update_progress = (e) => {\n      const progress = document.getElementById(this.options.selector.progress);\n      if (e.lengthComputable) {\n        const percent = Math.round(e.loaded / this.zipsize * 100);\n        const total = Math.round((chunkcounter - 1) / numchunks * 100 + percent / numchunks);\n        progress.innerHTML = \"Chunk # \" + chunkcounter + \" is \" + percent + \"% uploaded. Total uploaded: \" + total + \"%\";\n      } else {\n        console.log(\"not computable\");\n      }\n    }\n\n    const readstream = async () => {\n      const reader = response.body.getReader();\n\n      let data = [];\n      let start = 0;\n      let datalength = 0;\n      while (true) {\n        const {\n          done,\n          value\n        } = await reader.read();\n        if (done) {\n          //writer.write(new Uint8Array(0), true);\n\n          //writer.close();\n          fetch_range(data, start, datalength, true);\n          return;\n        }\n        //writer.write(value);\n        data.push(value);\n        datalength += value.length;\n        if (datalength >= chunksize) {\n          fetch_range(data, start, datalength, false);\n          start += datalength;\n          data = [];\n          datalength = 0;\n        }\n      }\n      reader.releaseLock();\n    }\n    //  readstream();\n\n    const to_hex = (str) => {\n      const encoder = new TextEncoder();\n      return Array\n        .from(encoder.encode(str))\n        .map(b => b.toString(16).padStart(2, '0'))\n        .join('')\n\n    }\n    const fetch_range = (data, start, datalength, final = false) => {\n      console.log('fetch_range ' + final + ' start=' + start + 'end=' + datalength, data)\n      const formdata = new FormData();\n      formdata.append('path', this.pathname);\n      formdata.append('tag', defdir);\n      if (final) formdata.append('final', final);\n      formdata.append(this.options.filefield, new Blob(data), this.zipname);\n      /*new File(data, this.zipname, {\n           content_type: \"application/zip\",\n             lastModified: new Date()\n         });*/\n      const end = start + datalength;\n      data = to_hex(datalength) + `\\r\\n` + data + `\\r\\n`;\n      const request = new Request(this.options.url, (0,_modules_utils_js__WEBPACK_IMPORTED_MODULE_2__.fetchSettings)({\n        //    mode: 'cors',\n        method: 'POST',\n        body: formdata,\n        //  range: 'bytes=' + start + '-' + parseInt(start + end),\n        headers: {\n          'Content-Type': 'Application/octet-stream',\n          'Transfer-Encoding': 'chunked',\n          'Content-Range': 'bytes ' + start + '-' + end + '/' + this.zipsize\n        },\n        //  duplex: 'half'\n      }));\n      fetch(request).then(res => res.json()).then(json => {\n        if (final) {\n          const filetoload = document.getElementById(this.options.selector.filetoload);\n          if (filetoload) filetoload.value = dompurify__WEBPACK_IMPORTED_MODULE_0___default().sanitize(json);\n          console.log('json', json)\n          console.log('timer', (new Date() - this.timer) / 1000);\n          console.log('sent');\n          if (this.callback) this.callback(json, defdir);\n        } else return [];\n      }).catch(err => {\n        console.log('reserror', err)\n      });\n    }\n\n  }\n  async addFileToZip(file, filepath, zip, callback) {\n    const self = this;\n    const ext = filepath.slice(filepath.lastIndexOf('.') + 1);\n    const zippedstream = already_compressed.has(ext) ?\n      new fflate__WEBPACK_IMPORTED_MODULE_4__.ZipPassThrough(filepath) :\n      file.size > largefile ?\n      new fflate__WEBPACK_IMPORTED_MODULE_4__.AsyncZipDeflate(filepath, {\n        level: 9\n      }) : new fflate__WEBPACK_IMPORTED_MODULE_4__.ZipDeflate(filepath, {\n        level: 9\n      });\n    zippedstream.ondata = (err, chunk, final) => {\n      if (err) console.log('err add chunk to zipfile' + chunk, err);\n      if (final) {\n\n      }\n    }\n    zip.add(zippedstream);\n\n    const readfile = async () => {\n      const reader = file.stream().getReader();\n      try {\n        while (true) {\n          const {\n            done,\n            value\n          } = await reader.read();\n          if (done) {\n\n            zippedstream.push(new Uint8Array(0), true);\n            self.decrementCounter(file.size);\n            if (callback) callback();\n            return done;\n          }\n          zippedstream.push(value);\n        }\n      } finally {\n        reader.releaseLock();\n      }\n    }\n    return await readfile();\n  }\n\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QWU7QUFDekI7QUFDQSxPQUFPLFFBQVEsOENBQVU7QUFDekI7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vc3JjL21vZHVsZXMvanMtdXBsb2FkLmpzPzdjNDgiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IERPTVB1cmlmeSBmcm9tICdkb21wdXJpZnknO1xuaW1wb3J0IHtcbiAgWmlwLFxuICBBc3luY1ppcERlZmxhdGUsXG4gIFppcFBhc3NUaHJvdWdoLFxuICBaaXBEZWZsYXRlXG59IGZyb20gJ2ZmbGF0ZSc7XG5pbXBvcnQge1xuICBGb3JtU3VibWl0XG59IGZyb20gJy4uL21vZHVsZXMvZm9ybS1zdWJtaXQuanMnO1xuaW1wb3J0IHtcbiAgZG93bmxvYWRfYmxvYixcbiAgZmV0Y2hTZXR0aW5ncyxcbn0gZnJvbSAnLi4vbW9kdWxlcy91dGlscy5qcyc7XG5pbXBvcnQge1xuICBjc3Ncbn0gZnJvbSAnLi4vbW9kdWxlcy9tb2R1bGVzLWNvbmZpZy5qcyc7XG5jb25zdCBhbHJlYWR5X2NvbXByZXNzZWQgPSBuZXcgU2V0KFtcbiAgJ3ppcCcsICdneicsICdwbmcnLCAnanBnJywgJ2pwZWcnLCAncGRmJywgJ2RvYycsICdkb2N4JywgJ3BwdCcsICdwcHR4JyxcbiAgJ3hscycsICd4bHN4JywgJ2hlaWMnLCAnaGVpZicsICc3eicsICdiejInLCAncmFyJywgJ2dpZicsICd3ZWJwJywgJ3dlYm0nLFxuICAnbXA0JywgJ21vdicsICdtcDMnLCAnYWlmYydcbl0pO1xuY29uc3QgYWNjZXB0ID0gJy50c3YsLnBuZywuanBnLCAuanBlZywuemlwLC5neiwuN3osLmJ6Mic7XG5jb25zdCBsYXJnZWZpbGUgPSA1MDAwMDAwO1xuY29uc3QgY2h1bmtzaXplID0gMjAwMDAwMDtcbmxldCBpbnN0YW5jZSA9IG51bGw7XG5jb25zdCBkZWZkaXIgPSBcImVjb3RheGFfaW1wb3J0XCI7XG5leHBvcnQgY2xhc3MgSnNVcGxvYWQge1xuICB6aXBzdHJlYW07XG4gIHppcHNpemUgPSAwO1xuICBwYXRobmFtZTtcbiAgemlwbmFtZTtcbiAgY291bnRlciA9IDA7XG4gIGNvdW50ZXJkaXNwbGF5ID0gbnVsbDtcbiAgemlwdHJpZ2dlciA9IG51bGw7XG4gIGRpc3BsYXlsaXN0ID0gbnVsbDtcbiAgdGltZXIgPSAwO1xuICB0YXJnZXRkaXIgPSAnJztcbiAgZHJvcHpvbmU7XG4gIGNvbnN0cnVjdG9yKGNvbnRhaW5lciwgY2FsbGJhY2sgPSBudWxsLCBvcHRpb25zID0ge30pIHtcbiAgICBpZiAoaW5zdGFuY2UpIHJldHVybiBpbnN0YW5jZTtcbiAgICBjb250YWluZXIgPSAoY29udGFpbmVyIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQpID8gY29udGFpbmVyIDogZG9jdW1lbnQucXVlcnlTZWxlY3Rvcihjb250YWluZXIpO1xuICAgIGlmICghY29udGFpbmVyKSByZXR1cm47XG4gICAgdGhpcy5jb250YWluZXIgPSBjb250YWluZXI7XG4gICAgdGhpcy5jYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgIGNvbnN0IGRlZmF1bHRPcHRpb25zID0ge1xuICAgICAgbGV2ZWw6IDAsXG4gICAgICB1cmw6IFwiaHR0cDovLzE5My40OS4xMTIuMTE2OjUwMDEvZ3VpL2pvYi9teV9maWxlcy9cIixcbiAgICAgIGZpbGVmaWVsZDogJ2ZpbGUnLFxuICAgICAgc2VsZWN0b3I6IHtcbiAgICAgICAgbWFrZXppcDogJy5tYWtlemlwJyxcbiAgICAgICAgZHJvcHRhcmdldDogJy5kcm9wdGFyZ2V0JyxcbiAgICAgICAgdHJpZ2dlcjogJy50cmlnZ2VyJyxcbiAgICAgICAgdXBsb2FkZmlsZTogJ3VwbG9hZGZpbGUnLFxuICAgICAgICBmb3JtdTogJ2Zvcm11cGxvYWQnLFxuICAgICAgICBzdGVwcGVyOiAnc3RlcHBlcicsXG4gICAgICAgIHN0ZXBpdGVtOiAnc3RlcHBlci1pdGVtJyxcbiAgICAgICAgZmlsZXRvbG9hZDogJ2ZpbGVfdG9fbG9hZCcsXG4gICAgICAgIHByb2dyZXNzOiBcInByb2dyZXNzLXVwbG9hZFwiXG4gICAgICB9LFxuICAgICAgZGlzcGxheToge1xuICAgICAgICBkcm9wem9uZTogJ2Ryb3B6b25lJyxcbiAgICAgICAgY291bnRlcjogJ2NvdW50ZXInLFxuICAgICAgICBzaXplOiAnc2l6ZXRvemlwJyxcbiAgICAgICAgY291bnRlcnppcHBlZDogJ2NvdW50ZXJ6aXBwZWQnLFxuICAgICAgICBzaXplemlwcGVkOiAnc2l6ZXppcHBlZCcsXG4gICAgICAgIGRpcmxpc3Q6ICdkaXJsaXN0JyxcbiAgICAgICAgYm94dGl0bGU6ICdib3h0aXRsZScsXG4gICAgICAgIHRpbWVyOiAndGltZXInXG4gICAgICB9LFxuICAgICAgY3NzOiB7XG4gICAgICAgIGVuYWJsZWQ6ICdlbmFibGVkJ1xuICAgICAgfVxuICAgIH07XG5cbiAgICB0aGlzLm9wdGlvbnMgPSBPYmplY3QuYXNzaWduKGRlZmF1bHRPcHRpb25zLCBvcHRpb25zKTtcblxuICAgIHRoaXMuaW5pdChjb250YWluZXIpO1xuICAgIGluc3RhbmNlID0gdGhpcztcbiAgICByZXR1cm4gaW5zdGFuY2U7XG4gIH1cblxuICBpbml0KGNvbnRhaW5lcikge1xuICAgIC8vIGNyZWF0ZSBhIGZpbGVwaWNrZXIgZGVwZW5kcyBvbiBicm93c2VyXG4gICAgdGhpcy5kcm9wem9uZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIHRoaXMuZHJvcHpvbmUuaWQgPSB0aGlzLm9wdGlvbnMuZGlzcGxheS5kcm9wem9uZTtcbiAgICB0aGlzLmRyb3B6b25lLmlubmVySFRNTCA9IGA8aW5wdXQgdHlwZT1cImZpbGVcIiBjbGFzcz1cImhpZGRlblwiICBuYW1lPVwiJHt0aGlzLm9wdGlvbnMuc2VsZWN0b3IudXBsb2FkZmlsZX1cIiBpZD1cIiR7dGhpcy5vcHRpb25zLnNlbGVjdG9yLnVwbG9hZGZpbGV9XCI+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwiJHt0aGlzLm9wdGlvbnMuc2VsZWN0b3IuZHJvcHRhcmdldC5zbGljZSgxKX1cIj5cbiAgICAgICAgICAgIDxkaXYgaWQ9XCIke3RoaXMub3B0aW9ucy5kaXNwbGF5LmJveHRpdGxlfVwiPjxzcGFuIGNsYXNzPVwiJHt0aGlzLm9wdGlvbnMuc2VsZWN0b3IudHJpZ2dlci5zbGljZSgxKX1cIj4ke3RoaXMuY29udGFpbmVyLmRhdGFzZXQudGV4dGJyb3dzZX08L3NwYW4+ICAke3RoaXMuY29udGFpbmVyLmRhdGFzZXQudGV4dGRyb3B9PC9kaXY+XG4gICAgICAgICAgPC9kaXY+PGRpdj48c3BhbiBpZD1cIiR7dGhpcy5vcHRpb25zLmRpc3BsYXkuY291bnRlcn1cIj48L3NwYW4+LzxzcGFuIGlkPVwiJHt0aGlzLm9wdGlvbnMuZGlzcGxheS5jb3VudGVyemlwcGVkfVwiPjwvc3Bhbj48L2Rpdj5cbiAgICAgICAgICA8ZGl2PjxzcGFuIGlkPVwiJHt0aGlzLm9wdGlvbnMuZGlzcGxheS5zaXplfVwiPjwvc3Bhbj4vPHNwYW4gaWQ9XCIke3RoaXMub3B0aW9ucy5kaXNwbGF5LnNpemV6aXBwZWR9XCI+PC9zcGFuPjwvZGl2PjxkaXYgaWQ9XCIke3RoaXMub3B0aW9ucy5kaXNwbGF5LnRpbWVyfVwiPjwvZGl2PlxuICAgICAgICAgIDxkaXYgaWQ9XCIke3RoaXMub3B0aW9ucy5zZWxlY3Rvci5tYWtlemlwLnNsaWNlKDEpfVwiIGNsYXNzPVwiYnV0dG9uICR7dGhpcy5vcHRpb25zLnNlbGVjdG9yLm1ha2V6aXAuc2xpY2UoMSl9ICR7Y3NzLmhpZGV9IFwiPjxkaXYgaWQ9XCIke3RoaXMub3B0aW9ucy5zZWxlY3Rvci5wcm9ncmVzc31cIj48L2Rpdj4ke2NvbnRhaW5lci5kYXRhc2V0LmVuZGVkfTwvZGl2PmA7XG4gICAgY29udGFpbmVyLmFwcGVuZCh0aGlzLmRyb3B6b25lKTtcbiAgICB0aGlzLmNvdW50ZXJkaXNwbGF5ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQodGhpcy5vcHRpb25zLmRpc3BsYXkuY291bnRlcik7XG4gICAgdGhpcy5jb3VudGVyemlwcGVkZGlzcGxheSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHRoaXMub3B0aW9ucy5kaXNwbGF5LmNvdW50ZXJ6aXBwZWQpO1xuICAgIHRoaXMuc2l6ZWRpc3BsYXkgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCh0aGlzLm9wdGlvbnMuZGlzcGxheS5zaXplKTtcbiAgICB0aGlzLnNpemV6aXBwZWRkaXNwbGF5ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQodGhpcy5vcHRpb25zLmRpc3BsYXkuc2l6ZXppcHBlZCk7XG4gICAgdGhpcy56aXB0cmlnZ2VyID0gY29udGFpbmVyLnF1ZXJ5U2VsZWN0b3IodGhpcy5vcHRpb25zLnNlbGVjdG9yLm1ha2V6aXApO1xuICAgIHRoaXMuZGlzcGxheWxpc3QgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCh0aGlzLm9wdGlvbnMuZGlzcGxheS5kaXJsaXN0KTtcbiAgICBjb25zdCBkcm9wdGFyZ2V0ID0gdGhpcy5jb250YWluZXIucXVlcnlTZWxlY3Rvcih0aGlzLm9wdGlvbnMuc2VsZWN0b3IuZHJvcHRhcmdldCk7XG4gICAgZHJvcHRhcmdldC5hZGRFdmVudExpc3RlbmVyKCdkcmFnb3ZlcicsIChlKSA9PiB7XG4gICAgICB0aGlzLmhhbmRsZURyYWdPdmVyKGUpO1xuICAgIH0pO1xuICAgIGRyb3B0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcignZHJvcCcsIGFzeW5jIChlKSA9PiB7XG4gICAgICB0aGlzLmhhbmRsZURyb3AoZSk7XG5cbiAgICB9KTtcbiAgICBjb250YWluZXIucXVlcnlTZWxlY3Rvcih0aGlzLm9wdGlvbnMuc2VsZWN0b3IudHJpZ2dlcikuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoZSkgPT4ge1xuICAgICAgbGV0IGRhdGF0cmFuc2ZlciA9IGU7XG4gICAgICB0aGlzLm9wZW5EaXJEaWFsb2coYWNjZXB0LCAoZSkgPT4ge1xuICAgICAgICBjb25zb2xlLmxvZygnZWRyb3AnLCBkYXRhdHJhbnNmZXIpXG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuICBhdHRhY2hEcm9wem9uZSh0YXJnZXQpIHtcbiAgICBjb25zb2xlLmxvZygnYXR0Y2gnLCB0YXJnZXQpO1xuICAgIHRoaXMudGFyZ2V0ZGlyID0gKHRhcmdldC5wYXJlbnRFbGVtZW50LmRhdGFzZXQubmFtZSkgPyB0YXJnZXQucGFyZW50RWxlbWVudC5kYXRhc2V0Lm5hbWUgOiAnJztcbiAgICBjb25zb2xlLmxvZygndGFyZ2V0ZGlyJywgdGhpcy50YXJnZXRkaXIpXG4gICAgdGhpcy5kcm9wem9uZS5jbGFzc0xpc3QuYWRkKHRoaXMub3B0aW9ucy5jc3MuZW5hYmxlZCk7XG4gICAgY29uc29sZS5sb2coJ2F0dCcsIHRoaXMuZHJvcHpvbmUpO1xuICAgIHRhcmdldC5hcHBlbmQodGhpcy5kcm9wem9uZSk7XG4gIH1cbiAgZGV0YWNoRHJvcHpvbmUoKSB7XG4gICAgdGhpcy50YXJnZXRkaXIgPSBudWxsO1xuICAgIHRoaXMuY29udGFpbmVyLmNsYXNzTGlzdC5yZW1vdmUodGhpcy5vcHRpb25zLmNzcy5lbmFibGVkKTtcblxuICB9XG4gIG9wZW5EaXJEaWFsb2coYWNjZXB0LCBjYWxsYmFjaykge1xuICAgIGNvbnN0IGlucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImlucHV0XCIpO1xuICAgIGlucHV0LnR5cGUgPSBcImZpbGVcIjtcbiAgICBpbnB1dC5kaXJlY3RvcnkgPSB0cnVlO1xuICAgIGlucHV0Lm11bHRpcGxlID0gdHJ1ZTtcbiAgICBpbnB1dC53ZWJraXRkaXJlY3RvcnkgPSB0cnVlO1xuICAgIGlucHV0LmFsbG93ZGlycyA9IHRydWU7XG4gICAgaW5wdXQuYWNjZXB0ID0gYWNjZXB0O1xuICAgIGlucHV0LmFkZEV2ZW50TGlzdGVuZXIoXCJjaGFuZ2VcIiwgY2FsbGJhY2spO1xuICAgIGlucHV0LmRpc3BhdGNoRXZlbnQobmV3IE1vdXNlRXZlbnQoXCJjbGlja1wiKSk7XG4gIH1cbiAgaGFuZGxlRHJhZ092ZXIoZSkge1xuICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICBlLmRhdGFUcmFuc2Zlci5kcm9wRWZmZWN0ID0gXCJtb3ZlXCI7XG4gIH1cblxuICBoYW5kbGVEcm9wKGUpIHtcbiAgICBsZXQgZGF0YVRyYW5zZmVyO1xuICAgIGlmIChlLmRhdGFUcmFuc2Zlcikge1xuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgZGF0YVRyYW5zZmVyID0gZS5kYXRhVHJhbnNmZXI7XG4gICAgfSBlbHNlIGRhdGFUcmFuc2ZlciA9IGU7XG4gICAgY29uc3QgaXRlbXMgPSBbLi4uKChkYXRhVHJhbnNmZXIuaXRlbXMpID8gZGF0YVRyYW5zZmVyLml0ZW1zIDogZGF0YVRyYW5zZmVyLmZpbGVzKV07XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGl0ZW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICBsZXQgaXRlbSA9IGl0ZW1zW2ldLndlYmtpdEdldEFzRW50cnkoKTtcbiAgICAgIGlmIChpdGVtLmlzRGlyZWN0b3J5ID09PSB0cnVlKSB7XG4gICAgICAgIHRoaXMuZW5hYmxlRHJvcHpvbmUoZmFsc2UpO1xuICAgICAgICBjb25zdCBvbl9jb21wbGV0ZSA9IChlbnRyaWVzLCB6aXAsIHppcFJlYWRhYmxlU3RyZWFtLCBvbl9lcnJvcikgPT4ge1xuICAgICAgICAgIHRoaXMudGltZXIgPSBuZXcgRGF0ZSgpO1xuXG4gICAgICAgICAgY29uc29sZS5sb2coJ2l0ZW0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tJywgemlwKTtcbiAgICAgICAgICB0aGlzLmVuYWJsZURyb3B6b25lKCk7XG5cbiAgICAgICAgICB0aGlzLnppcHRyaWdnZXIuY2xhc3NMaXN0LnJlbW92ZShjc3MuaGlkZSk7XG4gICAgICAgICAgdGhpcy56aXB0cmlnZ2VyLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKGUpID0+IHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCd1cGxvYWQgY2xpY2snKVxuICAgICAgICAgICAgemlwLmVuZCgpO1xuICAgICAgICAgICAgdGhpcy5lbmFibGVEcm9wem9uZShmYWxzZSwgdHJ1ZSk7XG4gICAgICAgICAgICBjb25zdCB6aXBSZXNwb25zZSA9IG5ldyBSZXNwb25zZSh6aXBSZWFkYWJsZVN0cmVhbSk7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnemlwUmVzcCcsIHppcFJlc3BvbnNlKVxuICAgICAgICAgICAgdGhpcy5zZW5kWmlwKHppcFJlc3BvbnNlKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBvbl9lcnJvciA9IChlcnIpID0+IHtcbiAgICAgICAgICBjb25zb2xlLmxvZygnZXJyX3JlYWRfZGlyJywgZXJyKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnppcG5hbWUgPSBpdGVtLm5hbWUgKyAnLnppcCc7XG4gICAgICAgIHRoaXMucGF0aG5hbWUgPSBpdGVtLmZ1bGxQYXRoLnNsaWNlKDEpLnNwbGl0KCcuJyk7XG4gICAgICAgIC8vdGhpcy5wYXRobmFtZS5wb3AoKTtcbiAgICAgICAgdGhpcy5yZWFkRGlyZWN0b3J5KGl0ZW0sIG9uX2NvbXBsZXRlLCBvbl9lcnJvcik7XG5cbiAgICAgIH0gZWxzZSBpZiAoaXRlbS5pc0ZpbGUgPT09IHRydWUpIHtcbiAgICAgICAgLy8gcHV0IGRpcmVjdGx5IGluIGlucHV0IGZpbGVcblxuICAgICAgfVxuXG4gICAgfVxuXG4gIH1cbiAgc3RvcE9uRXJyb3IoZXJyKSB7XG4gICAgY29uc29sZS5sb2coJ2VycicsIGVycik7XG4gIH1cblxuICBpbmNyZW1lbnRDb3VudGVyKHNpemUpIHtcbiAgICB0aGlzLmNvdW50ZXIrKztcbiAgICB0aGlzLmNvdW50ZXJkaXNwbGF5LnRleHRDb250ZW50ID0gdGhpcy5jb3VudGVyO1xuICB9XG4gIGRlY3JlbWVudENvdW50ZXIoc2l6ZSkge1xuICAgIHRoaXMuY291bnRlci0tO1xuICAgIHRoaXMuY291bnRlcmRpc3BsYXkudGV4dENvbnRlbnQgPSB0aGlzLmNvdW50ZXI7XG4gIH1cblxuICBlbmFibGVEcm9wem9uZShlbmFibGUgPSB0cnVlLCBkZXN0cm95ID0gZmFsc2UpIHtcbiAgICBpZiAoZGVzdHJveSkgdGhpcy5kcm9wem9uZS5jbGFzc0xpc3QuYWRkKGNzcy5oaWRlKTtcbiAgICBpZiAoZW5hYmxlKSB0aGlzLmRyb3B6b25lLmNsYXNzTGlzdC5hZGQodGhpcy5vcHRpb25zLmNzcy5lbmFibGVkKTtcbiAgICBlbHNlIHRoaXMuZHJvcHpvbmUuY2xhc3NMaXN0LnJlbW92ZSh0aGlzLm9wdGlvbnMuY3NzLmVuYWJsZWQpO1xuXG4gIH1cbiAgZmlsZVR5cGUoZGF0YSkge1xuICAgIGNvbnN0IG1pbWVfdHlwZSA9IChzaWduYXR1cmUpID0+IHtcbiAgICAgIHN3aXRjaCAoc2lnbmF0dXJlKSB7XG4gICAgICAgIGNhc2UgJzg5NTA0RTQ3JzpcbiAgICAgICAgICByZXR1cm4gJ2ltYWdlL3BuZyc7XG4gICAgICAgIGNhc2UgJzQ3NDk0NjM4JzpcbiAgICAgICAgICByZXR1cm4gJ2ltYWdlL2dpZic7XG4gICAgICAgIGNhc2UgJzI1NTA0NDQ2JzpcbiAgICAgICAgICByZXR1cm4gJ2FwcGxpY2F0aW9uL3BkZic7XG4gICAgICAgIGNhc2UgJ0ZGRDhGRkRCJzpcbiAgICAgICAgY2FzZSAnRkZEOEZGRTAnOlxuICAgICAgICBjYXNlICdGRkQ4RkZFMSc6XG4gICAgICAgICAgcmV0dXJuICdpbWFnZS9qcGVnJztcbiAgICAgICAgY2FzZSAnNTA0QjAzMDQnOlxuICAgICAgICAgIHJldHVybiAnYXBwbGljYXRpb24vemlwJztcbiAgICAgICAgY2FzZSAnRUZCQkJGMjInOlxuICAgICAgICAgIHJldHVybiAndGV4dC90c3YnOyAvLyd0ZXh0L3RhYi1zZXBhcmF0ZWQtdmFsdWVzJztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBjb25zb2xlLmxvZygndW5rbm93bnNpZ24nLCBzaWduYXR1cmUpXG4gICAgICAgICAgcmV0dXJuICd1bmtub3duJztcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgdWludCA9IG5ldyBVaW50OEFycmF5KGRhdGEpO1xuICAgIGxldCBieXRlcyA9IFtdXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCA0OyBpKyspIHtcbiAgICAgIGJ5dGVzLnB1c2godWludFtpXS50b1N0cmluZygxNikpXG4gICAgfVxuICAgIGRhdGEgPSBieXRlcy5qb2luKCcnKS50b1VwcGVyQ2FzZSgpO1xuICAgIHJldHVybiB7XG4gICAgICBpbnB1dDogdWludCxcbiAgICAgIG1pbWV0eXBlOiBtaW1lX3R5cGUoZGF0YSlcbiAgICB9O1xuICB9XG4gIGZmbFRvU3RyZWFtKGZmbGF0ZVN0cmVhbSkge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzXG4gICAgcmV0dXJuIG5ldyBSZWFkYWJsZVN0cmVhbSh7XG4gICAgICBzdGFydChjb250cm9sbGVyKSB7XG4gICAgICAgIGZmbGF0ZVN0cmVhbS5vbmRhdGEgPSAoZXJyb3IsIGRhdGEsIGZpbmFsKSA9PiB7XG4gICAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICBjb250cm9sbGVyLmVycm9yKGVycm9yKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2VsZi56aXBzaXplICs9IGRhdGEubGVuZ3RoO1xuICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKGRhdGEpO1xuICAgICAgICAgICAgaWYgKGZpbmFsKSB7XG4gICAgICAgICAgICAgIGNvbnRyb2xsZXIuY2xvc2UoKTtcblxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGNhbmNlbCgpIHtcbiAgICAgICAgZmZsYXRlU3RyZWFtLnRlcm1pbmF0ZSgpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIC8vXG5cbiAgYXN5bmMgcmVhZERpcmVjdG9yeShkaXIsIG9uY29tcGxldGUsIG9uZXJyb3IsIHppcCwgemlwUmVhZGFibGVTdHJlYW0pIHtcbiAgICBsZXQgZXJyb3JlZCA9IGZhbHNlO1xuICAgIGxldCBmaW5hbCA9IGZhbHNlO1xuICAgIGxldCB0b3RhbCA9IDA7XG4gICAgbGV0IGRpcmVudHJpZXMgPSBbXSxcbiAgICAgIGhhbmRsZXJzID0gW107XG5cbiAgICBjb25zdCBvbl9lcnJvciA9IChlcnIpID0+IHtcbiAgICAgIGNvbnNvbGUubG9nKCdvbl9lcnJvcicsIGVycilcbiAgICAgIGlmICghZXJyb3JlZCkge1xuICAgICAgICBlcnJvcmVkID0gdHJ1ZTtcbiAgICAgICAgb25lcnJvcihlcnIpO1xuICAgICAgfVxuICAgIH07XG4gICAgemlwID0gemlwID8gemlwIDogbmV3IFppcCgpO1xuICAgIHppcFJlYWRhYmxlU3RyZWFtID0gemlwUmVhZGFibGVTdHJlYW0gPyB6aXBSZWFkYWJsZVN0cmVhbSA6IHRoaXMuZmZsVG9TdHJlYW0oemlwKTtcblxuICAgIGZldGNoKHRoaXMub3B0aW9ucy51cmwsIGZldGNoU2V0dGluZ3Moe1xuICAgICAgbW9kZTogJ2NvcnMnLFxuICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICBib2R5OiB6aXAsXG4gICAgICBoZWFkZXJzOiB7XG4gICAgICAgICdDb250ZW50LVR5cGUnOiAnQXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtJyxcbiAgICAgIH0sXG4gICAgICBkdXBsZXg6ICdoYWxmJ1xuICAgIH0pKS50aGVuKHJlc3BvbnNlID0+IHtcbiAgICAgIGNvbnNvbGUubG9nKCdyZXNwb25zZScsIHJlc3BvbnNlKTtcbiAgICB9KTtcbiAgICBjb25zdCBwcm9jZXNzX2ZpbGUgPSBhc3luYyAoZiwgZmlsZW5hbWUsIGNhbGxiYWNrKSA9PiB7XG4gICAgICB0aGlzLmluY3JlbWVudENvdW50ZXIoZi5zaXplKTtcbiAgICAgIHRoaXMuYWRkRmlsZVRvWmlwKGYsIGZpbGVuYW1lLCB6aXAsIGNhbGxiYWNrKTtcblxuICAgIH07XG4gICAgY29uc3QgcHJvY2Vzc19zZXJpYWxpemUgPSBhc3luYyAoKSA9PiB7XG4gICAgICAvLyBzZXJpZXNcbiAgICAgIGlmIChoYW5kbGVycy5sZW5ndGgpIHtcbiAgICAgICAgY29uc3QgaGFuZGxlciA9IGhhbmRsZXJzLnNoaWZ0KCk7XG4gICAgICAgIGF3YWl0IGhhbmRsZXIoKTtcbiAgICAgICAgcHJvY2Vzc19zZXJpYWxpemUoKTtcbiAgICAgIH1cblxuXG4gICAgfVxuXG4gICAgY29uc3Qgb25fZG9uZSA9IGFzeW5jIChlbnRyaWVzLCB6aXAsIHppcFJlYWRhYmxlU3RyZWFtLCBvbl9lcnJvcikgPT4ge1xuICAgICAgaWYgKGVudHJpZXMubGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IGVudHJ5ID0gZW50cmllcy5zaGlmdCgpO1xuICAgICAgICBpZiAoZW50cnkuaXNGaWxlKSB7XG4gICAgICAgICAgY29uc3QgY2FsbGJhY2sgPSAoKSA9PiB7XG5cbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdlbnRyaWVzbGVuZ3RobGVmdCAnLCBlbnRyaWVzLmxlbmd0aClcblxuICAgICAgICAgICAgaWYgKCFlbnRyaWVzLmxlbmd0aCAmJiBoYW5kbGVycy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgY29uc29sZS5sb2coJ3NlcmlhbGl6ZScpXG4gICAgICAgICAgICAgIHByb2Nlc3Nfc2VyaWFsaXplKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZmluYWwgJiYgIWVudHJpZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdvbmNvbXBsZXRlJyk7XG4gICAgICAgICAgICAgIG9uY29tcGxldGUoW10sIHppcCwgemlwUmVhZGFibGVTdHJlYW0sIG9uX2Vycm9yKTtcbiAgICAgICAgICAgIH0gZWxzZSBvbl9kb25lKGVudHJpZXMsIHppcCwgemlwUmVhZGFibGVTdHJlYW0sIG9uX2Vycm9yKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZW50cnkuZmlsZShmID0+IHByb2Nlc3NfZmlsZShmLCBlbnRyeS5mdWxsUGF0aC5zbGljZSgxKSwgY2FsbGJhY2spKTsgLy9cblxuICAgICAgICB9IGVsc2UgaWYgKGVudHJ5LmlzRGlyZWN0b3J5KSBoYW5kbGVycy5wdXNoKGFzeW5jICgpID0+IHtcbiAgICAgICAgICB0aGlzLnJlYWREaXJlY3RvcnkoZW50cnksIG9uX2RvbmUsIG9uX2Vycm9yLCB6aXAsIHppcFJlYWRhYmxlU3RyZWFtKTtcblxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCByZWFkZXIgPSBkaXIuY3JlYXRlUmVhZGVyKCk7XG4gICAgY29uc3Qgb25fcmVhZCA9IGFzeW5jIChlbnRyaWVzKSA9PiB7XG4gICAgICBpZiAoIWVudHJpZXMubGVuZ3RoICYmICFlcnJvcmVkKSB7XG4gICAgICAgIGlmICghZGlyZW50cmllcy5sZW5ndGgpIG9uY29tcGxldGUoW10sIHppcCwgemlwUmVhZGFibGVTdHJlYW0sIG9uX2Vycm9yKTtcbiAgICAgICAgZWxzZSBmaW5hbCA9IHRydWU7XG4gICAgICB9IGVsc2UgYXdhaXQgcmVhZGVyLnJlYWRFbnRyaWVzKG9uX3JlYWQsIG9uX2Vycm9yKTtcbiAgICAgIGRpcmVudHJpZXMgPSBbLi4uZGlyZW50cmllcywgLi4uZW50cmllc107XG4gICAgICBpZiAoZmluYWwpIG9uX2RvbmUoZGlyZW50cmllcywgemlwLCB6aXBSZWFkYWJsZVN0cmVhbSwgb25fZXJyb3IpO1xuICAgIH1cbiAgICByZWFkZXIucmVhZEVudHJpZXMob25fcmVhZCwgb25fZXJyb3IpO1xuXG4gIH1cblxuICBjb21wcmVzc2lvbkxldmVsKG5hbWUpIHtcbiAgICBpZiAoIW5hbWUpIHtcbiAgICAgIGNvbnNvbGUubG9nKCduYW1lJywgbmFtZSk7XG4gICAgICByZXR1cm4gLTE7XG4gICAgfVxuICAgIGxldCBleHQgPSBuYW1lLnNwbGl0KCcuJyk7XG4gICAgZXh0ID0gKGV4dC5sZW5ndGggPiAxKSA/IGV4dFtleHQubGVuZ3RoIC0gMV0gOiBleHRbMF07XG4gICAgcmV0dXJuIChhbHJlYWR5X2NvbXByZXNzZWQuZmluZChleCA9PiAoZXggPT09IGV4dCkpKSA/IDIgOiB0aGlzLm9wdGlvbnMubGV2ZWw7XG4gIH1cblxuICBzZW5kWmlwKHJlc3BvbnNlKSB7XG4gICAgLy8gIGNvbnN0IGZpbGVzdHJlYW0gPSBuZXcgV3JpdGFibGVTdHJlYW0oKTtcbiAgICAvLyAgY29uc3Qgd3JpdGVyID0gZmlsZXN0cmVhbS5nZXRXcml0ZXIoKTtcbiAgICAvL1xuICAgIGxldCBjaHVua2NvdW50ZXI7XG5cbiAgICBjb25zdCBudW1jaHVua3MgPSBNYXRoLnJvdW5kKHRoaXMuemlwc2l6ZSAvIGNodW5rc2l6ZSk7XG4gICAgY29uc3QgdXBkYXRlX3Byb2dyZXNzID0gKGUpID0+IHtcbiAgICAgIGNvbnN0IHByb2dyZXNzID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQodGhpcy5vcHRpb25zLnNlbGVjdG9yLnByb2dyZXNzKTtcbiAgICAgIGlmIChlLmxlbmd0aENvbXB1dGFibGUpIHtcbiAgICAgICAgY29uc3QgcGVyY2VudCA9IE1hdGgucm91bmQoZS5sb2FkZWQgLyB0aGlzLnppcHNpemUgKiAxMDApO1xuICAgICAgICBjb25zdCB0b3RhbCA9IE1hdGgucm91bmQoKGNodW5rY291bnRlciAtIDEpIC8gbnVtY2h1bmtzICogMTAwICsgcGVyY2VudCAvIG51bWNodW5rcyk7XG4gICAgICAgIHByb2dyZXNzLmlubmVySFRNTCA9IFwiQ2h1bmsgIyBcIiArIGNodW5rY291bnRlciArIFwiIGlzIFwiICsgcGVyY2VudCArIFwiJSB1cGxvYWRlZC4gVG90YWwgdXBsb2FkZWQ6IFwiICsgdG90YWwgKyBcIiVcIjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUubG9nKFwibm90IGNvbXB1dGFibGVcIik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgcmVhZHN0cmVhbSA9IGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHJlYWRlciA9IHJlc3BvbnNlLmJvZHkuZ2V0UmVhZGVyKCk7XG5cbiAgICAgIGxldCBkYXRhID0gW107XG4gICAgICBsZXQgc3RhcnQgPSAwO1xuICAgICAgbGV0IGRhdGFsZW5ndGggPSAwO1xuICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIGRvbmUsXG4gICAgICAgICAgdmFsdWVcbiAgICAgICAgfSA9IGF3YWl0IHJlYWRlci5yZWFkKCk7XG4gICAgICAgIGlmIChkb25lKSB7XG4gICAgICAgICAgLy93cml0ZXIud3JpdGUobmV3IFVpbnQ4QXJyYXkoMCksIHRydWUpO1xuXG4gICAgICAgICAgLy93cml0ZXIuY2xvc2UoKTtcbiAgICAgICAgICBmZXRjaF9yYW5nZShkYXRhLCBzdGFydCwgZGF0YWxlbmd0aCwgdHJ1ZSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vd3JpdGVyLndyaXRlKHZhbHVlKTtcbiAgICAgICAgZGF0YS5wdXNoKHZhbHVlKTtcbiAgICAgICAgZGF0YWxlbmd0aCArPSB2YWx1ZS5sZW5ndGg7XG4gICAgICAgIGlmIChkYXRhbGVuZ3RoID49IGNodW5rc2l6ZSkge1xuICAgICAgICAgIGZldGNoX3JhbmdlKGRhdGEsIHN0YXJ0LCBkYXRhbGVuZ3RoLCBmYWxzZSk7XG4gICAgICAgICAgc3RhcnQgKz0gZGF0YWxlbmd0aDtcbiAgICAgICAgICBkYXRhID0gW107XG4gICAgICAgICAgZGF0YWxlbmd0aCA9IDA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJlYWRlci5yZWxlYXNlTG9jaygpO1xuICAgIH1cbiAgICAvLyAgcmVhZHN0cmVhbSgpO1xuXG4gICAgY29uc3QgdG9faGV4ID0gKHN0cikgPT4ge1xuICAgICAgY29uc3QgZW5jb2RlciA9IG5ldyBUZXh0RW5jb2RlcigpO1xuICAgICAgcmV0dXJuIEFycmF5XG4gICAgICAgIC5mcm9tKGVuY29kZXIuZW5jb2RlKHN0cikpXG4gICAgICAgIC5tYXAoYiA9PiBiLnRvU3RyaW5nKDE2KS5wYWRTdGFydCgyLCAnMCcpKVxuICAgICAgICAuam9pbignJylcblxuICAgIH1cbiAgICBjb25zdCBmZXRjaF9yYW5nZSA9IChkYXRhLCBzdGFydCwgZGF0YWxlbmd0aCwgZmluYWwgPSBmYWxzZSkgPT4ge1xuICAgICAgY29uc29sZS5sb2coJ2ZldGNoX3JhbmdlICcgKyBmaW5hbCArICcgc3RhcnQ9JyArIHN0YXJ0ICsgJ2VuZD0nICsgZGF0YWxlbmd0aCwgZGF0YSlcbiAgICAgIGNvbnN0IGZvcm1kYXRhID0gbmV3IEZvcm1EYXRhKCk7XG4gICAgICBmb3JtZGF0YS5hcHBlbmQoJ3BhdGgnLCB0aGlzLnBhdGhuYW1lKTtcbiAgICAgIGZvcm1kYXRhLmFwcGVuZCgndGFnJywgZGVmZGlyKTtcbiAgICAgIGlmIChmaW5hbCkgZm9ybWRhdGEuYXBwZW5kKCdmaW5hbCcsIGZpbmFsKTtcbiAgICAgIGZvcm1kYXRhLmFwcGVuZCh0aGlzLm9wdGlvbnMuZmlsZWZpZWxkLCBuZXcgQmxvYihkYXRhKSwgdGhpcy56aXBuYW1lKTtcbiAgICAgIC8qbmV3IEZpbGUoZGF0YSwgdGhpcy56aXBuYW1lLCB7XG4gICAgICAgICAgIGNvbnRlbnRfdHlwZTogXCJhcHBsaWNhdGlvbi96aXBcIixcbiAgICAgICAgICAgICBsYXN0TW9kaWZpZWQ6IG5ldyBEYXRlKClcbiAgICAgICAgIH0pOyovXG4gICAgICBjb25zdCBlbmQgPSBzdGFydCArIGRhdGFsZW5ndGg7XG4gICAgICBkYXRhID0gdG9faGV4KGRhdGFsZW5ndGgpICsgYFxcclxcbmAgKyBkYXRhICsgYFxcclxcbmA7XG4gICAgICBjb25zdCByZXF1ZXN0ID0gbmV3IFJlcXVlc3QodGhpcy5vcHRpb25zLnVybCwgZmV0Y2hTZXR0aW5ncyh7XG4gICAgICAgIC8vICAgIG1vZGU6ICdjb3JzJyxcbiAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgIGJvZHk6IGZvcm1kYXRhLFxuICAgICAgICAvLyAgcmFuZ2U6ICdieXRlcz0nICsgc3RhcnQgKyAnLScgKyBwYXJzZUludChzdGFydCArIGVuZCksXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ0FwcGxpY2F0aW9uL29jdGV0LXN0cmVhbScsXG4gICAgICAgICAgJ1RyYW5zZmVyLUVuY29kaW5nJzogJ2NodW5rZWQnLFxuICAgICAgICAgICdDb250ZW50LVJhbmdlJzogJ2J5dGVzICcgKyBzdGFydCArICctJyArIGVuZCArICcvJyArIHRoaXMuemlwc2l6ZVxuICAgICAgICB9LFxuICAgICAgICAvLyAgZHVwbGV4OiAnaGFsZidcbiAgICAgIH0pKTtcbiAgICAgIGZldGNoKHJlcXVlc3QpLnRoZW4ocmVzID0+IHJlcy5qc29uKCkpLnRoZW4oanNvbiA9PiB7XG4gICAgICAgIGlmIChmaW5hbCkge1xuICAgICAgICAgIGNvbnN0IGZpbGV0b2xvYWQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCh0aGlzLm9wdGlvbnMuc2VsZWN0b3IuZmlsZXRvbG9hZCk7XG4gICAgICAgICAgaWYgKGZpbGV0b2xvYWQpIGZpbGV0b2xvYWQudmFsdWUgPSBET01QdXJpZnkuc2FuaXRpemUoanNvbik7XG4gICAgICAgICAgY29uc29sZS5sb2coJ2pzb24nLCBqc29uKVxuICAgICAgICAgIGNvbnNvbGUubG9nKCd0aW1lcicsIChuZXcgRGF0ZSgpIC0gdGhpcy50aW1lcikgLyAxMDAwKTtcbiAgICAgICAgICBjb25zb2xlLmxvZygnc2VudCcpO1xuICAgICAgICAgIGlmICh0aGlzLmNhbGxiYWNrKSB0aGlzLmNhbGxiYWNrKGpzb24sIGRlZmRpcik7XG4gICAgICAgIH0gZWxzZSByZXR1cm4gW107XG4gICAgICB9KS5jYXRjaChlcnIgPT4ge1xuICAgICAgICBjb25zb2xlLmxvZygncmVzZXJyb3InLCBlcnIpXG4gICAgICB9KTtcbiAgICB9XG5cbiAgfVxuICBhc3luYyBhZGRGaWxlVG9aaXAoZmlsZSwgZmlsZXBhdGgsIHppcCwgY2FsbGJhY2spIHtcbiAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICBjb25zdCBleHQgPSBmaWxlcGF0aC5zbGljZShmaWxlcGF0aC5sYXN0SW5kZXhPZignLicpICsgMSk7XG4gICAgY29uc3QgemlwcGVkc3RyZWFtID0gYWxyZWFkeV9jb21wcmVzc2VkLmhhcyhleHQpID9cbiAgICAgIG5ldyBaaXBQYXNzVGhyb3VnaChmaWxlcGF0aCkgOlxuICAgICAgZmlsZS5zaXplID4gbGFyZ2VmaWxlID9cbiAgICAgIG5ldyBBc3luY1ppcERlZmxhdGUoZmlsZXBhdGgsIHtcbiAgICAgICAgbGV2ZWw6IDlcbiAgICAgIH0pIDogbmV3IFppcERlZmxhdGUoZmlsZXBhdGgsIHtcbiAgICAgICAgbGV2ZWw6IDlcbiAgICAgIH0pO1xuICAgIHppcHBlZHN0cmVhbS5vbmRhdGEgPSAoZXJyLCBjaHVuaywgZmluYWwpID0+IHtcbiAgICAgIGlmIChlcnIpIGNvbnNvbGUubG9nKCdlcnIgYWRkIGNodW5rIHRvIHppcGZpbGUnICsgY2h1bmssIGVycik7XG4gICAgICBpZiAoZmluYWwpIHtcblxuICAgICAgfVxuICAgIH1cbiAgICB6aXAuYWRkKHppcHBlZHN0cmVhbSk7XG5cbiAgICBjb25zdCByZWFkZmlsZSA9IGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHJlYWRlciA9IGZpbGUuc3RyZWFtKCkuZ2V0UmVhZGVyKCk7XG4gICAgICB0cnkge1xuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgIGRvbmUsXG4gICAgICAgICAgICB2YWx1ZVxuICAgICAgICAgIH0gPSBhd2FpdCByZWFkZXIucmVhZCgpO1xuICAgICAgICAgIGlmIChkb25lKSB7XG5cbiAgICAgICAgICAgIHppcHBlZHN0cmVhbS5wdXNoKG5ldyBVaW50OEFycmF5KDApLCB0cnVlKTtcbiAgICAgICAgICAgIHNlbGYuZGVjcmVtZW50Q291bnRlcihmaWxlLnNpemUpO1xuICAgICAgICAgICAgaWYgKGNhbGxiYWNrKSBjYWxsYmFjaygpO1xuICAgICAgICAgICAgcmV0dXJuIGRvbmU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHppcHBlZHN0cmVhbS5wdXNoKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgcmVhZGVyLnJlbGVhc2VMb2NrKCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBhd2FpdCByZWFkZmlsZSgpO1xuICB9XG5cbn0iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/modules/js-upload.js\n")}}]);