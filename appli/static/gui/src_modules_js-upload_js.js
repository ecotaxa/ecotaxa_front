/*! For license information please see src_modules_js-upload_js.js.LICENSE.txt */
"use strict";(self.webpackChunk=self.webpackChunk||[]).push([["src_modules_js-upload_js"],{"./src/modules/form-submit.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   FormSubmit: () => (/* binding */ FormSubmit)\n/* harmony export */ });\n/* harmony import */ var dompurify__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! dompurify */ \"./node_modules/dompurify/dist/purify.js\");\n/* harmony import */ var dompurify__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(dompurify__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _modules_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../modules/utils.js */ \"./src/modules/utils.js\");\n\n\nlet instance = null;\nconst formcss = {\n  invalid: 'invalid',\n  inputvalidate: 'input-validate',\n}\nconst domselectors = {\n  captcha: '.js-captcha'\n}\n;\n\nclass FormSubmit {\n  handlers = [];\n  form = null;\n  listener = null;\n  constructor(form, options = {}) {\n    if (!instance) {\n      if (!form) return;\n      this.form = form instanceof HTMLElement ? form : document.querySelector(form);\n      const defaultOptions = {\n        fetch: null,\n      };\n      options = Object.assign(options, this.form.dataset);\n      this.options = Object.assign(defaultOptions, options);\n      if (!this.form) return;\n      this.validateFields(true);\n      this.init();\n      instance = this;\n    }\n    return instance;\n  }\n  init() {\n    // init the form ( options like beforeunload etc...)\n\n    this.form.addEventListener('submit', async (e) => {\n      e.preventDefault();\n      const res = await this.submitForm();\n      return res;\n    });\n    this.specialFields();\n  }\n  specialFields() {\n    // check if there is a password confirm input\n    // add show text for password fields\n\n    this.form.querySelectorAll('input[data-match]').forEach(input => {\n      //\n      const match = input.dataset.match;\n      if (!match) return;\n      const target = document.getElementById(match);\n      if (!target) return;\n      const invalid = (input.dataset.matchinvalid) ? input.dataset.matchinvalid : \"no match\";\n      const check_match = (item, itemtarget) => {\n        const label = (input.previousElementSibling && input.previousElementSibling.tagName.toLowerCase() == 'label') ? input.previousElementSibling : null;\n        const labeltarget = (target.previousElementSibling && target.previousElementSibling.tagName.toLowerCase() == 'label') ? target.previousElementSibling : null;\n        const {\n          patternMismatch = false\n        } = item.validity;\n        const customvalidity = (patternMismatch) ?\n          this.get_message(item, 'invalid') : '';\n        if (item.checkValidity() === true) {\n          item.dataset.invalid = '';\n          item.setCustomValidity(\"\");\n          if (item == input && label !== null) label.classList.remove(formcss.invalid);\n          else if (labeltarget !== null) labeltarget.classList.remove(formcss.invalid);\n          item.classList.remove(formcss.inputvalidate);\n          if (item.value !== itemtarget.value) {\n            input.setCustomValidity(invalid);\n            input.dataset.invalid = invalid;\n            if (label) label.classList.add(formcss.invalid);\n            input.classList.add(formcss.inputvalidate);\n          } else {\n            input.setCustomValidity(\"\");\n            input.dataset.invalid = \"\";\n            if (label) label.classList.remove(formcss.invalid);\n            input.classList.remove(formcss.inputvalidate);\n          }\n        } else {\n          item.setCustomValidity(customvalidity);\n          item.dataset.invalid = customvalidity;\n          if (label) label.classList.add(formcss.invalid);\n          item.classList.add(formcss.inputvalidate);\n        }\n        item.focus();\n      };\n      [input, target].forEach(item => {\n        item.addEventListener('keyup', (e) => {\n          const itemtarget = (item === input) ? target : input;\n          check_match(item, itemtarget);\n        });\n      });\n\n    });\n  }\n  get_message(field, type = 'invalid') {\n    if (field.checkValidity() == false) {\n      const {\n        valueMissing = true\n      } = field.validity;\n      if (valueMissing) return (field.dataset.required) ? field.dataset.required : ((this.form.dataset.required) ? this.form.dataset.required : 'required');\n      else return (field.dataset[type]) ? field.dataset[type] : 'input invalid';\n    } else return '';\n  }\n\n  validateField(field, init = false) {\n\n\n\n    if (['textarea', 'input'].indexOf(field.tagName.toLowerCase()) >= 0) {\n\n    }\n    if (['select', 'input[type=\"checkbox\"]'].indexOf(field.tagName.toLowerCase()) >= 0) {\n      field.querySelectorAll('option:checked').forEach(option => {\n        option.value = dompurify__WEBPACK_IMPORTED_MODULE_0___default().sanitize(option.value);\n      });\n\n    } else field.value = dompurify__WEBPACK_IMPORTED_MODULE_0___default().sanitize(field.value);\n\n    const rep = field.checkValidity();\n\n    if (field.classList.contains('select-one')) {\n      console.log('select rep', rep);\n    }\n    const label = field.closest('.form-box') ? field.closest('.form-box').querySelector('label') : null;\n\n    if (rep && label) {\n      label.classList.remove(formcss.invalid);\n    } else if (!rep) {\n      if (label) {\n        label.dataset.invalid = this.get_message(field);\n        label.classList.add(formcss.invalid);\n        window.scrollTo({\n          top: parseInt(label.offsetTop),\n          left: parseInt(label.offsetLeft),\n          behavior: 'smooth'\n        });\n      }\n    }\n    return rep;\n  }\n\n  validateFields(init = false) {\n    //todo: complete validation foreach field type\n    let resp = true;\n    // .required input for tom-select component\n\n    [...this.form.elements].forEach(field => {\n      if (field.name) {\n\n        if (init === true) {\n\n          if (!field.dataset.listen) {\n            if (field.hasAttribute('required') && field.required) {\n              const label = field.closest('.form-box') ? field.closest('.form-box').querySelector('label') : field.parentElement.querySelector('label');\n              if (label) label.classList.add('required');\n            }\n\n            ['change', 'blur'].forEach(evt => {\n              field.addEventListener(evt, (e) => {\n                this.validateField(e.currentTarget, init);\n              });\n            });\n            field.dataset.listen = true;\n          }\n        } else resp = (resp && this.validateField(field, init));\n      }\n    });\n    return resp;\n  }\n\n  addHandler(handler) {\n    this.handlers.push(handler);\n  }\n  fieldEnable(enable = true) {\n    this.form.querySelectorAll('input[data-sub=\"enable\"]').forEach(input => {\n      if (enable === true) {\n        input.removeAttribute(\"disabled\");\n      } else input.disabled = true;\n    });\n  }\n\n  async submitHandler() {\n    if (!this.validateFields()) return false;\n\n    if (this.handlers.length === 0) return true;\n    let resp = true;\n    // series\n    /*  for (const handler of this.handlers) {\n          const rep = await handler()\n          resp = (resp && rep)\n      }*/\n    // concurrent\n    await Promise.all(this.handlers.map(async handler => {\n      const rep = await handler();\n      resp = (resp && rep);\n    }));\n    if (resp === true) this.handlers = [];\n    return resp;\n  }\n  // no redirection when using data-fetch\n  formFetch(format = null) {\n    const formdata = new FormData(this.form);\n    formdata[\"fetch\"] = true;\n    fetch(this.form.action, (0,_modules_utils_js__WEBPACK_IMPORTED_MODULE_1__.fetchSettings)({\n        method: 'POST',\n        body: formdata,\n      }))\n      .then(response => {\n        switch (format) {\n          case \"text\":\n          case \"html\":\n            return response.text();\n            break;\n          default:\n            return response.json();\n        }\n      })\n      .then(response => {\n        this.displayResponse(response);\n      })\n      .catch(err => {\n        this.displayResponse(err, true)\n      }).finally(response => {\n        this.form.disabled = true;\n      });\n    return false;\n  }\n\n  async submitForm() {\n    this.fieldEnable();\n    if (this.validateFields(false)) {\n      const isbot = (this.form.querySelector(domselectors.captcha)) ? (this.form.dataset.isbot ? (this.form.dataset.isbot === true) : true) : false;\n      if (isbot === true) return false;\n      const yessubmit = await this.submitHandler();\n      if (yessubmit) {\n        if (this.options.fetch) this.formFetch(this.options.fetch);\n        else this.form.submit();\n        this.form.disabled = true;\n        return true;\n      } else return false;\n    } else return false;\n  }\n\n  displayResponse(response, error = false) {\n    const el = document.createElement('div');\n    el.insertAdjacentHTML('afterbegin', response);\n    if (error !== false) el.classList.add('is-error');\n    this.form.parentElement.insertBefore(el, this.form);\n    this.form.remove();\n  }\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvbW9kdWxlcy9mb3JtLXN1Ym1pdC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQWtDO0FBQ0E7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBRTZCOztBQUV0QjtBQUNQO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPOztBQUVQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ047O0FBRUE7Ozs7QUFJQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIseURBQWtCO0FBQ3pDLE9BQU87O0FBRVAsTUFBTSxtQkFBbUIseURBQWtCOztBQUUzQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2YsYUFBYTtBQUNiO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUixLQUFLO0FBQ0w7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsZ0VBQWE7QUFDekM7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUixNQUFNO0FBQ047O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy9tb2R1bGVzL2Zvcm0tc3VibWl0LmpzP2M2YjciXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHZhbGlkYXRvciBmcm9tICd2YWxpZGF0b3InO1xuaW1wb3J0IERPTVB1cmlmeSBmcm9tICdkb21wdXJpZnknO1xubGV0IGluc3RhbmNlID0gbnVsbDtcbmNvbnN0IGZvcm1jc3MgPSB7XG4gIGludmFsaWQ6ICdpbnZhbGlkJyxcbiAgaW5wdXR2YWxpZGF0ZTogJ2lucHV0LXZhbGlkYXRlJyxcbn1cbmNvbnN0IGRvbXNlbGVjdG9ycyA9IHtcbiAgY2FwdGNoYTogJy5qcy1jYXB0Y2hhJ1xufVxuaW1wb3J0IHtcbiAgZmV0Y2hTZXR0aW5nc1xufSBmcm9tICcuLi9tb2R1bGVzL3V0aWxzLmpzJztcblxuZXhwb3J0IGNsYXNzIEZvcm1TdWJtaXQge1xuICBoYW5kbGVycyA9IFtdO1xuICBmb3JtID0gbnVsbDtcbiAgbGlzdGVuZXIgPSBudWxsO1xuICBjb25zdHJ1Y3Rvcihmb3JtLCBvcHRpb25zID0ge30pIHtcbiAgICBpZiAoIWluc3RhbmNlKSB7XG4gICAgICBpZiAoIWZvcm0pIHJldHVybjtcbiAgICAgIHRoaXMuZm9ybSA9IGZvcm0gaW5zdGFuY2VvZiBIVE1MRWxlbWVudCA/IGZvcm0gOiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKGZvcm0pO1xuICAgICAgY29uc3QgZGVmYXVsdE9wdGlvbnMgPSB7XG4gICAgICAgIGZldGNoOiBudWxsLFxuICAgICAgfTtcbiAgICAgIG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKG9wdGlvbnMsIHRoaXMuZm9ybS5kYXRhc2V0KTtcbiAgICAgIHRoaXMub3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oZGVmYXVsdE9wdGlvbnMsIG9wdGlvbnMpO1xuICAgICAgaWYgKCF0aGlzLmZvcm0pIHJldHVybjtcbiAgICAgIHRoaXMudmFsaWRhdGVGaWVsZHModHJ1ZSk7XG4gICAgICB0aGlzLmluaXQoKTtcbiAgICAgIGluc3RhbmNlID0gdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIGluc3RhbmNlO1xuICB9XG4gIGluaXQoKSB7XG4gICAgLy8gaW5pdCB0aGUgZm9ybSAoIG9wdGlvbnMgbGlrZSBiZWZvcmV1bmxvYWQgZXRjLi4uKVxuXG4gICAgdGhpcy5mb3JtLmFkZEV2ZW50TGlzdGVuZXIoJ3N1Ym1pdCcsIGFzeW5jIChlKSA9PiB7XG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICBjb25zdCByZXMgPSBhd2FpdCB0aGlzLnN1Ym1pdEZvcm0oKTtcbiAgICAgIHJldHVybiByZXM7XG4gICAgfSk7XG4gICAgdGhpcy5zcGVjaWFsRmllbGRzKCk7XG4gIH1cbiAgc3BlY2lhbEZpZWxkcygpIHtcbiAgICAvLyBjaGVjayBpZiB0aGVyZSBpcyBhIHBhc3N3b3JkIGNvbmZpcm0gaW5wdXRcbiAgICAvLyBhZGQgc2hvdyB0ZXh0IGZvciBwYXNzd29yZCBmaWVsZHNcblxuICAgIHRoaXMuZm9ybS5xdWVyeVNlbGVjdG9yQWxsKCdpbnB1dFtkYXRhLW1hdGNoXScpLmZvckVhY2goaW5wdXQgPT4ge1xuICAgICAgLy9cbiAgICAgIGNvbnN0IG1hdGNoID0gaW5wdXQuZGF0YXNldC5tYXRjaDtcbiAgICAgIGlmICghbWF0Y2gpIHJldHVybjtcbiAgICAgIGNvbnN0IHRhcmdldCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKG1hdGNoKTtcbiAgICAgIGlmICghdGFyZ2V0KSByZXR1cm47XG4gICAgICBjb25zdCBpbnZhbGlkID0gKGlucHV0LmRhdGFzZXQubWF0Y2hpbnZhbGlkKSA/IGlucHV0LmRhdGFzZXQubWF0Y2hpbnZhbGlkIDogXCJubyBtYXRjaFwiO1xuICAgICAgY29uc3QgY2hlY2tfbWF0Y2ggPSAoaXRlbSwgaXRlbXRhcmdldCkgPT4ge1xuICAgICAgICBjb25zdCBsYWJlbCA9IChpbnB1dC5wcmV2aW91c0VsZW1lbnRTaWJsaW5nICYmIGlucHV0LnByZXZpb3VzRWxlbWVudFNpYmxpbmcudGFnTmFtZS50b0xvd2VyQ2FzZSgpID09ICdsYWJlbCcpID8gaW5wdXQucHJldmlvdXNFbGVtZW50U2libGluZyA6IG51bGw7XG4gICAgICAgIGNvbnN0IGxhYmVsdGFyZ2V0ID0gKHRhcmdldC5wcmV2aW91c0VsZW1lbnRTaWJsaW5nICYmIHRhcmdldC5wcmV2aW91c0VsZW1lbnRTaWJsaW5nLnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PSAnbGFiZWwnKSA/IHRhcmdldC5wcmV2aW91c0VsZW1lbnRTaWJsaW5nIDogbnVsbDtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIHBhdHRlcm5NaXNtYXRjaCA9IGZhbHNlXG4gICAgICAgIH0gPSBpdGVtLnZhbGlkaXR5O1xuICAgICAgICBjb25zdCBjdXN0b212YWxpZGl0eSA9IChwYXR0ZXJuTWlzbWF0Y2gpID9cbiAgICAgICAgICB0aGlzLmdldF9tZXNzYWdlKGl0ZW0sICdpbnZhbGlkJykgOiAnJztcbiAgICAgICAgaWYgKGl0ZW0uY2hlY2tWYWxpZGl0eSgpID09PSB0cnVlKSB7XG4gICAgICAgICAgaXRlbS5kYXRhc2V0LmludmFsaWQgPSAnJztcbiAgICAgICAgICBpdGVtLnNldEN1c3RvbVZhbGlkaXR5KFwiXCIpO1xuICAgICAgICAgIGlmIChpdGVtID09IGlucHV0ICYmIGxhYmVsICE9PSBudWxsKSBsYWJlbC5jbGFzc0xpc3QucmVtb3ZlKGZvcm1jc3MuaW52YWxpZCk7XG4gICAgICAgICAgZWxzZSBpZiAobGFiZWx0YXJnZXQgIT09IG51bGwpIGxhYmVsdGFyZ2V0LmNsYXNzTGlzdC5yZW1vdmUoZm9ybWNzcy5pbnZhbGlkKTtcbiAgICAgICAgICBpdGVtLmNsYXNzTGlzdC5yZW1vdmUoZm9ybWNzcy5pbnB1dHZhbGlkYXRlKTtcbiAgICAgICAgICBpZiAoaXRlbS52YWx1ZSAhPT0gaXRlbXRhcmdldC52YWx1ZSkge1xuICAgICAgICAgICAgaW5wdXQuc2V0Q3VzdG9tVmFsaWRpdHkoaW52YWxpZCk7XG4gICAgICAgICAgICBpbnB1dC5kYXRhc2V0LmludmFsaWQgPSBpbnZhbGlkO1xuICAgICAgICAgICAgaWYgKGxhYmVsKSBsYWJlbC5jbGFzc0xpc3QuYWRkKGZvcm1jc3MuaW52YWxpZCk7XG4gICAgICAgICAgICBpbnB1dC5jbGFzc0xpc3QuYWRkKGZvcm1jc3MuaW5wdXR2YWxpZGF0ZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlucHV0LnNldEN1c3RvbVZhbGlkaXR5KFwiXCIpO1xuICAgICAgICAgICAgaW5wdXQuZGF0YXNldC5pbnZhbGlkID0gXCJcIjtcbiAgICAgICAgICAgIGlmIChsYWJlbCkgbGFiZWwuY2xhc3NMaXN0LnJlbW92ZShmb3JtY3NzLmludmFsaWQpO1xuICAgICAgICAgICAgaW5wdXQuY2xhc3NMaXN0LnJlbW92ZShmb3JtY3NzLmlucHV0dmFsaWRhdGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpdGVtLnNldEN1c3RvbVZhbGlkaXR5KGN1c3RvbXZhbGlkaXR5KTtcbiAgICAgICAgICBpdGVtLmRhdGFzZXQuaW52YWxpZCA9IGN1c3RvbXZhbGlkaXR5O1xuICAgICAgICAgIGlmIChsYWJlbCkgbGFiZWwuY2xhc3NMaXN0LmFkZChmb3JtY3NzLmludmFsaWQpO1xuICAgICAgICAgIGl0ZW0uY2xhc3NMaXN0LmFkZChmb3JtY3NzLmlucHV0dmFsaWRhdGUpO1xuICAgICAgICB9XG4gICAgICAgIGl0ZW0uZm9jdXMoKTtcbiAgICAgIH07XG4gICAgICBbaW5wdXQsIHRhcmdldF0uZm9yRWFjaChpdGVtID0+IHtcbiAgICAgICAgaXRlbS5hZGRFdmVudExpc3RlbmVyKCdrZXl1cCcsIChlKSA9PiB7XG4gICAgICAgICAgY29uc3QgaXRlbXRhcmdldCA9IChpdGVtID09PSBpbnB1dCkgPyB0YXJnZXQgOiBpbnB1dDtcbiAgICAgICAgICBjaGVja19tYXRjaChpdGVtLCBpdGVtdGFyZ2V0KTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcblxuICAgIH0pO1xuICB9XG4gIGdldF9tZXNzYWdlKGZpZWxkLCB0eXBlID0gJ2ludmFsaWQnKSB7XG4gICAgaWYgKGZpZWxkLmNoZWNrVmFsaWRpdHkoKSA9PSBmYWxzZSkge1xuICAgICAgY29uc3Qge1xuICAgICAgICB2YWx1ZU1pc3NpbmcgPSB0cnVlXG4gICAgICB9ID0gZmllbGQudmFsaWRpdHk7XG4gICAgICBpZiAodmFsdWVNaXNzaW5nKSByZXR1cm4gKGZpZWxkLmRhdGFzZXQucmVxdWlyZWQpID8gZmllbGQuZGF0YXNldC5yZXF1aXJlZCA6ICgodGhpcy5mb3JtLmRhdGFzZXQucmVxdWlyZWQpID8gdGhpcy5mb3JtLmRhdGFzZXQucmVxdWlyZWQgOiAncmVxdWlyZWQnKTtcbiAgICAgIGVsc2UgcmV0dXJuIChmaWVsZC5kYXRhc2V0W3R5cGVdKSA/IGZpZWxkLmRhdGFzZXRbdHlwZV0gOiAnaW5wdXQgaW52YWxpZCc7XG4gICAgfSBlbHNlIHJldHVybiAnJztcbiAgfVxuXG4gIHZhbGlkYXRlRmllbGQoZmllbGQsIGluaXQgPSBmYWxzZSkge1xuXG5cblxuICAgIGlmIChbJ3RleHRhcmVhJywgJ2lucHV0J10uaW5kZXhPZihmaWVsZC50YWdOYW1lLnRvTG93ZXJDYXNlKCkpID49IDApIHtcblxuICAgIH1cbiAgICBpZiAoWydzZWxlY3QnLCAnaW5wdXRbdHlwZT1cImNoZWNrYm94XCJdJ10uaW5kZXhPZihmaWVsZC50YWdOYW1lLnRvTG93ZXJDYXNlKCkpID49IDApIHtcbiAgICAgIGZpZWxkLnF1ZXJ5U2VsZWN0b3JBbGwoJ29wdGlvbjpjaGVja2VkJykuZm9yRWFjaChvcHRpb24gPT4ge1xuICAgICAgICBvcHRpb24udmFsdWUgPSBET01QdXJpZnkuc2FuaXRpemUob3B0aW9uLnZhbHVlKTtcbiAgICAgIH0pO1xuXG4gICAgfSBlbHNlIGZpZWxkLnZhbHVlID0gRE9NUHVyaWZ5LnNhbml0aXplKGZpZWxkLnZhbHVlKTtcblxuICAgIGNvbnN0IHJlcCA9IGZpZWxkLmNoZWNrVmFsaWRpdHkoKTtcblxuICAgIGlmIChmaWVsZC5jbGFzc0xpc3QuY29udGFpbnMoJ3NlbGVjdC1vbmUnKSkge1xuICAgICAgY29uc29sZS5sb2coJ3NlbGVjdCByZXAnLCByZXApO1xuICAgIH1cbiAgICBjb25zdCBsYWJlbCA9IGZpZWxkLmNsb3Nlc3QoJy5mb3JtLWJveCcpID8gZmllbGQuY2xvc2VzdCgnLmZvcm0tYm94JykucXVlcnlTZWxlY3RvcignbGFiZWwnKSA6IG51bGw7XG5cbiAgICBpZiAocmVwICYmIGxhYmVsKSB7XG4gICAgICBsYWJlbC5jbGFzc0xpc3QucmVtb3ZlKGZvcm1jc3MuaW52YWxpZCk7XG4gICAgfSBlbHNlIGlmICghcmVwKSB7XG4gICAgICBpZiAobGFiZWwpIHtcbiAgICAgICAgbGFiZWwuZGF0YXNldC5pbnZhbGlkID0gdGhpcy5nZXRfbWVzc2FnZShmaWVsZCk7XG4gICAgICAgIGxhYmVsLmNsYXNzTGlzdC5hZGQoZm9ybWNzcy5pbnZhbGlkKTtcbiAgICAgICAgd2luZG93LnNjcm9sbFRvKHtcbiAgICAgICAgICB0b3A6IHBhcnNlSW50KGxhYmVsLm9mZnNldFRvcCksXG4gICAgICAgICAgbGVmdDogcGFyc2VJbnQobGFiZWwub2Zmc2V0TGVmdCksXG4gICAgICAgICAgYmVoYXZpb3I6ICdzbW9vdGgnXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVwO1xuICB9XG5cbiAgdmFsaWRhdGVGaWVsZHMoaW5pdCA9IGZhbHNlKSB7XG4gICAgLy90b2RvOiBjb21wbGV0ZSB2YWxpZGF0aW9uIGZvcmVhY2ggZmllbGQgdHlwZVxuICAgIGxldCByZXNwID0gdHJ1ZTtcbiAgICAvLyAucmVxdWlyZWQgaW5wdXQgZm9yIHRvbS1zZWxlY3QgY29tcG9uZW50XG5cbiAgICBbLi4udGhpcy5mb3JtLmVsZW1lbnRzXS5mb3JFYWNoKGZpZWxkID0+IHtcbiAgICAgIGlmIChmaWVsZC5uYW1lKSB7XG5cbiAgICAgICAgaWYgKGluaXQgPT09IHRydWUpIHtcblxuICAgICAgICAgIGlmICghZmllbGQuZGF0YXNldC5saXN0ZW4pIHtcbiAgICAgICAgICAgIGlmIChmaWVsZC5oYXNBdHRyaWJ1dGUoJ3JlcXVpcmVkJykgJiYgZmllbGQucmVxdWlyZWQpIHtcbiAgICAgICAgICAgICAgY29uc3QgbGFiZWwgPSBmaWVsZC5jbG9zZXN0KCcuZm9ybS1ib3gnKSA/IGZpZWxkLmNsb3Nlc3QoJy5mb3JtLWJveCcpLnF1ZXJ5U2VsZWN0b3IoJ2xhYmVsJykgOiBmaWVsZC5wYXJlbnRFbGVtZW50LnF1ZXJ5U2VsZWN0b3IoJ2xhYmVsJyk7XG4gICAgICAgICAgICAgIGlmIChsYWJlbCkgbGFiZWwuY2xhc3NMaXN0LmFkZCgncmVxdWlyZWQnKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgWydjaGFuZ2UnLCAnYmx1ciddLmZvckVhY2goZXZ0ID0+IHtcbiAgICAgICAgICAgICAgZmllbGQuYWRkRXZlbnRMaXN0ZW5lcihldnQsIChlKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy52YWxpZGF0ZUZpZWxkKGUuY3VycmVudFRhcmdldCwgaW5pdCk7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBmaWVsZC5kYXRhc2V0Lmxpc3RlbiA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgcmVzcCA9IChyZXNwICYmIHRoaXMudmFsaWRhdGVGaWVsZChmaWVsZCwgaW5pdCkpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiByZXNwO1xuICB9XG5cbiAgYWRkSGFuZGxlcihoYW5kbGVyKSB7XG4gICAgdGhpcy5oYW5kbGVycy5wdXNoKGhhbmRsZXIpO1xuICB9XG4gIGZpZWxkRW5hYmxlKGVuYWJsZSA9IHRydWUpIHtcbiAgICB0aGlzLmZvcm0ucXVlcnlTZWxlY3RvckFsbCgnaW5wdXRbZGF0YS1zdWI9XCJlbmFibGVcIl0nKS5mb3JFYWNoKGlucHV0ID0+IHtcbiAgICAgIGlmIChlbmFibGUgPT09IHRydWUpIHtcbiAgICAgICAgaW5wdXQucmVtb3ZlQXR0cmlidXRlKFwiZGlzYWJsZWRcIik7XG4gICAgICB9IGVsc2UgaW5wdXQuZGlzYWJsZWQgPSB0cnVlO1xuICAgIH0pO1xuICB9XG5cbiAgYXN5bmMgc3VibWl0SGFuZGxlcigpIHtcbiAgICBpZiAoIXRoaXMudmFsaWRhdGVGaWVsZHMoKSkgcmV0dXJuIGZhbHNlO1xuXG4gICAgaWYgKHRoaXMuaGFuZGxlcnMubGVuZ3RoID09PSAwKSByZXR1cm4gdHJ1ZTtcbiAgICBsZXQgcmVzcCA9IHRydWU7XG4gICAgLy8gc2VyaWVzXG4gICAgLyogIGZvciAoY29uc3QgaGFuZGxlciBvZiB0aGlzLmhhbmRsZXJzKSB7XG4gICAgICAgICAgY29uc3QgcmVwID0gYXdhaXQgaGFuZGxlcigpXG4gICAgICAgICAgcmVzcCA9IChyZXNwICYmIHJlcClcbiAgICAgIH0qL1xuICAgIC8vIGNvbmN1cnJlbnRcbiAgICBhd2FpdCBQcm9taXNlLmFsbCh0aGlzLmhhbmRsZXJzLm1hcChhc3luYyBoYW5kbGVyID0+IHtcbiAgICAgIGNvbnN0IHJlcCA9IGF3YWl0IGhhbmRsZXIoKTtcbiAgICAgIHJlc3AgPSAocmVzcCAmJiByZXApO1xuICAgIH0pKTtcbiAgICBpZiAocmVzcCA9PT0gdHJ1ZSkgdGhpcy5oYW5kbGVycyA9IFtdO1xuICAgIHJldHVybiByZXNwO1xuICB9XG4gIC8vIG5vIHJlZGlyZWN0aW9uIHdoZW4gdXNpbmcgZGF0YS1mZXRjaFxuICBmb3JtRmV0Y2goZm9ybWF0ID0gbnVsbCkge1xuICAgIGNvbnN0IGZvcm1kYXRhID0gbmV3IEZvcm1EYXRhKHRoaXMuZm9ybSk7XG4gICAgZm9ybWRhdGFbXCJmZXRjaFwiXSA9IHRydWU7XG4gICAgZmV0Y2godGhpcy5mb3JtLmFjdGlvbiwgZmV0Y2hTZXR0aW5ncyh7XG4gICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICBib2R5OiBmb3JtZGF0YSxcbiAgICAgIH0pKVxuICAgICAgLnRoZW4ocmVzcG9uc2UgPT4ge1xuICAgICAgICBzd2l0Y2ggKGZvcm1hdCkge1xuICAgICAgICAgIGNhc2UgXCJ0ZXh0XCI6XG4gICAgICAgICAgY2FzZSBcImh0bWxcIjpcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZS50ZXh0KCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICAgIC50aGVuKHJlc3BvbnNlID0+IHtcbiAgICAgICAgdGhpcy5kaXNwbGF5UmVzcG9uc2UocmVzcG9uc2UpO1xuICAgICAgfSlcbiAgICAgIC5jYXRjaChlcnIgPT4ge1xuICAgICAgICB0aGlzLmRpc3BsYXlSZXNwb25zZShlcnIsIHRydWUpXG4gICAgICB9KS5maW5hbGx5KHJlc3BvbnNlID0+IHtcbiAgICAgICAgdGhpcy5mb3JtLmRpc2FibGVkID0gdHJ1ZTtcbiAgICAgIH0pO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGFzeW5jIHN1Ym1pdEZvcm0oKSB7XG4gICAgdGhpcy5maWVsZEVuYWJsZSgpO1xuICAgIGlmICh0aGlzLnZhbGlkYXRlRmllbGRzKGZhbHNlKSkge1xuICAgICAgY29uc3QgaXNib3QgPSAodGhpcy5mb3JtLnF1ZXJ5U2VsZWN0b3IoZG9tc2VsZWN0b3JzLmNhcHRjaGEpKSA/ICh0aGlzLmZvcm0uZGF0YXNldC5pc2JvdCA/ICh0aGlzLmZvcm0uZGF0YXNldC5pc2JvdCA9PT0gdHJ1ZSkgOiB0cnVlKSA6IGZhbHNlO1xuICAgICAgaWYgKGlzYm90ID09PSB0cnVlKSByZXR1cm4gZmFsc2U7XG4gICAgICBjb25zdCB5ZXNzdWJtaXQgPSBhd2FpdCB0aGlzLnN1Ym1pdEhhbmRsZXIoKTtcbiAgICAgIGlmICh5ZXNzdWJtaXQpIHtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5mZXRjaCkgdGhpcy5mb3JtRmV0Y2godGhpcy5vcHRpb25zLmZldGNoKTtcbiAgICAgICAgZWxzZSB0aGlzLmZvcm0uc3VibWl0KCk7XG4gICAgICAgIHRoaXMuZm9ybS5kaXNhYmxlZCA9IHRydWU7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSBlbHNlIHJldHVybiBmYWxzZTtcbiAgICB9IGVsc2UgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgZGlzcGxheVJlc3BvbnNlKHJlc3BvbnNlLCBlcnJvciA9IGZhbHNlKSB7XG4gICAgY29uc3QgZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBlbC5pbnNlcnRBZGphY2VudEhUTUwoJ2FmdGVyYmVnaW4nLCByZXNwb25zZSk7XG4gICAgaWYgKGVycm9yICE9PSBmYWxzZSkgZWwuY2xhc3NMaXN0LmFkZCgnaXMtZXJyb3InKTtcbiAgICB0aGlzLmZvcm0ucGFyZW50RWxlbWVudC5pbnNlcnRCZWZvcmUoZWwsIHRoaXMuZm9ybSk7XG4gICAgdGhpcy5mb3JtLnJlbW92ZSgpO1xuICB9XG59Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/modules/form-submit.js\n")},"./src/modules/js-upload.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   JsUpload: () => (/* binding */ JsUpload)\n/* harmony export */ });\n/* harmony import */ var dompurify__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! dompurify */ \"./node_modules/dompurify/dist/purify.js\");\n/* harmony import */ var dompurify__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(dompurify__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var fflate__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! fflate */ \"./node_modules/fflate/esm/browser.js\");\n/* harmony import */ var _modules_form_submit_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../modules/form-submit.js */ \"./src/modules/form-submit.js\");\n/* harmony import */ var _modules_utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../modules/utils.js */ \"./src/modules/utils.js\");\n/* harmony import */ var _modules_modules_config_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../modules/modules-config.js */ \"./src/modules/modules-config.js\");\n\n\n\n\n\n\nconst already_compressed = new Set([\n  'zip', 'gz', 'png', 'jpg', 'jpeg', 'pdf', 'doc', 'docx', 'ppt', 'pptx',\n  'xls', 'xlsx', 'heic', 'heif', '7z', 'bz2', 'rar', 'gif', 'webp', 'webm',\n  'mp4', 'mov', 'mp3', 'aifc'\n]);\nconst accept = '.tsv,.png,.jpg, .jpeg,.zip,.gz,.7z,.bz2';\nconst largefile = 50000;\nconst chunksize = 2000000;\nlet instance = null;\nconst defdir = \"ecotaxa_import\";\n\nclass JsUpload {\n  zipstream;\n  zipsize = 0;\n  pathname;\n  zipname;\n  numfiles = 0;\n  sizefiles = 0;\n  zipparts = [];\n  counter = 0;\n  counterdisplay = null;\n  ziptrigger = null;\n  displaylist = null;\n  timer = 0;\n  targetdir = '';\n  sent = false;\n  dropzone;\n  root = '.';\n  constructor(container, callback = null, options = {}) {\n    if (instance) return instance;\n    container = (container instanceof HTMLElement) ? container : document.querySelector(container);\n    if (!container) return;\n    this.container = container;\n    this.callback = callback;\n    const defaultOptions = {\n      level: 0,\n      //  url: \"http://localhost:5001/gui/files/upload\",\n      url: \"https://localhost:8000/my_files/\",\n      filefield: 'file',\n      selector: {\n        makezip: '.makezip',\n        droptarget: '.droptarget',\n        trigger: '.trigger',\n        uploadfile: 'uploadfile',\n        formu: 'formupload',\n        stepper: 'stepper',\n        stepitem: 'stepper-item',\n        filetoload: 'file_to_load',\n        progress: \"progress-upload\"\n      },\n      display: {\n        dropzone: 'dropzone',\n        counter: 'counter',\n        size: 'sizetozip',\n        counterzipped: 'counterzipped',\n        sizezipped: 'sizezipped',\n        dirlist: 'dirlist',\n        boxtitle: 'boxtitle',\n        timer: 'timer'\n      },\n      css: {\n        enabled: 'enabled'\n      }\n    };\n\n    this.options = Object.assign(defaultOptions, options);\n\n    this.init(container);\n    instance = this;\n    return instance;\n  }\n\n  init(container) {\n    // create a filepicker depends on browser\n    this.dropzone = document.createElement('div');\n    this.dropzone.id = this.options.display.dropzone;\n    this.dropzone.innerHTML = `<input type=\"file\" class=\"hidden\"  name=\"${this.options.selector.uploadfile}\" id=\"${this.options.selector.uploadfile}\">\n            <div class=\"${this.options.selector.droptarget.slice(1)}\">\n            <div id=\"${this.options.display.boxtitle}\"><span class=\"${this.options.selector.trigger.slice(1)}\">${this.container.dataset.textbrowse}</span>  ${this.container.dataset.textdrop}</div>\n          </div><div><span id=\"${this.options.display.counter}\"></span>/<span id=\"${this.options.display.counterzipped}\"></span></div>\n          <div><span id=\"${this.options.display.size}\"></span>/<span id=\"${this.options.display.sizezipped}\"></span></div><div id=\"${this.options.display.timer}\"></div>\n          <div id=\"${this.options.selector.makezip.slice(1)}\" class=\"button ${this.options.selector.makezip.slice(1)} ${_modules_modules_config_js__WEBPACK_IMPORTED_MODULE_3__.css.hide} \"><div id=\"${this.options.selector.progress}\"></div>${container.dataset.ended}</div>`;\n    container.append(this.dropzone);\n    this.counterdisplay = document.getElementById(this.options.display.counter);\n    this.counterzippeddisplay = document.getElementById(this.options.display.counterzipped);\n    this.sizedisplay = document.getElementById(this.options.display.size);\n    this.sizezippeddisplay = document.getElementById(this.options.display.sizezipped);\n    this.ziptrigger = container.querySelector(this.options.selector.makezip);\n    this.displaylist = document.getElementById(this.options.display.dirlist);\n    const droptarget = this.container.querySelector(this.options.selector.droptarget);\n    droptarget.addEventListener('dragover', (e) => {\n      this.handleDragOver(e);\n    });\n    droptarget.addEventListener('drop', async (e) => {\n      this.handleDrop(e);\n\n    });\n    container.querySelector(this.options.selector.trigger).addEventListener('click', (e) => {\n      let datatransfer = e;\n      this.openDirDialog(accept, (e) => {\n        console.log('edrop', datatransfer)\n      });\n    });\n  }\n  attachDropzone(target) {\n    console.log('attch', target);\n    this.targetdir = (target.parentElement.dataset.name) ? target.parentElement.dataset.name : '';\n    console.log('targetdir', this.targetdir)\n    this.dropzone.classList.add(this.options.css.enabled);\n    console.log('att', this.dropzone);\n    target.append(this.dropzone);\n  }\n  detachDropzone() {\n    this.targetdir = null;\n    this.container.classList.remove(this.options.css.enabled);\n\n  }\n  openDirDialog(accept, callback) {\n    const input = document.createElement(\"input\");\n    input.type = \"file\";\n    input.directory = true;\n    input.multiple = true;\n    input.webkitdirectory = true;\n    input.allowdirs = true;\n    input.accept = accept;\n    input.addEventListener(\"change\", callback);\n    input.dispatchEvent(new MouseEvent(\"click\"));\n  }\n  handleDragOver(e) {\n    e.preventDefault();\n    e.dataTransfer.dropEffect = \"move\";\n  }\n\n  async handleDrop(e) {\n    let dataTransfer;\n    if (e.dataTransfer) {\n      e.preventDefault();\n      dataTransfer = e.dataTransfer;\n    } else dataTransfer = e;\n    this.timer = new Date();\n    console.log('dataTransfer ', dataTransfer.items)\n\n    const items = [...((dataTransfer.items) ? dataTransfer.items : dataTransfer.files)];\n    if (items.length) {\n      this.enableDropzone(false);\n      this.zipname = '_upload.zip';\n      this.zip = new fflate__WEBPACK_IMPORTED_MODULE_4__.Zip();\n\n      this.zipReadableStream = await this.fflToStream();\n      const on_error = (err) => {\n        console.log('err_read_dir', err);\n      }\n      const on_complete = async () => {\n        this.timer = (new Date() - this.timer) / 1000;\n        console.log('item-------------------------------------' + parseInt(this.timer / 60) + ' --- ' + (\n          this.timer - (parseInt(this.timer / 60) * 60)), this.zip);\n        this.enableDropzone();\n        this.zip.end();\n        this.ziptrigger.classList.remove(_modules_modules_config_js__WEBPACK_IMPORTED_MODULE_3__.css.hide);\n        this.ziptrigger.addEventListener('click', async (e) => {\n          this.ziptrigger.disabled = true;\n          console.log('upload click')\n          this.enableDropzone(false, true);\n\n          return await this.sendZip();\n        });\n      }\n      //this.pathname.pop();\n      for (let i = 0; i < items.length; i++) {\n        let item = items[i].webkitGetAsEntry();\n        if (item.isDirectory === true) {\n          this.zipname = item.name + this.zipname;\n          await this.readDirectory(item, this.root, on_complete);\n        } else if (item.isFile === true) {\n          // put directly in input file\n\n        }\n\n      }\n    }\n  }\n  stopOnError(err) {\n    console.log('err', err);\n  }\n\n  enableDropzone(enable = true, destroy = false) {\n    if (destroy) this.dropzone.classList.add(_modules_modules_config_js__WEBPACK_IMPORTED_MODULE_3__.css.hide);\n    if (enable) this.dropzone.classList.add(this.options.css.enabled);\n    else this.dropzone.classList.remove(this.options.css.enabled);\n\n  }\n  async supportsRequestStreams() {\n    let duplexAccessed = false;\n    const hasContentType = new Request(this.options.url, {\n      body: new ReadableStream(),\n      method: 'POST',\n      get duplex() {\n        duplexAccessed = true;\n        return 'half';\n      },\n    }).headers.has('Content-Type');\n\n    return duplexAccessed && !hasContentType;\n  }\n\n  fileType(data) {\n    const mime_type = (signature) => {\n      switch (signature) {\n        case '89504E47':\n          return 'image/png';\n        case '47494638':\n          return 'image/gif';\n        case '25504446':\n          return 'application/pdf';\n        case 'FFD8FFDB':\n        case 'FFD8FFE0':\n        case 'FFD8FFE1':\n          return 'image/jpeg';\n        case '504B0304':\n          return 'application/zip';\n        case 'EFBBBF22':\n          return 'text/tsv'; //'text/tab-separated-values';\n        default:\n          console.log('unknownsign', signature)\n          return 'unknown';\n      }\n    }\n    const uint = new Uint8Array(data);\n    let bytes = []\n    for (let i = 0; i < 4; i++) {\n      bytes.push(uint[i].toString(16))\n    }\n    data = bytes.join('').toUpperCase();\n    return {\n      input: uint,\n      mimetype: mime_type(data)\n    };\n  }\n\n  async fflToStream() {\n    const fflateStream = this.zip;\n    const transform = new TransformStream();\n    const writer = transform.writable.getWriter();\n    return new TransformStream({\n      start(controller) {\n        fflateStream.ondata = (error, data, final) => {\n          if (error) {\n            console.log('error', error);\n            return false;\n          } else {\n            controller.enqueue(data);\n            if (final) {\n              console.log('final', final);\n              //  controller.terminate();\n            }\n\n          }\n        }\n      },\n      flush(controller) {\n        console.log('terminate ffstrem')\n        controller.terminate();\n      }\n    })\n\n  }\n  //\n\n\n  async readDirectory(dir, parent, oncomplete, onerror = null) {\n    console.log('read', dir.name)\n    const self = this;\n    let errored = false;\n    let direntries = [],\n      handlers = [],\n      files = [];\n\n    const on_error = onerror ? onerror : (err) => {\n      console.log('on_error', err)\n      if (!errored) {\n        errored = true;\n\n      }\n    };\n\n    const readfile = async function(file, zippedstream) {\n      const reader = file.stream().getReader();\n      while (true) {\n        const {\n          done,\n          value\n        } = await reader.read();\n        if (done) {\n          await zippedstream.push(new Uint8Array(0), true);\n          return done;\n        }\n        await zippedstream.push(value);\n      }\n\n    };\n\n    //\n    const process_file = async function() {\n      const entry = files.shift();\n      const filepath = entry.fullPath.slice(1);\n      //  console.log('fileadd=' + self.numfiles, entry.name)\n      const ext = filepath.slice(filepath.lastIndexOf('.') + 1);\n      const zip_file = async (filetozip) => {\n        const iscompressed = already_compressed.has(ext);\n        const zippedstream = iscompressed ?\n          new fflate__WEBPACK_IMPORTED_MODULE_4__.ZipPassThrough(filepath) :\n          filetozip.size > largefile ?\n          new fflate__WEBPACK_IMPORTED_MODULE_4__.AsyncZipDeflate(filepath, {\n            level: 9\n          }) : new fflate__WEBPACK_IMPORTED_MODULE_4__.ZipDeflate(filepath, {\n            level: 6\n          });\n        //  console.log('zipstr', zippedstream)\n        zippedstream.ondata = async function(err, dat, final) {\n          if (err) console.log('err add chunk to zipfile' + dat, err);\n          else if (final) {\n\n            if (files.length) {\n              console.log('files', files.length);\n              await process_file();\n            } else {\n              console.log('lastfile', dir.name);\n              await on_complete();\n            }\n          }\n        };\n        await self.zip.add(zippedstream);\n        return await readfile(filetozip, zippedstream);\n      };\n      self.numfiles++;\n      if (self.numfiles === 1) {\n        fetch(self.options.url.replace('my_files', 'stream_my_files'), {\n          mode: 'cors',\n          method: \"POST\",\n          credentials: \"include\",\n          headers: {\n            \"Content-Type\": \"application/zip\",\n          },\n          body: self.zipReadableStream.readable,\n          duplex: 'half',\n        }).then((response) => {\n          console.log('response', response);\n        });\n      }\n      await entry.file(zip_file);\n\n    };\n    //\n\n    const process_entries = function() {\n      const entry = direntries.shift();\n      if (entry.isFile) {\n        //console.log('fileleft ***---' + dir.name, entry.name);\n        self.counter++;\n        self.counterdisplay.textContent = self.counter;\n        //const f = entry.getAsFile();\n        files.push(entry);\n        //  await process_file(entry, entry.fullPath.slice(1));\n        self.counter--;\n        self.counterdisplay.textContent = self.counter;\n      } else if (entry.isDirectory) {\n        console.log('entry is dir', entry)\n        handlers.push(entry);\n      }\n      if (direntries.length) process_entries();\n\n    }\n    const on_complete = async function() {\n      for (const handler of handlers) {\n        console.log(handler);\n        await self.readDirectory(handler, dir, async function() {\n          console.log('idir', handler.name);\n          if (files.length) await process_file();\n        });\n      }\n\n    }\n    const reader = dir.createReader();\n    const on_read = async function(ents) {\n      if (ents.length && !errored) {\n        direntries = [...direntries, ...ents];\n        await reader.readEntries(on_read, on_error);\n      } else if (!errored) {\n        process_entries();\n        console.log('theend------------------- ' + dir.name, direntries.length)\n        await on_complete();\n\n\n      } else {\n        console.log('treat error readdir');\n      }\n    }\n\n    await reader.readEntries(on_read, on_error);\n\n    console.log('enddir' + dir.name, direntries.length)\n\n  }\n\n  compressionLevel(name) {\n    if (!name) {\n\n      return -1;\n    }\n    let ext = name.split('.');\n    ext = (ext.length > 1) ? ext[ext.length - 1] : ext[0];\n    return (already_compressed.find(ex => (ex === ext))) ? 2 : this.options.level;\n  }\n\n  async sendZip() {\n    //  const filestream = new WritableStream();\n    //  const writer = filestream.getWriter();\n    //\n\n    //\n\n\n    /*  fetch(this.options.url.replace('my_files', 'stream_my_files'), {\n        mode: 'cors',\n        method: \"POST\",\n        credentials: \"include\",\n        headers: {\n          \"Content-Type\": \"text/plain\",\n        },\n        body: this.zipReadableStream,\n        duplex: 'half',\n      });*/\n    /**********************************/\n    /*webtransport\n      const transport = new WebTransport(this.options.url);\n\n      // Optionally, set up functions to respond to\n      // the connection closing:\n      transport.closed.then(() => {\n        console.log(`The HTTP/3 connection to ${url} closed gracefully.`);\n      }).catch((error) => {\n        console.error(`The HTTP/3 connection to ${url} closed due to ${error}.`);\n      });\n\n      // Once .ready fulfills, the connection can be used.\n      await transport.ready;\n      const streamsend = await transport.createUnidirectionalStream();\n      const writer = streamsend.writable.getWriter();\n      const streamtest = new ReadableStream({\n        async start(controller) {\n          await wait(1000);\n          controller.enqueue('This ');\n          await wait(1000);\n          controller.enqueue('is ');\n          await wait(1000);\n          controller.enqueue('a ');\n          await wait(1000);\n          controller.enqueue('slow ');\n          await wait(1000);\n          controller.enqueue('request.');\n          controller.close();\n        },\n      }).pipeTo(writer);\n\n    */\n\n\n\n\n  }\n\n\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87O0FBRVA7Ozs7O0FBS0E7OztBQUdBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vc3JjL21vZHVsZXMvanMtdXBsb2FkLmpzPzdjNDgiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IERPTVB1cmlmeSBmcm9tICdkb21wdXJpZnknO1xuaW1wb3J0IHtcbiAgWmlwLFxuICBBc3luY1ppcERlZmxhdGUsXG4gIFppcFBhc3NUaHJvdWdoLFxuICBaaXBEZWZsYXRlLFxufSBmcm9tICdmZmxhdGUnO1xuaW1wb3J0IHtcbiAgRm9ybVN1Ym1pdFxufSBmcm9tICcuLi9tb2R1bGVzL2Zvcm0tc3VibWl0LmpzJztcblxuaW1wb3J0IHtcbiAgZG93bmxvYWRfYmxvYixcbiAgZmV0Y2hTZXR0aW5ncyxcbn0gZnJvbSAnLi4vbW9kdWxlcy91dGlscy5qcyc7XG5pbXBvcnQge1xuICBjc3Ncbn0gZnJvbSAnLi4vbW9kdWxlcy9tb2R1bGVzLWNvbmZpZy5qcyc7XG5jb25zdCBhbHJlYWR5X2NvbXByZXNzZWQgPSBuZXcgU2V0KFtcbiAgJ3ppcCcsICdneicsICdwbmcnLCAnanBnJywgJ2pwZWcnLCAncGRmJywgJ2RvYycsICdkb2N4JywgJ3BwdCcsICdwcHR4JyxcbiAgJ3hscycsICd4bHN4JywgJ2hlaWMnLCAnaGVpZicsICc3eicsICdiejInLCAncmFyJywgJ2dpZicsICd3ZWJwJywgJ3dlYm0nLFxuICAnbXA0JywgJ21vdicsICdtcDMnLCAnYWlmYydcbl0pO1xuY29uc3QgYWNjZXB0ID0gJy50c3YsLnBuZywuanBnLCAuanBlZywuemlwLC5neiwuN3osLmJ6Mic7XG5jb25zdCBsYXJnZWZpbGUgPSA1MDAwMDtcbmNvbnN0IGNodW5rc2l6ZSA9IDIwMDAwMDA7XG5sZXQgaW5zdGFuY2UgPSBudWxsO1xuY29uc3QgZGVmZGlyID0gXCJlY290YXhhX2ltcG9ydFwiO1xuXG5leHBvcnQgY2xhc3MgSnNVcGxvYWQge1xuICB6aXBzdHJlYW07XG4gIHppcHNpemUgPSAwO1xuICBwYXRobmFtZTtcbiAgemlwbmFtZTtcbiAgbnVtZmlsZXMgPSAwO1xuICBzaXplZmlsZXMgPSAwO1xuICB6aXBwYXJ0cyA9IFtdO1xuICBjb3VudGVyID0gMDtcbiAgY291bnRlcmRpc3BsYXkgPSBudWxsO1xuICB6aXB0cmlnZ2VyID0gbnVsbDtcbiAgZGlzcGxheWxpc3QgPSBudWxsO1xuICB0aW1lciA9IDA7XG4gIHRhcmdldGRpciA9ICcnO1xuICBzZW50ID0gZmFsc2U7XG4gIGRyb3B6b25lO1xuICByb290ID0gJy4nO1xuICBjb25zdHJ1Y3Rvcihjb250YWluZXIsIGNhbGxiYWNrID0gbnVsbCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgaWYgKGluc3RhbmNlKSByZXR1cm4gaW5zdGFuY2U7XG4gICAgY29udGFpbmVyID0gKGNvbnRhaW5lciBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KSA/IGNvbnRhaW5lciA6IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoY29udGFpbmVyKTtcbiAgICBpZiAoIWNvbnRhaW5lcikgcmV0dXJuO1xuICAgIHRoaXMuY29udGFpbmVyID0gY29udGFpbmVyO1xuICAgIHRoaXMuY2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICBjb25zdCBkZWZhdWx0T3B0aW9ucyA9IHtcbiAgICAgIGxldmVsOiAwLFxuICAgICAgLy8gIHVybDogXCJodHRwOi8vbG9jYWxob3N0OjUwMDEvZ3VpL2ZpbGVzL3VwbG9hZFwiLFxuICAgICAgdXJsOiBcImh0dHBzOi8vbG9jYWxob3N0OjgwMDAvbXlfZmlsZXMvXCIsXG4gICAgICBmaWxlZmllbGQ6ICdmaWxlJyxcbiAgICAgIHNlbGVjdG9yOiB7XG4gICAgICAgIG1ha2V6aXA6ICcubWFrZXppcCcsXG4gICAgICAgIGRyb3B0YXJnZXQ6ICcuZHJvcHRhcmdldCcsXG4gICAgICAgIHRyaWdnZXI6ICcudHJpZ2dlcicsXG4gICAgICAgIHVwbG9hZGZpbGU6ICd1cGxvYWRmaWxlJyxcbiAgICAgICAgZm9ybXU6ICdmb3JtdXBsb2FkJyxcbiAgICAgICAgc3RlcHBlcjogJ3N0ZXBwZXInLFxuICAgICAgICBzdGVwaXRlbTogJ3N0ZXBwZXItaXRlbScsXG4gICAgICAgIGZpbGV0b2xvYWQ6ICdmaWxlX3RvX2xvYWQnLFxuICAgICAgICBwcm9ncmVzczogXCJwcm9ncmVzcy11cGxvYWRcIlxuICAgICAgfSxcbiAgICAgIGRpc3BsYXk6IHtcbiAgICAgICAgZHJvcHpvbmU6ICdkcm9wem9uZScsXG4gICAgICAgIGNvdW50ZXI6ICdjb3VudGVyJyxcbiAgICAgICAgc2l6ZTogJ3NpemV0b3ppcCcsXG4gICAgICAgIGNvdW50ZXJ6aXBwZWQ6ICdjb3VudGVyemlwcGVkJyxcbiAgICAgICAgc2l6ZXppcHBlZDogJ3NpemV6aXBwZWQnLFxuICAgICAgICBkaXJsaXN0OiAnZGlybGlzdCcsXG4gICAgICAgIGJveHRpdGxlOiAnYm94dGl0bGUnLFxuICAgICAgICB0aW1lcjogJ3RpbWVyJ1xuICAgICAgfSxcbiAgICAgIGNzczoge1xuICAgICAgICBlbmFibGVkOiAnZW5hYmxlZCdcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdGhpcy5vcHRpb25zID0gT2JqZWN0LmFzc2lnbihkZWZhdWx0T3B0aW9ucywgb3B0aW9ucyk7XG5cbiAgICB0aGlzLmluaXQoY29udGFpbmVyKTtcbiAgICBpbnN0YW5jZSA9IHRoaXM7XG4gICAgcmV0dXJuIGluc3RhbmNlO1xuICB9XG5cbiAgaW5pdChjb250YWluZXIpIHtcbiAgICAvLyBjcmVhdGUgYSBmaWxlcGlja2VyIGRlcGVuZHMgb24gYnJvd3NlclxuICAgIHRoaXMuZHJvcHpvbmUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICB0aGlzLmRyb3B6b25lLmlkID0gdGhpcy5vcHRpb25zLmRpc3BsYXkuZHJvcHpvbmU7XG4gICAgdGhpcy5kcm9wem9uZS5pbm5lckhUTUwgPSBgPGlucHV0IHR5cGU9XCJmaWxlXCIgY2xhc3M9XCJoaWRkZW5cIiAgbmFtZT1cIiR7dGhpcy5vcHRpb25zLnNlbGVjdG9yLnVwbG9hZGZpbGV9XCIgaWQ9XCIke3RoaXMub3B0aW9ucy5zZWxlY3Rvci51cGxvYWRmaWxlfVwiPlxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cIiR7dGhpcy5vcHRpb25zLnNlbGVjdG9yLmRyb3B0YXJnZXQuc2xpY2UoMSl9XCI+XG4gICAgICAgICAgICA8ZGl2IGlkPVwiJHt0aGlzLm9wdGlvbnMuZGlzcGxheS5ib3h0aXRsZX1cIj48c3BhbiBjbGFzcz1cIiR7dGhpcy5vcHRpb25zLnNlbGVjdG9yLnRyaWdnZXIuc2xpY2UoMSl9XCI+JHt0aGlzLmNvbnRhaW5lci5kYXRhc2V0LnRleHRicm93c2V9PC9zcGFuPiAgJHt0aGlzLmNvbnRhaW5lci5kYXRhc2V0LnRleHRkcm9wfTwvZGl2PlxuICAgICAgICAgIDwvZGl2PjxkaXY+PHNwYW4gaWQ9XCIke3RoaXMub3B0aW9ucy5kaXNwbGF5LmNvdW50ZXJ9XCI+PC9zcGFuPi88c3BhbiBpZD1cIiR7dGhpcy5vcHRpb25zLmRpc3BsYXkuY291bnRlcnppcHBlZH1cIj48L3NwYW4+PC9kaXY+XG4gICAgICAgICAgPGRpdj48c3BhbiBpZD1cIiR7dGhpcy5vcHRpb25zLmRpc3BsYXkuc2l6ZX1cIj48L3NwYW4+LzxzcGFuIGlkPVwiJHt0aGlzLm9wdGlvbnMuZGlzcGxheS5zaXplemlwcGVkfVwiPjwvc3Bhbj48L2Rpdj48ZGl2IGlkPVwiJHt0aGlzLm9wdGlvbnMuZGlzcGxheS50aW1lcn1cIj48L2Rpdj5cbiAgICAgICAgICA8ZGl2IGlkPVwiJHt0aGlzLm9wdGlvbnMuc2VsZWN0b3IubWFrZXppcC5zbGljZSgxKX1cIiBjbGFzcz1cImJ1dHRvbiAke3RoaXMub3B0aW9ucy5zZWxlY3Rvci5tYWtlemlwLnNsaWNlKDEpfSAke2Nzcy5oaWRlfSBcIj48ZGl2IGlkPVwiJHt0aGlzLm9wdGlvbnMuc2VsZWN0b3IucHJvZ3Jlc3N9XCI+PC9kaXY+JHtjb250YWluZXIuZGF0YXNldC5lbmRlZH08L2Rpdj5gO1xuICAgIGNvbnRhaW5lci5hcHBlbmQodGhpcy5kcm9wem9uZSk7XG4gICAgdGhpcy5jb3VudGVyZGlzcGxheSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHRoaXMub3B0aW9ucy5kaXNwbGF5LmNvdW50ZXIpO1xuICAgIHRoaXMuY291bnRlcnppcHBlZGRpc3BsYXkgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCh0aGlzLm9wdGlvbnMuZGlzcGxheS5jb3VudGVyemlwcGVkKTtcbiAgICB0aGlzLnNpemVkaXNwbGF5ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQodGhpcy5vcHRpb25zLmRpc3BsYXkuc2l6ZSk7XG4gICAgdGhpcy5zaXplemlwcGVkZGlzcGxheSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHRoaXMub3B0aW9ucy5kaXNwbGF5LnNpemV6aXBwZWQpO1xuICAgIHRoaXMuemlwdHJpZ2dlciA9IGNvbnRhaW5lci5xdWVyeVNlbGVjdG9yKHRoaXMub3B0aW9ucy5zZWxlY3Rvci5tYWtlemlwKTtcbiAgICB0aGlzLmRpc3BsYXlsaXN0ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQodGhpcy5vcHRpb25zLmRpc3BsYXkuZGlybGlzdCk7XG4gICAgY29uc3QgZHJvcHRhcmdldCA9IHRoaXMuY29udGFpbmVyLnF1ZXJ5U2VsZWN0b3IodGhpcy5vcHRpb25zLnNlbGVjdG9yLmRyb3B0YXJnZXQpO1xuICAgIGRyb3B0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcignZHJhZ292ZXInLCAoZSkgPT4ge1xuICAgICAgdGhpcy5oYW5kbGVEcmFnT3ZlcihlKTtcbiAgICB9KTtcbiAgICBkcm9wdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoJ2Ryb3AnLCBhc3luYyAoZSkgPT4ge1xuICAgICAgdGhpcy5oYW5kbGVEcm9wKGUpO1xuXG4gICAgfSk7XG4gICAgY29udGFpbmVyLnF1ZXJ5U2VsZWN0b3IodGhpcy5vcHRpb25zLnNlbGVjdG9yLnRyaWdnZXIpLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKGUpID0+IHtcbiAgICAgIGxldCBkYXRhdHJhbnNmZXIgPSBlO1xuICAgICAgdGhpcy5vcGVuRGlyRGlhbG9nKGFjY2VwdCwgKGUpID0+IHtcbiAgICAgICAgY29uc29sZS5sb2coJ2Vkcm9wJywgZGF0YXRyYW5zZmVyKVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbiAgYXR0YWNoRHJvcHpvbmUodGFyZ2V0KSB7XG4gICAgY29uc29sZS5sb2coJ2F0dGNoJywgdGFyZ2V0KTtcbiAgICB0aGlzLnRhcmdldGRpciA9ICh0YXJnZXQucGFyZW50RWxlbWVudC5kYXRhc2V0Lm5hbWUpID8gdGFyZ2V0LnBhcmVudEVsZW1lbnQuZGF0YXNldC5uYW1lIDogJyc7XG4gICAgY29uc29sZS5sb2coJ3RhcmdldGRpcicsIHRoaXMudGFyZ2V0ZGlyKVxuICAgIHRoaXMuZHJvcHpvbmUuY2xhc3NMaXN0LmFkZCh0aGlzLm9wdGlvbnMuY3NzLmVuYWJsZWQpO1xuICAgIGNvbnNvbGUubG9nKCdhdHQnLCB0aGlzLmRyb3B6b25lKTtcbiAgICB0YXJnZXQuYXBwZW5kKHRoaXMuZHJvcHpvbmUpO1xuICB9XG4gIGRldGFjaERyb3B6b25lKCkge1xuICAgIHRoaXMudGFyZ2V0ZGlyID0gbnVsbDtcbiAgICB0aGlzLmNvbnRhaW5lci5jbGFzc0xpc3QucmVtb3ZlKHRoaXMub3B0aW9ucy5jc3MuZW5hYmxlZCk7XG5cbiAgfVxuICBvcGVuRGlyRGlhbG9nKGFjY2VwdCwgY2FsbGJhY2spIHtcbiAgICBjb25zdCBpbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpbnB1dFwiKTtcbiAgICBpbnB1dC50eXBlID0gXCJmaWxlXCI7XG4gICAgaW5wdXQuZGlyZWN0b3J5ID0gdHJ1ZTtcbiAgICBpbnB1dC5tdWx0aXBsZSA9IHRydWU7XG4gICAgaW5wdXQud2Via2l0ZGlyZWN0b3J5ID0gdHJ1ZTtcbiAgICBpbnB1dC5hbGxvd2RpcnMgPSB0cnVlO1xuICAgIGlucHV0LmFjY2VwdCA9IGFjY2VwdDtcbiAgICBpbnB1dC5hZGRFdmVudExpc3RlbmVyKFwiY2hhbmdlXCIsIGNhbGxiYWNrKTtcbiAgICBpbnB1dC5kaXNwYXRjaEV2ZW50KG5ldyBNb3VzZUV2ZW50KFwiY2xpY2tcIikpO1xuICB9XG4gIGhhbmRsZURyYWdPdmVyKGUpIHtcbiAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgZS5kYXRhVHJhbnNmZXIuZHJvcEVmZmVjdCA9IFwibW92ZVwiO1xuICB9XG5cbiAgYXN5bmMgaGFuZGxlRHJvcChlKSB7XG4gICAgbGV0IGRhdGFUcmFuc2ZlcjtcbiAgICBpZiAoZS5kYXRhVHJhbnNmZXIpIHtcbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgIGRhdGFUcmFuc2ZlciA9IGUuZGF0YVRyYW5zZmVyO1xuICAgIH0gZWxzZSBkYXRhVHJhbnNmZXIgPSBlO1xuICAgIHRoaXMudGltZXIgPSBuZXcgRGF0ZSgpO1xuICAgIGNvbnNvbGUubG9nKCdkYXRhVHJhbnNmZXIgJywgZGF0YVRyYW5zZmVyLml0ZW1zKVxuXG4gICAgY29uc3QgaXRlbXMgPSBbLi4uKChkYXRhVHJhbnNmZXIuaXRlbXMpID8gZGF0YVRyYW5zZmVyLml0ZW1zIDogZGF0YVRyYW5zZmVyLmZpbGVzKV07XG4gICAgaWYgKGl0ZW1zLmxlbmd0aCkge1xuICAgICAgdGhpcy5lbmFibGVEcm9wem9uZShmYWxzZSk7XG4gICAgICB0aGlzLnppcG5hbWUgPSAnX3VwbG9hZC56aXAnO1xuICAgICAgdGhpcy56aXAgPSBuZXcgWmlwKCk7XG5cbiAgICAgIHRoaXMuemlwUmVhZGFibGVTdHJlYW0gPSBhd2FpdCB0aGlzLmZmbFRvU3RyZWFtKCk7XG4gICAgICBjb25zdCBvbl9lcnJvciA9IChlcnIpID0+IHtcbiAgICAgICAgY29uc29sZS5sb2coJ2Vycl9yZWFkX2RpcicsIGVycik7XG4gICAgICB9XG4gICAgICBjb25zdCBvbl9jb21wbGV0ZSA9IGFzeW5jICgpID0+IHtcbiAgICAgICAgdGhpcy50aW1lciA9IChuZXcgRGF0ZSgpIC0gdGhpcy50aW1lcikgLyAxMDAwO1xuICAgICAgICBjb25zb2xlLmxvZygnaXRlbS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0nICsgcGFyc2VJbnQodGhpcy50aW1lciAvIDYwKSArICcgLS0tICcgKyAoXG4gICAgICAgICAgdGhpcy50aW1lciAtIChwYXJzZUludCh0aGlzLnRpbWVyIC8gNjApICogNjApKSwgdGhpcy56aXApO1xuICAgICAgICB0aGlzLmVuYWJsZURyb3B6b25lKCk7XG4gICAgICAgIHRoaXMuemlwLmVuZCgpO1xuICAgICAgICB0aGlzLnppcHRyaWdnZXIuY2xhc3NMaXN0LnJlbW92ZShjc3MuaGlkZSk7XG4gICAgICAgIHRoaXMuemlwdHJpZ2dlci5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGFzeW5jIChlKSA9PiB7XG4gICAgICAgICAgdGhpcy56aXB0cmlnZ2VyLmRpc2FibGVkID0gdHJ1ZTtcbiAgICAgICAgICBjb25zb2xlLmxvZygndXBsb2FkIGNsaWNrJylcbiAgICAgICAgICB0aGlzLmVuYWJsZURyb3B6b25lKGZhbHNlLCB0cnVlKTtcblxuICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnNlbmRaaXAoKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICAvL3RoaXMucGF0aG5hbWUucG9wKCk7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGl0ZW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxldCBpdGVtID0gaXRlbXNbaV0ud2Via2l0R2V0QXNFbnRyeSgpO1xuICAgICAgICBpZiAoaXRlbS5pc0RpcmVjdG9yeSA9PT0gdHJ1ZSkge1xuICAgICAgICAgIHRoaXMuemlwbmFtZSA9IGl0ZW0ubmFtZSArIHRoaXMuemlwbmFtZTtcbiAgICAgICAgICBhd2FpdCB0aGlzLnJlYWREaXJlY3RvcnkoaXRlbSwgdGhpcy5yb290LCBvbl9jb21wbGV0ZSk7XG4gICAgICAgIH0gZWxzZSBpZiAoaXRlbS5pc0ZpbGUgPT09IHRydWUpIHtcbiAgICAgICAgICAvLyBwdXQgZGlyZWN0bHkgaW4gaW5wdXQgZmlsZVxuXG4gICAgICAgIH1cblxuICAgICAgfVxuICAgIH1cbiAgfVxuICBzdG9wT25FcnJvcihlcnIpIHtcbiAgICBjb25zb2xlLmxvZygnZXJyJywgZXJyKTtcbiAgfVxuXG4gIGVuYWJsZURyb3B6b25lKGVuYWJsZSA9IHRydWUsIGRlc3Ryb3kgPSBmYWxzZSkge1xuICAgIGlmIChkZXN0cm95KSB0aGlzLmRyb3B6b25lLmNsYXNzTGlzdC5hZGQoY3NzLmhpZGUpO1xuICAgIGlmIChlbmFibGUpIHRoaXMuZHJvcHpvbmUuY2xhc3NMaXN0LmFkZCh0aGlzLm9wdGlvbnMuY3NzLmVuYWJsZWQpO1xuICAgIGVsc2UgdGhpcy5kcm9wem9uZS5jbGFzc0xpc3QucmVtb3ZlKHRoaXMub3B0aW9ucy5jc3MuZW5hYmxlZCk7XG5cbiAgfVxuICBhc3luYyBzdXBwb3J0c1JlcXVlc3RTdHJlYW1zKCkge1xuICAgIGxldCBkdXBsZXhBY2Nlc3NlZCA9IGZhbHNlO1xuICAgIGNvbnN0IGhhc0NvbnRlbnRUeXBlID0gbmV3IFJlcXVlc3QodGhpcy5vcHRpb25zLnVybCwge1xuICAgICAgYm9keTogbmV3IFJlYWRhYmxlU3RyZWFtKCksXG4gICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgIGdldCBkdXBsZXgoKSB7XG4gICAgICAgIGR1cGxleEFjY2Vzc2VkID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuICdoYWxmJztcbiAgICAgIH0sXG4gICAgfSkuaGVhZGVycy5oYXMoJ0NvbnRlbnQtVHlwZScpO1xuXG4gICAgcmV0dXJuIGR1cGxleEFjY2Vzc2VkICYmICFoYXNDb250ZW50VHlwZTtcbiAgfVxuXG4gIGZpbGVUeXBlKGRhdGEpIHtcbiAgICBjb25zdCBtaW1lX3R5cGUgPSAoc2lnbmF0dXJlKSA9PiB7XG4gICAgICBzd2l0Y2ggKHNpZ25hdHVyZSkge1xuICAgICAgICBjYXNlICc4OTUwNEU0Nyc6XG4gICAgICAgICAgcmV0dXJuICdpbWFnZS9wbmcnO1xuICAgICAgICBjYXNlICc0NzQ5NDYzOCc6XG4gICAgICAgICAgcmV0dXJuICdpbWFnZS9naWYnO1xuICAgICAgICBjYXNlICcyNTUwNDQ0Nic6XG4gICAgICAgICAgcmV0dXJuICdhcHBsaWNhdGlvbi9wZGYnO1xuICAgICAgICBjYXNlICdGRkQ4RkZEQic6XG4gICAgICAgIGNhc2UgJ0ZGRDhGRkUwJzpcbiAgICAgICAgY2FzZSAnRkZEOEZGRTEnOlxuICAgICAgICAgIHJldHVybiAnaW1hZ2UvanBlZyc7XG4gICAgICAgIGNhc2UgJzUwNEIwMzA0JzpcbiAgICAgICAgICByZXR1cm4gJ2FwcGxpY2F0aW9uL3ppcCc7XG4gICAgICAgIGNhc2UgJ0VGQkJCRjIyJzpcbiAgICAgICAgICByZXR1cm4gJ3RleHQvdHN2JzsgLy8ndGV4dC90YWItc2VwYXJhdGVkLXZhbHVlcyc7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgY29uc29sZS5sb2coJ3Vua25vd25zaWduJywgc2lnbmF0dXJlKVxuICAgICAgICAgIHJldHVybiAndW5rbm93bic7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHVpbnQgPSBuZXcgVWludDhBcnJheShkYXRhKTtcbiAgICBsZXQgYnl0ZXMgPSBbXVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNDsgaSsrKSB7XG4gICAgICBieXRlcy5wdXNoKHVpbnRbaV0udG9TdHJpbmcoMTYpKVxuICAgIH1cbiAgICBkYXRhID0gYnl0ZXMuam9pbignJykudG9VcHBlckNhc2UoKTtcbiAgICByZXR1cm4ge1xuICAgICAgaW5wdXQ6IHVpbnQsXG4gICAgICBtaW1ldHlwZTogbWltZV90eXBlKGRhdGEpXG4gICAgfTtcbiAgfVxuXG4gIGFzeW5jIGZmbFRvU3RyZWFtKCkge1xuICAgIGNvbnN0IGZmbGF0ZVN0cmVhbSA9IHRoaXMuemlwO1xuICAgIGNvbnN0IHRyYW5zZm9ybSA9IG5ldyBUcmFuc2Zvcm1TdHJlYW0oKTtcbiAgICBjb25zdCB3cml0ZXIgPSB0cmFuc2Zvcm0ud3JpdGFibGUuZ2V0V3JpdGVyKCk7XG4gICAgcmV0dXJuIG5ldyBUcmFuc2Zvcm1TdHJlYW0oe1xuICAgICAgc3RhcnQoY29udHJvbGxlcikge1xuICAgICAgICBmZmxhdGVTdHJlYW0ub25kYXRhID0gKGVycm9yLCBkYXRhLCBmaW5hbCkgPT4ge1xuICAgICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ2Vycm9yJywgZXJyb3IpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoZGF0YSk7XG4gICAgICAgICAgICBpZiAoZmluYWwpIHtcbiAgICAgICAgICAgICAgY29uc29sZS5sb2coJ2ZpbmFsJywgZmluYWwpO1xuICAgICAgICAgICAgICAvLyAgY29udHJvbGxlci50ZXJtaW5hdGUoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGZsdXNoKGNvbnRyb2xsZXIpIHtcbiAgICAgICAgY29uc29sZS5sb2coJ3Rlcm1pbmF0ZSBmZnN0cmVtJylcbiAgICAgICAgY29udHJvbGxlci50ZXJtaW5hdGUoKTtcbiAgICAgIH1cbiAgICB9KVxuXG4gIH1cbiAgLy9cblxuXG4gIGFzeW5jIHJlYWREaXJlY3RvcnkoZGlyLCBwYXJlbnQsIG9uY29tcGxldGUsIG9uZXJyb3IgPSBudWxsKSB7XG4gICAgY29uc29sZS5sb2coJ3JlYWQnLCBkaXIubmFtZSlcbiAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICBsZXQgZXJyb3JlZCA9IGZhbHNlO1xuICAgIGxldCBkaXJlbnRyaWVzID0gW10sXG4gICAgICBoYW5kbGVycyA9IFtdLFxuICAgICAgZmlsZXMgPSBbXTtcblxuICAgIGNvbnN0IG9uX2Vycm9yID0gb25lcnJvciA/IG9uZXJyb3IgOiAoZXJyKSA9PiB7XG4gICAgICBjb25zb2xlLmxvZygnb25fZXJyb3InLCBlcnIpXG4gICAgICBpZiAoIWVycm9yZWQpIHtcbiAgICAgICAgZXJyb3JlZCA9IHRydWU7XG5cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgY29uc3QgcmVhZGZpbGUgPSBhc3luYyBmdW5jdGlvbihmaWxlLCB6aXBwZWRzdHJlYW0pIHtcbiAgICAgIGNvbnN0IHJlYWRlciA9IGZpbGUuc3RyZWFtKCkuZ2V0UmVhZGVyKCk7XG4gICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgZG9uZSxcbiAgICAgICAgICB2YWx1ZVxuICAgICAgICB9ID0gYXdhaXQgcmVhZGVyLnJlYWQoKTtcbiAgICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgICBhd2FpdCB6aXBwZWRzdHJlYW0ucHVzaChuZXcgVWludDhBcnJheSgwKSwgdHJ1ZSk7XG4gICAgICAgICAgcmV0dXJuIGRvbmU7XG4gICAgICAgIH1cbiAgICAgICAgYXdhaXQgemlwcGVkc3RyZWFtLnB1c2godmFsdWUpO1xuICAgICAgfVxuXG4gICAgfTtcblxuICAgIC8vXG4gICAgY29uc3QgcHJvY2Vzc19maWxlID0gYXN5bmMgZnVuY3Rpb24oKSB7XG4gICAgICBjb25zdCBlbnRyeSA9IGZpbGVzLnNoaWZ0KCk7XG4gICAgICBjb25zdCBmaWxlcGF0aCA9IGVudHJ5LmZ1bGxQYXRoLnNsaWNlKDEpO1xuICAgICAgLy8gIGNvbnNvbGUubG9nKCdmaWxlYWRkPScgKyBzZWxmLm51bWZpbGVzLCBlbnRyeS5uYW1lKVxuICAgICAgY29uc3QgZXh0ID0gZmlsZXBhdGguc2xpY2UoZmlsZXBhdGgubGFzdEluZGV4T2YoJy4nKSArIDEpO1xuICAgICAgY29uc3QgemlwX2ZpbGUgPSBhc3luYyAoZmlsZXRvemlwKSA9PiB7XG4gICAgICAgIGNvbnN0IGlzY29tcHJlc3NlZCA9IGFscmVhZHlfY29tcHJlc3NlZC5oYXMoZXh0KTtcbiAgICAgICAgY29uc3QgemlwcGVkc3RyZWFtID0gaXNjb21wcmVzc2VkID9cbiAgICAgICAgICBuZXcgWmlwUGFzc1Rocm91Z2goZmlsZXBhdGgpIDpcbiAgICAgICAgICBmaWxldG96aXAuc2l6ZSA+IGxhcmdlZmlsZSA/XG4gICAgICAgICAgbmV3IEFzeW5jWmlwRGVmbGF0ZShmaWxlcGF0aCwge1xuICAgICAgICAgICAgbGV2ZWw6IDlcbiAgICAgICAgICB9KSA6IG5ldyBaaXBEZWZsYXRlKGZpbGVwYXRoLCB7XG4gICAgICAgICAgICBsZXZlbDogNlxuICAgICAgICAgIH0pO1xuICAgICAgICAvLyAgY29uc29sZS5sb2coJ3ppcHN0cicsIHppcHBlZHN0cmVhbSlcbiAgICAgICAgemlwcGVkc3RyZWFtLm9uZGF0YSA9IGFzeW5jIGZ1bmN0aW9uKGVyciwgZGF0LCBmaW5hbCkge1xuICAgICAgICAgIGlmIChlcnIpIGNvbnNvbGUubG9nKCdlcnIgYWRkIGNodW5rIHRvIHppcGZpbGUnICsgZGF0LCBlcnIpO1xuICAgICAgICAgIGVsc2UgaWYgKGZpbmFsKSB7XG5cbiAgICAgICAgICAgIGlmIChmaWxlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgY29uc29sZS5sb2coJ2ZpbGVzJywgZmlsZXMubGVuZ3RoKTtcbiAgICAgICAgICAgICAgYXdhaXQgcHJvY2Vzc19maWxlKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBjb25zb2xlLmxvZygnbGFzdGZpbGUnLCBkaXIubmFtZSk7XG4gICAgICAgICAgICAgIGF3YWl0IG9uX2NvbXBsZXRlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBhd2FpdCBzZWxmLnppcC5hZGQoemlwcGVkc3RyZWFtKTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHJlYWRmaWxlKGZpbGV0b3ppcCwgemlwcGVkc3RyZWFtKTtcbiAgICAgIH07XG4gICAgICBzZWxmLm51bWZpbGVzKys7XG4gICAgICBpZiAoc2VsZi5udW1maWxlcyA9PT0gMSkge1xuICAgICAgICBmZXRjaChzZWxmLm9wdGlvbnMudXJsLnJlcGxhY2UoJ215X2ZpbGVzJywgJ3N0cmVhbV9teV9maWxlcycpLCB7XG4gICAgICAgICAgbW9kZTogJ2NvcnMnLFxuICAgICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAgICAgY3JlZGVudGlhbHM6IFwiaW5jbHVkZVwiLFxuICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vemlwXCIsXG4gICAgICAgICAgfSxcbiAgICAgICAgICBib2R5OiBzZWxmLnppcFJlYWRhYmxlU3RyZWFtLnJlYWRhYmxlLFxuICAgICAgICAgIGR1cGxleDogJ2hhbGYnLFxuICAgICAgICB9KS50aGVuKChyZXNwb25zZSkgPT4ge1xuICAgICAgICAgIGNvbnNvbGUubG9nKCdyZXNwb25zZScsIHJlc3BvbnNlKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBhd2FpdCBlbnRyeS5maWxlKHppcF9maWxlKTtcblxuICAgIH07XG4gICAgLy9cblxuICAgIGNvbnN0IHByb2Nlc3NfZW50cmllcyA9IGZ1bmN0aW9uKCkge1xuICAgICAgY29uc3QgZW50cnkgPSBkaXJlbnRyaWVzLnNoaWZ0KCk7XG4gICAgICBpZiAoZW50cnkuaXNGaWxlKSB7XG4gICAgICAgIC8vY29uc29sZS5sb2coJ2ZpbGVsZWZ0ICoqKi0tLScgKyBkaXIubmFtZSwgZW50cnkubmFtZSk7XG4gICAgICAgIHNlbGYuY291bnRlcisrO1xuICAgICAgICBzZWxmLmNvdW50ZXJkaXNwbGF5LnRleHRDb250ZW50ID0gc2VsZi5jb3VudGVyO1xuICAgICAgICAvL2NvbnN0IGYgPSBlbnRyeS5nZXRBc0ZpbGUoKTtcbiAgICAgICAgZmlsZXMucHVzaChlbnRyeSk7XG4gICAgICAgIC8vICBhd2FpdCBwcm9jZXNzX2ZpbGUoZW50cnksIGVudHJ5LmZ1bGxQYXRoLnNsaWNlKDEpKTtcbiAgICAgICAgc2VsZi5jb3VudGVyLS07XG4gICAgICAgIHNlbGYuY291bnRlcmRpc3BsYXkudGV4dENvbnRlbnQgPSBzZWxmLmNvdW50ZXI7XG4gICAgICB9IGVsc2UgaWYgKGVudHJ5LmlzRGlyZWN0b3J5KSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdlbnRyeSBpcyBkaXInLCBlbnRyeSlcbiAgICAgICAgaGFuZGxlcnMucHVzaChlbnRyeSk7XG4gICAgICB9XG4gICAgICBpZiAoZGlyZW50cmllcy5sZW5ndGgpIHByb2Nlc3NfZW50cmllcygpO1xuXG4gICAgfVxuICAgIGNvbnN0IG9uX2NvbXBsZXRlID0gYXN5bmMgZnVuY3Rpb24oKSB7XG4gICAgICBmb3IgKGNvbnN0IGhhbmRsZXIgb2YgaGFuZGxlcnMpIHtcbiAgICAgICAgY29uc29sZS5sb2coaGFuZGxlcik7XG4gICAgICAgIGF3YWl0IHNlbGYucmVhZERpcmVjdG9yeShoYW5kbGVyLCBkaXIsIGFzeW5jIGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGNvbnNvbGUubG9nKCdpZGlyJywgaGFuZGxlci5uYW1lKTtcbiAgICAgICAgICBpZiAoZmlsZXMubGVuZ3RoKSBhd2FpdCBwcm9jZXNzX2ZpbGUoKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICB9XG4gICAgY29uc3QgcmVhZGVyID0gZGlyLmNyZWF0ZVJlYWRlcigpO1xuICAgIGNvbnN0IG9uX3JlYWQgPSBhc3luYyBmdW5jdGlvbihlbnRzKSB7XG4gICAgICBpZiAoZW50cy5sZW5ndGggJiYgIWVycm9yZWQpIHtcbiAgICAgICAgZGlyZW50cmllcyA9IFsuLi5kaXJlbnRyaWVzLCAuLi5lbnRzXTtcbiAgICAgICAgYXdhaXQgcmVhZGVyLnJlYWRFbnRyaWVzKG9uX3JlYWQsIG9uX2Vycm9yKTtcbiAgICAgIH0gZWxzZSBpZiAoIWVycm9yZWQpIHtcbiAgICAgICAgcHJvY2Vzc19lbnRyaWVzKCk7XG4gICAgICAgIGNvbnNvbGUubG9nKCd0aGVlbmQtLS0tLS0tLS0tLS0tLS0tLS0tICcgKyBkaXIubmFtZSwgZGlyZW50cmllcy5sZW5ndGgpXG4gICAgICAgIGF3YWl0IG9uX2NvbXBsZXRlKCk7XG5cblxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS5sb2coJ3RyZWF0IGVycm9yIHJlYWRkaXInKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBhd2FpdCByZWFkZXIucmVhZEVudHJpZXMob25fcmVhZCwgb25fZXJyb3IpO1xuXG4gICAgY29uc29sZS5sb2coJ2VuZGRpcicgKyBkaXIubmFtZSwgZGlyZW50cmllcy5sZW5ndGgpXG5cbiAgfVxuXG4gIGNvbXByZXNzaW9uTGV2ZWwobmFtZSkge1xuICAgIGlmICghbmFtZSkge1xuXG4gICAgICByZXR1cm4gLTE7XG4gICAgfVxuICAgIGxldCBleHQgPSBuYW1lLnNwbGl0KCcuJyk7XG4gICAgZXh0ID0gKGV4dC5sZW5ndGggPiAxKSA/IGV4dFtleHQubGVuZ3RoIC0gMV0gOiBleHRbMF07XG4gICAgcmV0dXJuIChhbHJlYWR5X2NvbXByZXNzZWQuZmluZChleCA9PiAoZXggPT09IGV4dCkpKSA/IDIgOiB0aGlzLm9wdGlvbnMubGV2ZWw7XG4gIH1cblxuICBhc3luYyBzZW5kWmlwKCkge1xuICAgIC8vICBjb25zdCBmaWxlc3RyZWFtID0gbmV3IFdyaXRhYmxlU3RyZWFtKCk7XG4gICAgLy8gIGNvbnN0IHdyaXRlciA9IGZpbGVzdHJlYW0uZ2V0V3JpdGVyKCk7XG4gICAgLy9cblxuICAgIC8vXG5cblxuICAgIC8qICBmZXRjaCh0aGlzLm9wdGlvbnMudXJsLnJlcGxhY2UoJ215X2ZpbGVzJywgJ3N0cmVhbV9teV9maWxlcycpLCB7XG4gICAgICAgIG1vZGU6ICdjb3JzJyxcbiAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgICAgY3JlZGVudGlhbHM6IFwiaW5jbHVkZVwiLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJ0ZXh0L3BsYWluXCIsXG4gICAgICAgIH0sXG4gICAgICAgIGJvZHk6IHRoaXMuemlwUmVhZGFibGVTdHJlYW0sXG4gICAgICAgIGR1cGxleDogJ2hhbGYnLFxuICAgICAgfSk7Ki9cbiAgICAvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbiAgICAvKndlYnRyYW5zcG9ydFxuICAgICAgY29uc3QgdHJhbnNwb3J0ID0gbmV3IFdlYlRyYW5zcG9ydCh0aGlzLm9wdGlvbnMudXJsKTtcblxuICAgICAgLy8gT3B0aW9uYWxseSwgc2V0IHVwIGZ1bmN0aW9ucyB0byByZXNwb25kIHRvXG4gICAgICAvLyB0aGUgY29ubmVjdGlvbiBjbG9zaW5nOlxuICAgICAgdHJhbnNwb3J0LmNsb3NlZC50aGVuKCgpID0+IHtcbiAgICAgICAgY29uc29sZS5sb2coYFRoZSBIVFRQLzMgY29ubmVjdGlvbiB0byAke3VybH0gY2xvc2VkIGdyYWNlZnVsbHkuYCk7XG4gICAgICB9KS5jYXRjaCgoZXJyb3IpID0+IHtcbiAgICAgICAgY29uc29sZS5lcnJvcihgVGhlIEhUVFAvMyBjb25uZWN0aW9uIHRvICR7dXJsfSBjbG9zZWQgZHVlIHRvICR7ZXJyb3J9LmApO1xuICAgICAgfSk7XG5cbiAgICAgIC8vIE9uY2UgLnJlYWR5IGZ1bGZpbGxzLCB0aGUgY29ubmVjdGlvbiBjYW4gYmUgdXNlZC5cbiAgICAgIGF3YWl0IHRyYW5zcG9ydC5yZWFkeTtcbiAgICAgIGNvbnN0IHN0cmVhbXNlbmQgPSBhd2FpdCB0cmFuc3BvcnQuY3JlYXRlVW5pZGlyZWN0aW9uYWxTdHJlYW0oKTtcbiAgICAgIGNvbnN0IHdyaXRlciA9IHN0cmVhbXNlbmQud3JpdGFibGUuZ2V0V3JpdGVyKCk7XG4gICAgICBjb25zdCBzdHJlYW10ZXN0ID0gbmV3IFJlYWRhYmxlU3RyZWFtKHtcbiAgICAgICAgYXN5bmMgc3RhcnQoY29udHJvbGxlcikge1xuICAgICAgICAgIGF3YWl0IHdhaXQoMTAwMCk7XG4gICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKCdUaGlzICcpO1xuICAgICAgICAgIGF3YWl0IHdhaXQoMTAwMCk7XG4gICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKCdpcyAnKTtcbiAgICAgICAgICBhd2FpdCB3YWl0KDEwMDApO1xuICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSgnYSAnKTtcbiAgICAgICAgICBhd2FpdCB3YWl0KDEwMDApO1xuICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSgnc2xvdyAnKTtcbiAgICAgICAgICBhd2FpdCB3YWl0KDEwMDApO1xuICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSgncmVxdWVzdC4nKTtcbiAgICAgICAgICBjb250cm9sbGVyLmNsb3NlKCk7XG4gICAgICAgIH0sXG4gICAgICB9KS5waXBlVG8od3JpdGVyKTtcblxuICAgICovXG5cblxuXG5cbiAgfVxuXG5cbn0iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/modules/js-upload.js\n")}}]);