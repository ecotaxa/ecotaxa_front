/*! For license information please see src_modules_files_js-dirtozip_js.js.LICENSE.txt */
"use strict";(self.webpackChunk=self.webpackChunk||[]).push([["src_modules_files_js-dirtozip_js"],{"./src/modules/files/js-dirtozip.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   JsDirToZip: () => (/* binding */ JsDirToZip)\n/* harmony export */ });\n/* harmony import */ var _modules_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../modules/utils.js */ \"./src/modules/utils.js\");\n/* harmony import */ var fflate__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! fflate */ \"./node_modules/fflate/esm/browser.js\");\n\n\n\n\nconst already_compressed = new Set([\n  'zip', 'gz', 'png', 'jpg', 'jpeg', 'pdf', 'doc', 'docx', 'ppt', 'pptx',\n  'xls', 'xlsx', 'heic', 'heif', '7z', 'bz2', 'rar', 'gif', 'webp', 'webm',\n  'mp4', 'mov', 'mp3', 'aifc'\n]);\nconst accept = '.tsv,.png,.jpg, .jpeg,.zip,.gz,.7z,.bz2';\nlet instance = null;\nconst MAXSIZE = 1073741824; ////maxfilesize: 1073741824,\nclass JsDirToZip {\n  _events = {};\n  eventnames = {\n    ready: 'ready',\n    endzip: 'endzip',\n    complete: 'complete',\n    gzip: 'gzipfile',\n    sendfile: 'sendfile',\n    bigfile: 'bigfile',\n    terminate: 'terminate',\n    pending: 'pending',\n    getfile: 'getzipfile',\n    counter: 'counter',\n    message: 'message',\n    error: 'error'\n  }\n  zip = null;\n  zipname = null;\n  filestream = null;\n  streamhandle = null;\n  gzipped = null;\n  sizetozip = 0;\n  part = 0;\n  continue = null;\n  constructor(options = {}) {\n    if (instance) return instance;\n    const defaultOptions = {\n      uploadurl: '/gui/files/upload',\n      largefile: 4194304,\n      accept: accept.split(',')\n    }\n    this.options = { ...defaultOptions,\n      ...options\n    };\n    console.log('thisopts', this.options)\n\n    this.init();\n\n    instance = this;\n    return instance;\n  }\n  init() {\n    (0,_modules_utils_js__WEBPACK_IMPORTED_MODULE_0__.add_custom_events)(this);\n    this.initStorage();\n    this.on(this.eventnames.ready, () => {\n      //this.initZip();\n      console.log('ready')\n    });\n  }\n  reset() {\n    this.zip = null;\n    this.zipname = null;\n    this.filestream = null;\n    this.streamhandle = null;\n    this.gzipped = null;\n    this.sizetozip = 0;\n    this.part = 0;\n    this.continue = null;\n    this.initStorage();\n  }\n  initZip() {\n    const self = this;\n    this.pos = 0;\n    this.sizetozip = 0;\n    this.zip = new fflate__WEBPACK_IMPORTED_MODULE_1__.Zip(\n      (error, chunk, final) => {\n        if (error) {\n          console.log('error', error);\n          return false;\n        } else {\n          self.streamhandle.write(chunk, {\n            at: self.pos\n          });\n          self.pos += chunk.length;\n          if (final) {\n            self.streamhandle.close();\n            console.log('final-----------------------------*******************************-', this.part);\n\n          }\n\n        }\n      });\n    if (this.continue) this.continue();\n    else {\n      // events\n      this.on(this.eventnames.endzip, (e) => {\n\n        if (!e.bigfile && this.zip) {\n          console.log('zipend', this.zip)\n          this.zip.end();\n        } else if (e.bigfile && this.gzipped.name) console.log('-------------------------gzipped end ', this.gzipped)\n        const message = {\n          name: this.eventnames.sendfile\n        };\n        if (e.part) {\n          message[\"part\"] = e.part;\n        } else this.part = 0;\n        if (e.bigfile) message[\"bigfile\"] = e.bigfile;\n        console.log('endzip%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%', e)\n        this.emit(this.eventnames.complete, message);\n      });\n\n      this.on(this.eventnames.sendfile, async (e) => {\n        let file = (e.bigfile) ? this.gzipped : await this.getFile();\n        console.log('sendfile', file)\n        /*  if (e.bigfile) this.sendChunk((e.path ? e.path : ''));\n          else */\n        this.sendZipFile(file, (e.path ? e.path : ''), null, (e.bigfile ? e.bigfile : false));\n      });\n      this.on(this.eventnames.bigfile, (e) => {\n        this.sendChunk((e.path ? e.path : ''));\n      });\n    }\n  }\n  async initStorage() {\n    if (navigator && navigator.storage && navigator.storage.estimate) {\n      await this.cleanStorage();\n      this.emit(this.eventnames.ready);\n      navigator.storage.estimate().then((quota) => {\n        const percentageUsed = (quota.usage / quota.quota) * 100;\n        const remaining = quota.quota - quota.usage;\n        this.emit(this.eventnames.message, {\n          name: \"console\",\n          message: \"You can write up to \" + remaining + \" more bytes.\"\n        });\n        this.emit(this.eventnames.message, {\n          name: \"console\",\n          message: \"you've used \" + percentageUsed + \"% of the available storage.\"\n        });\n      });\n    } else this.emit(this.eventnames.message, {\n      name: \"error\",\n      message: \"no navigator storage\"\n    });\n  }\n  async createLocalStream(name, accept = {\n    'application/zip': ['.zip'],\n  }) {\n    const root = await navigator.storage.getDirectory();\n    const opts = {\n      types: [{\n        description: 'Temp file',\n        accept: accept,\n      }, ],\n      create: true\n    };\n    const filestream = await root.getFileHandle(name, opts);\n    const streamhandle = await filestream.createWritable();\n    return {\n      filestream,\n      streamhandle\n    };\n  }\n\n  async scanHandle(dir, options = {}) {\n    console.log('this.zip', this.zip)\n    if (this.zip === null) {\n      const type = (options && options.type) ? options.type : '.zip';\n      this.zipname = ((options.zipname) ? options.zipname : dir.name) + type;\n      //\n\n      const {\n        filestream,\n        streamhandle\n      } = await this.createLocalStream(this.zipname);\n      console.log('streamhandle', streamhandle)\n      this.filestream = filestream;\n      this.streamhandle = streamhandle;\n      let size = 0;\n      this.part = 0;\n      this.initZip();\n      console\n      const zip = this.zip;\n      if (!this.jsScanDir) {\n        const {\n          JsScanDir\n        } = await __webpack_require__.e(/*! import() */ \"src_modules_files_js-scandir_js\").then(__webpack_require__.bind(__webpack_require__, /*! ../files/js-scandir.js */ \"./src/modules/files/js-scandir.js\"));\n        this.jsScanDir = new JsScanDir();\n      }\n      this.jsScanDir.processFile = (entry, callback) => {\n        this.processFile(entry, callback);\n      };\n      await this.jsScanDir.readDirectory(dir, () => {\n        this.emit(this.eventnames.complete, {\n          name: this.eventnames.endzip\n        });\n\n      });\n    }\n  }\n  async sendBigFile(file, callback, filepath) {\n    console.log('sendbigfilepath', filepath)\n    /*let filepath = file.webkitRelativePath;\n    filepath = (filepath === '') ? dirname + '/' + file.name : filepath;*/\n    const ext = file.name.slice(file.name.lastIndexOf('.') + 1);\n    if (already_compressed.has(ext)) {\n      this.gzipped = file;\n      this.emit(this.eventnames.counter, {\n        name: 'zip',\n        filepath: filepath,\n        size: file.size\n      });\n      this.emit(this.eventnames.complete, {\n        name: this.eventnames.bigfile,\n        bigfile: filepath\n      });\n    } else {\n      this.emit(this.eventnames.gzip, {\n        name: this.eventnames.gzip,\n        bigfile: filepath,\n        size: file.size\n      });\n      let zipname = file.name.split(ext);\n      zipname.pop();\n      zipname = zipname.join(ext) + 'gz';\n      console.log('bigfile ext=' + ext, zipname)\n      const {\n        filestream,\n        streamhandle\n      } = await this.createLocalStream(zipname, {\n        'application/gzip': ['.gz'],\n      });\n      let pos = 0;\n      const selfi = this;\n      const gzipped = new fflate__WEBPACK_IMPORTED_MODULE_1__.Gzip({\n        level: 9,\n        filename: file.name\n      });\n      gzipped.ondata = (data, final) => {\n        if (final) {\n          console.log('final BIGFILE%%%%%%%%%%%%%%%%%%%%' + selfi.eventnames.bigfile, filepath)\n          selfi.emit(selfi.eventnames.counter, {\n            name: 'zip',\n            filepath: filepath,\n            size: file.size\n          });\n          selfi.gzipped = streamhandle;\n          console.log('big file *******************', this.gzipped);\n          selfi.emit(selfi.eventnames.complete, {\n            name: selfi.eventnames.bigfile,\n            bigfile: filepath\n\n          });\n\n          console.log('callbackbig', callback)\n          //  gzipped.terminate();\n          //  streamhandle.close();\n\n\n        } else {\n\n          streamhandle.write(data, {\n            at: pos\n          });\n          pos += data.length;\n        }\n      };\n      await this.readFile(file, filepath, gzipped, callback);\n    }\n\n\n  }\n  async partZip() {\n    this.part += 1;\n    this.emit(this.eventnames.complete, {\n      name: this.eventnames.endzip,\n      part: this.part\n    });\n  }\n  async readFile(file, filepath, zippedstream, callback = null) {\n    const reader = file.stream().getReader();\n    while (true) {\n      const {\n        done,\n        value\n      } = await reader.read();\n      if (done) {\n        zippedstream.push(new Uint8Array(0), true);\n        this.emit(this.eventnames.counter, {\n          name: 'zip',\n          filepath: filepath,\n          size: (zippedstream.size) ? zippedstream.size : file.size\n        });\n        if (zippedstream.terminate) zippedstream.terminate();\n        if (callback) callback();\n        return done;\n      }\n      zippedstream.push(value);\n    }\n  }\n  async zipStream(file, filepath, callback) {\n    const ext = filepath.slice(filepath.lastIndexOf('.') + 1);\n    const iscompressed = already_compressed.has(ext);\n    const zippedstream = (iscompressed) ? new fflate__WEBPACK_IMPORTED_MODULE_1__.ZipPassThrough(filepath) : file.size > this.options.largefile ?\n      new fflate__WEBPACK_IMPORTED_MODULE_1__.AsyncZipDeflate(filepath, {\n        level: 9\n      }) : new fflate__WEBPACK_IMPORTED_MODULE_1__.ZipDeflate(filepath, {\n        level: 6\n      });\n    this.zip.add(zippedstream);\n    await this.readFile(file, filepath, zippedstream, callback);\n  }\n  async processFile(entry, callback = null) {\n    const self = this;\n    const filepath = entry.fullPath;\n    const ext = filepath.slice(filepath.lastIndexOf('.') + 1);\n    if (this.options.accept.includes(ext)) {\n      console.log('reject', filepath);\n      return;\n    }\n    if (entry.isDirectory) {\n      //  console.log('zipdir', callback)\n      if (callback) callback();\n    } else {\n      entry.file(async file => {\n        this.emit(this.eventnames.counter, {\n          name: 'scan',\n          filepath: filepath,\n          size: file.size\n        });\n        this.continue = null;\n        // check file size > max post size\n        if (file.size >= MAXSIZE) {\n          this.sendBigFile(file, callback, filepath);\n        } else {\n          // check zip file size > total zip size\n          this.sizetozip += file.size;\n          if (this.sizetozip >= MAXSIZE) {\n            this.continue = async () => {\n              await this.zipStream(file, filepath, callback);\n            }\n            this.partZip();\n          } else {\n            await this.zipStream(file, filepath, callback);\n          }\n        }\n      });\n\n    }\n  }\n  onError() {\n    this.cleanStorage();\n    this.emit(this.eventnames.error, {\n      name: \"reload\"\n    });\n  }\n  async cleanStorage(entry = null) {\n    entry = (entry) ? entry : await navigator.storage.getDirectory();\n    for await (const [key, value] of entry.entries()) {\n      console.log('keyval', {\n        key,\n        value\n      });\n      await entry.removeEntry(key);\n    }\n\n  }\n\n  async endFetch(message, clean = false) {\n    message.name = this.eventnames.terminate;\n    if (message.hasOwnProperty(\"bigfile\") && message.bigfile !== \"\" &&\n      message.bigfile !== false && message.bigfile !== null) {\n      message[\"bigfile\"] = this.gzipped.name;\n      this.gzipped = null;\n    } else if (this.continue) {\n      console.log('continue')\n      this.streamhandle = await this.filestream.createWritable();\n      this.initZip();\n    } else if (clean === true) await this.cleanStorage();\n    this.emit(this.eventnames.complete, message);\n    console.log('continue', this.continue)\n  }\n\n  async sendChunk(path, start = 0, chunknum = 0, chunksize = MAXSIZE) {\n    const file = (this.gzipped.kind) ? await this.gzipped.getFile(): file;\n    path = path.split('/');\n    path.pop();\n    path = path.join('/');\n    const end = Math.min(start + chunksize, file.size);\n    if (end === file.size) {\n\n      this.sendZipFile(file, path, null, true);\n    } else {\n      const partfile = file.slice(start, end);\n      partfile.name = chunknum + '_' + file.name;\n      this.sendZipfile(partfile, path, () => {\n        start += end;\n        chunknum++;\n\n        if (start <= file.size) this.sendChunk(path, start, chunknum, chunksize);\n      }, true)\n    }\n    return chunknum;\n  }\n  async getFile() {\n    const file = await this.filestream.getFile();\n    return file;\n  }\n  async sendZipFile(file, path, callbackchunk = null, isbigfile = false) {\n    const message = (isbigfile) ? {\n      bigfile: file.name\n    } : {};\n    this.emit(this.eventnames.pending, message);\n    console.log('file', file)\n    console.log('callbackchunk---sendzip', callbackchunk)\n    const formdata = new FormData();\n    formdata.append('tag', 'ecotaxa_import');\n    formdata.append('path', path + file.name);\n    formdata.append('file', file, file.name);\n    if (this.part) formdata.append('part', this.part);\n    else if (callbackchunk !== null) formdata.append('ischunk', true);\n    fetch(this.options.uploadurl, {\n      //  mode: 'cors',\n      method: \"POST\",\n      credentials: \"include\",\n      body: formdata,\n    }).then(async (response) => {\n      console.log('response----------------------', response);\n      console.log('callbackchunk-------------------------------', callbackchunk)\n      if (callbackchunk !== null) {\n        callbackchunk();\n      } else this.endFetch(message);\n    });\n  }\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUNBLDhDQUE4QyxrREFBYztBQUM1RCxVQUFVLG1EQUFlO0FBQ3pCO0FBQ0EsT0FBTyxRQUFRLDhDQUFVO0FBQ3pCO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUixLQUFLO0FBQ0w7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy9tb2R1bGVzL2ZpbGVzL2pzLWRpcnRvemlwLmpzPzg1MzgiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuaW1wb3J0IHtcbiAgYWRkX2N1c3RvbV9ldmVudHMsXG4gIGZldGNoU2V0dGluZ3Ncbn0gZnJvbSAnLi4vLi4vbW9kdWxlcy91dGlscy5qcyc7XG5cbmltcG9ydCB7XG4gIEd6aXAsXG4gIFppcCxcbiAgQXN5bmNaaXBEZWZsYXRlLFxuICBaaXBQYXNzVGhyb3VnaCxcbiAgWmlwRGVmbGF0ZSxcbn0gZnJvbSAnZmZsYXRlJztcbmNvbnN0IGFscmVhZHlfY29tcHJlc3NlZCA9IG5ldyBTZXQoW1xuICAnemlwJywgJ2d6JywgJ3BuZycsICdqcGcnLCAnanBlZycsICdwZGYnLCAnZG9jJywgJ2RvY3gnLCAncHB0JywgJ3BwdHgnLFxuICAneGxzJywgJ3hsc3gnLCAnaGVpYycsICdoZWlmJywgJzd6JywgJ2J6MicsICdyYXInLCAnZ2lmJywgJ3dlYnAnLCAnd2VibScsXG4gICdtcDQnLCAnbW92JywgJ21wMycsICdhaWZjJ1xuXSk7XG5jb25zdCBhY2NlcHQgPSAnLnRzdiwucG5nLC5qcGcsIC5qcGVnLC56aXAsLmd6LC43eiwuYnoyJztcbmxldCBpbnN0YW5jZSA9IG51bGw7XG5jb25zdCBNQVhTSVpFID0gMTA3Mzc0MTgyNDsgLy8vL21heGZpbGVzaXplOiAxMDczNzQxODI0LFxuZXhwb3J0IGNsYXNzIEpzRGlyVG9aaXAge1xuICBfZXZlbnRzID0ge307XG4gIGV2ZW50bmFtZXMgPSB7XG4gICAgcmVhZHk6ICdyZWFkeScsXG4gICAgZW5kemlwOiAnZW5kemlwJyxcbiAgICBjb21wbGV0ZTogJ2NvbXBsZXRlJyxcbiAgICBnemlwOiAnZ3ppcGZpbGUnLFxuICAgIHNlbmRmaWxlOiAnc2VuZGZpbGUnLFxuICAgIGJpZ2ZpbGU6ICdiaWdmaWxlJyxcbiAgICB0ZXJtaW5hdGU6ICd0ZXJtaW5hdGUnLFxuICAgIHBlbmRpbmc6ICdwZW5kaW5nJyxcbiAgICBnZXRmaWxlOiAnZ2V0emlwZmlsZScsXG4gICAgY291bnRlcjogJ2NvdW50ZXInLFxuICAgIG1lc3NhZ2U6ICdtZXNzYWdlJyxcbiAgICBlcnJvcjogJ2Vycm9yJ1xuICB9XG4gIHppcCA9IG51bGw7XG4gIHppcG5hbWUgPSBudWxsO1xuICBmaWxlc3RyZWFtID0gbnVsbDtcbiAgc3RyZWFtaGFuZGxlID0gbnVsbDtcbiAgZ3ppcHBlZCA9IG51bGw7XG4gIHNpemV0b3ppcCA9IDA7XG4gIHBhcnQgPSAwO1xuICBjb250aW51ZSA9IG51bGw7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMgPSB7fSkge1xuICAgIGlmIChpbnN0YW5jZSkgcmV0dXJuIGluc3RhbmNlO1xuICAgIGNvbnN0IGRlZmF1bHRPcHRpb25zID0ge1xuICAgICAgdXBsb2FkdXJsOiAnL2d1aS9maWxlcy91cGxvYWQnLFxuICAgICAgbGFyZ2VmaWxlOiA0MTk0MzA0LFxuICAgICAgYWNjZXB0OiBhY2NlcHQuc3BsaXQoJywnKVxuICAgIH1cbiAgICB0aGlzLm9wdGlvbnMgPSB7IC4uLmRlZmF1bHRPcHRpb25zLFxuICAgICAgLi4ub3B0aW9uc1xuICAgIH07XG4gICAgY29uc29sZS5sb2coJ3RoaXNvcHRzJywgdGhpcy5vcHRpb25zKVxuXG4gICAgdGhpcy5pbml0KCk7XG5cbiAgICBpbnN0YW5jZSA9IHRoaXM7XG4gICAgcmV0dXJuIGluc3RhbmNlO1xuICB9XG4gIGluaXQoKSB7XG4gICAgYWRkX2N1c3RvbV9ldmVudHModGhpcyk7XG4gICAgdGhpcy5pbml0U3RvcmFnZSgpO1xuICAgIHRoaXMub24odGhpcy5ldmVudG5hbWVzLnJlYWR5LCAoKSA9PiB7XG4gICAgICAvL3RoaXMuaW5pdFppcCgpO1xuICAgICAgY29uc29sZS5sb2coJ3JlYWR5JylcbiAgICB9KTtcbiAgfVxuICByZXNldCgpIHtcbiAgICB0aGlzLnppcCA9IG51bGw7XG4gICAgdGhpcy56aXBuYW1lID0gbnVsbDtcbiAgICB0aGlzLmZpbGVzdHJlYW0gPSBudWxsO1xuICAgIHRoaXMuc3RyZWFtaGFuZGxlID0gbnVsbDtcbiAgICB0aGlzLmd6aXBwZWQgPSBudWxsO1xuICAgIHRoaXMuc2l6ZXRvemlwID0gMDtcbiAgICB0aGlzLnBhcnQgPSAwO1xuICAgIHRoaXMuY29udGludWUgPSBudWxsO1xuICAgIHRoaXMuaW5pdFN0b3JhZ2UoKTtcbiAgfVxuICBpbml0WmlwKCkge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgIHRoaXMucG9zID0gMDtcbiAgICB0aGlzLnNpemV0b3ppcCA9IDA7XG4gICAgdGhpcy56aXAgPSBuZXcgWmlwKFxuICAgICAgKGVycm9yLCBjaHVuaywgZmluYWwpID0+IHtcbiAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgY29uc29sZS5sb2coJ2Vycm9yJywgZXJyb3IpO1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzZWxmLnN0cmVhbWhhbmRsZS53cml0ZShjaHVuaywge1xuICAgICAgICAgICAgYXQ6IHNlbGYucG9zXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgc2VsZi5wb3MgKz0gY2h1bmsubGVuZ3RoO1xuICAgICAgICAgIGlmIChmaW5hbCkge1xuICAgICAgICAgICAgc2VsZi5zdHJlYW1oYW5kbGUuY2xvc2UoKTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdmaW5hbC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi0nLCB0aGlzLnBhcnQpO1xuXG4gICAgICAgICAgfVxuXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIGlmICh0aGlzLmNvbnRpbnVlKSB0aGlzLmNvbnRpbnVlKCk7XG4gICAgZWxzZSB7XG4gICAgICAvLyBldmVudHNcbiAgICAgIHRoaXMub24odGhpcy5ldmVudG5hbWVzLmVuZHppcCwgKGUpID0+IHtcblxuICAgICAgICBpZiAoIWUuYmlnZmlsZSAmJiB0aGlzLnppcCkge1xuICAgICAgICAgIGNvbnNvbGUubG9nKCd6aXBlbmQnLCB0aGlzLnppcClcbiAgICAgICAgICB0aGlzLnppcC5lbmQoKTtcbiAgICAgICAgfSBlbHNlIGlmIChlLmJpZ2ZpbGUgJiYgdGhpcy5nemlwcGVkLm5hbWUpIGNvbnNvbGUubG9nKCctLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tZ3ppcHBlZCBlbmQgJywgdGhpcy5nemlwcGVkKVxuICAgICAgICBjb25zdCBtZXNzYWdlID0ge1xuICAgICAgICAgIG5hbWU6IHRoaXMuZXZlbnRuYW1lcy5zZW5kZmlsZVxuICAgICAgICB9O1xuICAgICAgICBpZiAoZS5wYXJ0KSB7XG4gICAgICAgICAgbWVzc2FnZVtcInBhcnRcIl0gPSBlLnBhcnQ7XG4gICAgICAgIH0gZWxzZSB0aGlzLnBhcnQgPSAwO1xuICAgICAgICBpZiAoZS5iaWdmaWxlKSBtZXNzYWdlW1wiYmlnZmlsZVwiXSA9IGUuYmlnZmlsZTtcbiAgICAgICAgY29uc29sZS5sb2coJ2VuZHppcCUlJSUlJSUlJSUlJSUlJSUlJSUlJSUlJSUlJSUlJSUlJSUnLCBlKVxuICAgICAgICB0aGlzLmVtaXQodGhpcy5ldmVudG5hbWVzLmNvbXBsZXRlLCBtZXNzYWdlKTtcbiAgICAgIH0pO1xuXG4gICAgICB0aGlzLm9uKHRoaXMuZXZlbnRuYW1lcy5zZW5kZmlsZSwgYXN5bmMgKGUpID0+IHtcbiAgICAgICAgbGV0IGZpbGUgPSAoZS5iaWdmaWxlKSA/IHRoaXMuZ3ppcHBlZCA6IGF3YWl0IHRoaXMuZ2V0RmlsZSgpO1xuICAgICAgICBjb25zb2xlLmxvZygnc2VuZGZpbGUnLCBmaWxlKVxuICAgICAgICAvKiAgaWYgKGUuYmlnZmlsZSkgdGhpcy5zZW5kQ2h1bmsoKGUucGF0aCA/IGUucGF0aCA6ICcnKSk7XG4gICAgICAgICAgZWxzZSAqL1xuICAgICAgICB0aGlzLnNlbmRaaXBGaWxlKGZpbGUsIChlLnBhdGggPyBlLnBhdGggOiAnJyksIG51bGwsIChlLmJpZ2ZpbGUgPyBlLmJpZ2ZpbGUgOiBmYWxzZSkpO1xuICAgICAgfSk7XG4gICAgICB0aGlzLm9uKHRoaXMuZXZlbnRuYW1lcy5iaWdmaWxlLCAoZSkgPT4ge1xuICAgICAgICB0aGlzLnNlbmRDaHVuaygoZS5wYXRoID8gZS5wYXRoIDogJycpKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBhc3luYyBpbml0U3RvcmFnZSgpIHtcbiAgICBpZiAobmF2aWdhdG9yICYmIG5hdmlnYXRvci5zdG9yYWdlICYmIG5hdmlnYXRvci5zdG9yYWdlLmVzdGltYXRlKSB7XG4gICAgICBhd2FpdCB0aGlzLmNsZWFuU3RvcmFnZSgpO1xuICAgICAgdGhpcy5lbWl0KHRoaXMuZXZlbnRuYW1lcy5yZWFkeSk7XG4gICAgICBuYXZpZ2F0b3Iuc3RvcmFnZS5lc3RpbWF0ZSgpLnRoZW4oKHF1b3RhKSA9PiB7XG4gICAgICAgIGNvbnN0IHBlcmNlbnRhZ2VVc2VkID0gKHF1b3RhLnVzYWdlIC8gcXVvdGEucXVvdGEpICogMTAwO1xuICAgICAgICBjb25zdCByZW1haW5pbmcgPSBxdW90YS5xdW90YSAtIHF1b3RhLnVzYWdlO1xuICAgICAgICB0aGlzLmVtaXQodGhpcy5ldmVudG5hbWVzLm1lc3NhZ2UsIHtcbiAgICAgICAgICBuYW1lOiBcImNvbnNvbGVcIixcbiAgICAgICAgICBtZXNzYWdlOiBcIllvdSBjYW4gd3JpdGUgdXAgdG8gXCIgKyByZW1haW5pbmcgKyBcIiBtb3JlIGJ5dGVzLlwiXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmVtaXQodGhpcy5ldmVudG5hbWVzLm1lc3NhZ2UsIHtcbiAgICAgICAgICBuYW1lOiBcImNvbnNvbGVcIixcbiAgICAgICAgICBtZXNzYWdlOiBcInlvdSd2ZSB1c2VkIFwiICsgcGVyY2VudGFnZVVzZWQgKyBcIiUgb2YgdGhlIGF2YWlsYWJsZSBzdG9yYWdlLlwiXG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHRoaXMuZW1pdCh0aGlzLmV2ZW50bmFtZXMubWVzc2FnZSwge1xuICAgICAgbmFtZTogXCJlcnJvclwiLFxuICAgICAgbWVzc2FnZTogXCJubyBuYXZpZ2F0b3Igc3RvcmFnZVwiXG4gICAgfSk7XG4gIH1cbiAgYXN5bmMgY3JlYXRlTG9jYWxTdHJlYW0obmFtZSwgYWNjZXB0ID0ge1xuICAgICdhcHBsaWNhdGlvbi96aXAnOiBbJy56aXAnXSxcbiAgfSkge1xuICAgIGNvbnN0IHJvb3QgPSBhd2FpdCBuYXZpZ2F0b3Iuc3RvcmFnZS5nZXREaXJlY3RvcnkoKTtcbiAgICBjb25zdCBvcHRzID0ge1xuICAgICAgdHlwZXM6IFt7XG4gICAgICAgIGRlc2NyaXB0aW9uOiAnVGVtcCBmaWxlJyxcbiAgICAgICAgYWNjZXB0OiBhY2NlcHQsXG4gICAgICB9LCBdLFxuICAgICAgY3JlYXRlOiB0cnVlXG4gICAgfTtcbiAgICBjb25zdCBmaWxlc3RyZWFtID0gYXdhaXQgcm9vdC5nZXRGaWxlSGFuZGxlKG5hbWUsIG9wdHMpO1xuICAgIGNvbnN0IHN0cmVhbWhhbmRsZSA9IGF3YWl0IGZpbGVzdHJlYW0uY3JlYXRlV3JpdGFibGUoKTtcbiAgICByZXR1cm4ge1xuICAgICAgZmlsZXN0cmVhbSxcbiAgICAgIHN0cmVhbWhhbmRsZVxuICAgIH07XG4gIH1cblxuICBhc3luYyBzY2FuSGFuZGxlKGRpciwgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc29sZS5sb2coJ3RoaXMuemlwJywgdGhpcy56aXApXG4gICAgaWYgKHRoaXMuemlwID09PSBudWxsKSB7XG4gICAgICBjb25zdCB0eXBlID0gKG9wdGlvbnMgJiYgb3B0aW9ucy50eXBlKSA/IG9wdGlvbnMudHlwZSA6ICcuemlwJztcbiAgICAgIHRoaXMuemlwbmFtZSA9ICgob3B0aW9ucy56aXBuYW1lKSA/IG9wdGlvbnMuemlwbmFtZSA6IGRpci5uYW1lKSArIHR5cGU7XG4gICAgICAvL1xuXG4gICAgICBjb25zdCB7XG4gICAgICAgIGZpbGVzdHJlYW0sXG4gICAgICAgIHN0cmVhbWhhbmRsZVxuICAgICAgfSA9IGF3YWl0IHRoaXMuY3JlYXRlTG9jYWxTdHJlYW0odGhpcy56aXBuYW1lKTtcbiAgICAgIGNvbnNvbGUubG9nKCdzdHJlYW1oYW5kbGUnLCBzdHJlYW1oYW5kbGUpXG4gICAgICB0aGlzLmZpbGVzdHJlYW0gPSBmaWxlc3RyZWFtO1xuICAgICAgdGhpcy5zdHJlYW1oYW5kbGUgPSBzdHJlYW1oYW5kbGU7XG4gICAgICBsZXQgc2l6ZSA9IDA7XG4gICAgICB0aGlzLnBhcnQgPSAwO1xuICAgICAgdGhpcy5pbml0WmlwKCk7XG4gICAgICBjb25zb2xlXG4gICAgICBjb25zdCB6aXAgPSB0aGlzLnppcDtcbiAgICAgIGlmICghdGhpcy5qc1NjYW5EaXIpIHtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIEpzU2NhbkRpclxuICAgICAgICB9ID0gYXdhaXQgaW1wb3J0KCcuLi9maWxlcy9qcy1zY2FuZGlyLmpzJyk7XG4gICAgICAgIHRoaXMuanNTY2FuRGlyID0gbmV3IEpzU2NhbkRpcigpO1xuICAgICAgfVxuICAgICAgdGhpcy5qc1NjYW5EaXIucHJvY2Vzc0ZpbGUgPSAoZW50cnksIGNhbGxiYWNrKSA9PiB7XG4gICAgICAgIHRoaXMucHJvY2Vzc0ZpbGUoZW50cnksIGNhbGxiYWNrKTtcbiAgICAgIH07XG4gICAgICBhd2FpdCB0aGlzLmpzU2NhbkRpci5yZWFkRGlyZWN0b3J5KGRpciwgKCkgPT4ge1xuICAgICAgICB0aGlzLmVtaXQodGhpcy5ldmVudG5hbWVzLmNvbXBsZXRlLCB7XG4gICAgICAgICAgbmFtZTogdGhpcy5ldmVudG5hbWVzLmVuZHppcFxuICAgICAgICB9KTtcblxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIGFzeW5jIHNlbmRCaWdGaWxlKGZpbGUsIGNhbGxiYWNrLCBmaWxlcGF0aCkge1xuICAgIGNvbnNvbGUubG9nKCdzZW5kYmlnZmlsZXBhdGgnLCBmaWxlcGF0aClcbiAgICAvKmxldCBmaWxlcGF0aCA9IGZpbGUud2Via2l0UmVsYXRpdmVQYXRoO1xuICAgIGZpbGVwYXRoID0gKGZpbGVwYXRoID09PSAnJykgPyBkaXJuYW1lICsgJy8nICsgZmlsZS5uYW1lIDogZmlsZXBhdGg7Ki9cbiAgICBjb25zdCBleHQgPSBmaWxlLm5hbWUuc2xpY2UoZmlsZS5uYW1lLmxhc3RJbmRleE9mKCcuJykgKyAxKTtcbiAgICBpZiAoYWxyZWFkeV9jb21wcmVzc2VkLmhhcyhleHQpKSB7XG4gICAgICB0aGlzLmd6aXBwZWQgPSBmaWxlO1xuICAgICAgdGhpcy5lbWl0KHRoaXMuZXZlbnRuYW1lcy5jb3VudGVyLCB7XG4gICAgICAgIG5hbWU6ICd6aXAnLFxuICAgICAgICBmaWxlcGF0aDogZmlsZXBhdGgsXG4gICAgICAgIHNpemU6IGZpbGUuc2l6ZVxuICAgICAgfSk7XG4gICAgICB0aGlzLmVtaXQodGhpcy5ldmVudG5hbWVzLmNvbXBsZXRlLCB7XG4gICAgICAgIG5hbWU6IHRoaXMuZXZlbnRuYW1lcy5iaWdmaWxlLFxuICAgICAgICBiaWdmaWxlOiBmaWxlcGF0aFxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZW1pdCh0aGlzLmV2ZW50bmFtZXMuZ3ppcCwge1xuICAgICAgICBuYW1lOiB0aGlzLmV2ZW50bmFtZXMuZ3ppcCxcbiAgICAgICAgYmlnZmlsZTogZmlsZXBhdGgsXG4gICAgICAgIHNpemU6IGZpbGUuc2l6ZVxuICAgICAgfSk7XG4gICAgICBsZXQgemlwbmFtZSA9IGZpbGUubmFtZS5zcGxpdChleHQpO1xuICAgICAgemlwbmFtZS5wb3AoKTtcbiAgICAgIHppcG5hbWUgPSB6aXBuYW1lLmpvaW4oZXh0KSArICdneic7XG4gICAgICBjb25zb2xlLmxvZygnYmlnZmlsZSBleHQ9JyArIGV4dCwgemlwbmFtZSlcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgZmlsZXN0cmVhbSxcbiAgICAgICAgc3RyZWFtaGFuZGxlXG4gICAgICB9ID0gYXdhaXQgdGhpcy5jcmVhdGVMb2NhbFN0cmVhbSh6aXBuYW1lLCB7XG4gICAgICAgICdhcHBsaWNhdGlvbi9nemlwJzogWycuZ3onXSxcbiAgICAgIH0pO1xuICAgICAgbGV0IHBvcyA9IDA7XG4gICAgICBjb25zdCBzZWxmaSA9IHRoaXM7XG4gICAgICBjb25zdCBnemlwcGVkID0gbmV3IEd6aXAoe1xuICAgICAgICBsZXZlbDogOSxcbiAgICAgICAgZmlsZW5hbWU6IGZpbGUubmFtZVxuICAgICAgfSk7XG4gICAgICBnemlwcGVkLm9uZGF0YSA9IChkYXRhLCBmaW5hbCkgPT4ge1xuICAgICAgICBpZiAoZmluYWwpIHtcbiAgICAgICAgICBjb25zb2xlLmxvZygnZmluYWwgQklHRklMRSUlJSUlJSUlJSUlJSUlJSUlJSUlJyArIHNlbGZpLmV2ZW50bmFtZXMuYmlnZmlsZSwgZmlsZXBhdGgpXG4gICAgICAgICAgc2VsZmkuZW1pdChzZWxmaS5ldmVudG5hbWVzLmNvdW50ZXIsIHtcbiAgICAgICAgICAgIG5hbWU6ICd6aXAnLFxuICAgICAgICAgICAgZmlsZXBhdGg6IGZpbGVwYXRoLFxuICAgICAgICAgICAgc2l6ZTogZmlsZS5zaXplXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgc2VsZmkuZ3ppcHBlZCA9IHN0cmVhbWhhbmRsZTtcbiAgICAgICAgICBjb25zb2xlLmxvZygnYmlnIGZpbGUgKioqKioqKioqKioqKioqKioqKicsIHRoaXMuZ3ppcHBlZCk7XG4gICAgICAgICAgc2VsZmkuZW1pdChzZWxmaS5ldmVudG5hbWVzLmNvbXBsZXRlLCB7XG4gICAgICAgICAgICBuYW1lOiBzZWxmaS5ldmVudG5hbWVzLmJpZ2ZpbGUsXG4gICAgICAgICAgICBiaWdmaWxlOiBmaWxlcGF0aFxuXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBjb25zb2xlLmxvZygnY2FsbGJhY2tiaWcnLCBjYWxsYmFjaylcbiAgICAgICAgICAvLyAgZ3ppcHBlZC50ZXJtaW5hdGUoKTtcbiAgICAgICAgICAvLyAgc3RyZWFtaGFuZGxlLmNsb3NlKCk7XG5cblxuICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgc3RyZWFtaGFuZGxlLndyaXRlKGRhdGEsIHtcbiAgICAgICAgICAgIGF0OiBwb3NcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBwb3MgKz0gZGF0YS5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBhd2FpdCB0aGlzLnJlYWRGaWxlKGZpbGUsIGZpbGVwYXRoLCBnemlwcGVkLCBjYWxsYmFjayk7XG4gICAgfVxuXG5cbiAgfVxuICBhc3luYyBwYXJ0WmlwKCkge1xuICAgIHRoaXMucGFydCArPSAxO1xuICAgIHRoaXMuZW1pdCh0aGlzLmV2ZW50bmFtZXMuY29tcGxldGUsIHtcbiAgICAgIG5hbWU6IHRoaXMuZXZlbnRuYW1lcy5lbmR6aXAsXG4gICAgICBwYXJ0OiB0aGlzLnBhcnRcbiAgICB9KTtcbiAgfVxuICBhc3luYyByZWFkRmlsZShmaWxlLCBmaWxlcGF0aCwgemlwcGVkc3RyZWFtLCBjYWxsYmFjayA9IG51bGwpIHtcbiAgICBjb25zdCByZWFkZXIgPSBmaWxlLnN0cmVhbSgpLmdldFJlYWRlcigpO1xuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGRvbmUsXG4gICAgICAgIHZhbHVlXG4gICAgICB9ID0gYXdhaXQgcmVhZGVyLnJlYWQoKTtcbiAgICAgIGlmIChkb25lKSB7XG4gICAgICAgIHppcHBlZHN0cmVhbS5wdXNoKG5ldyBVaW50OEFycmF5KDApLCB0cnVlKTtcbiAgICAgICAgdGhpcy5lbWl0KHRoaXMuZXZlbnRuYW1lcy5jb3VudGVyLCB7XG4gICAgICAgICAgbmFtZTogJ3ppcCcsXG4gICAgICAgICAgZmlsZXBhdGg6IGZpbGVwYXRoLFxuICAgICAgICAgIHNpemU6ICh6aXBwZWRzdHJlYW0uc2l6ZSkgPyB6aXBwZWRzdHJlYW0uc2l6ZSA6IGZpbGUuc2l6ZVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHppcHBlZHN0cmVhbS50ZXJtaW5hdGUpIHppcHBlZHN0cmVhbS50ZXJtaW5hdGUoKTtcbiAgICAgICAgaWYgKGNhbGxiYWNrKSBjYWxsYmFjaygpO1xuICAgICAgICByZXR1cm4gZG9uZTtcbiAgICAgIH1cbiAgICAgIHppcHBlZHN0cmVhbS5wdXNoKHZhbHVlKTtcbiAgICB9XG4gIH1cbiAgYXN5bmMgemlwU3RyZWFtKGZpbGUsIGZpbGVwYXRoLCBjYWxsYmFjaykge1xuICAgIGNvbnN0IGV4dCA9IGZpbGVwYXRoLnNsaWNlKGZpbGVwYXRoLmxhc3RJbmRleE9mKCcuJykgKyAxKTtcbiAgICBjb25zdCBpc2NvbXByZXNzZWQgPSBhbHJlYWR5X2NvbXByZXNzZWQuaGFzKGV4dCk7XG4gICAgY29uc3QgemlwcGVkc3RyZWFtID0gKGlzY29tcHJlc3NlZCkgPyBuZXcgWmlwUGFzc1Rocm91Z2goZmlsZXBhdGgpIDogZmlsZS5zaXplID4gdGhpcy5vcHRpb25zLmxhcmdlZmlsZSA/XG4gICAgICBuZXcgQXN5bmNaaXBEZWZsYXRlKGZpbGVwYXRoLCB7XG4gICAgICAgIGxldmVsOiA5XG4gICAgICB9KSA6IG5ldyBaaXBEZWZsYXRlKGZpbGVwYXRoLCB7XG4gICAgICAgIGxldmVsOiA2XG4gICAgICB9KTtcbiAgICB0aGlzLnppcC5hZGQoemlwcGVkc3RyZWFtKTtcbiAgICBhd2FpdCB0aGlzLnJlYWRGaWxlKGZpbGUsIGZpbGVwYXRoLCB6aXBwZWRzdHJlYW0sIGNhbGxiYWNrKTtcbiAgfVxuICBhc3luYyBwcm9jZXNzRmlsZShlbnRyeSwgY2FsbGJhY2sgPSBudWxsKSB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgY29uc3QgZmlsZXBhdGggPSBlbnRyeS5mdWxsUGF0aDtcbiAgICBjb25zdCBleHQgPSBmaWxlcGF0aC5zbGljZShmaWxlcGF0aC5sYXN0SW5kZXhPZignLicpICsgMSk7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5hY2NlcHQuaW5jbHVkZXMoZXh0KSkge1xuICAgICAgY29uc29sZS5sb2coJ3JlamVjdCcsIGZpbGVwYXRoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGVudHJ5LmlzRGlyZWN0b3J5KSB7XG4gICAgICAvLyAgY29uc29sZS5sb2coJ3ppcGRpcicsIGNhbGxiYWNrKVxuICAgICAgaWYgKGNhbGxiYWNrKSBjYWxsYmFjaygpO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbnRyeS5maWxlKGFzeW5jIGZpbGUgPT4ge1xuICAgICAgICB0aGlzLmVtaXQodGhpcy5ldmVudG5hbWVzLmNvdW50ZXIsIHtcbiAgICAgICAgICBuYW1lOiAnc2NhbicsXG4gICAgICAgICAgZmlsZXBhdGg6IGZpbGVwYXRoLFxuICAgICAgICAgIHNpemU6IGZpbGUuc2l6ZVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5jb250aW51ZSA9IG51bGw7XG4gICAgICAgIC8vIGNoZWNrIGZpbGUgc2l6ZSA+IG1heCBwb3N0IHNpemVcbiAgICAgICAgaWYgKGZpbGUuc2l6ZSA+PSBNQVhTSVpFKSB7XG4gICAgICAgICAgdGhpcy5zZW5kQmlnRmlsZShmaWxlLCBjYWxsYmFjaywgZmlsZXBhdGgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIGNoZWNrIHppcCBmaWxlIHNpemUgPiB0b3RhbCB6aXAgc2l6ZVxuICAgICAgICAgIHRoaXMuc2l6ZXRvemlwICs9IGZpbGUuc2l6ZTtcbiAgICAgICAgICBpZiAodGhpcy5zaXpldG96aXAgPj0gTUFYU0laRSkge1xuICAgICAgICAgICAgdGhpcy5jb250aW51ZSA9IGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgYXdhaXQgdGhpcy56aXBTdHJlYW0oZmlsZSwgZmlsZXBhdGgsIGNhbGxiYWNrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMucGFydFppcCgpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLnppcFN0cmVhbShmaWxlLCBmaWxlcGF0aCwgY2FsbGJhY2spO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICB9XG4gIH1cbiAgb25FcnJvcigpIHtcbiAgICB0aGlzLmNsZWFuU3RvcmFnZSgpO1xuICAgIHRoaXMuZW1pdCh0aGlzLmV2ZW50bmFtZXMuZXJyb3IsIHtcbiAgICAgIG5hbWU6IFwicmVsb2FkXCJcbiAgICB9KTtcbiAgfVxuICBhc3luYyBjbGVhblN0b3JhZ2UoZW50cnkgPSBudWxsKSB7XG4gICAgZW50cnkgPSAoZW50cnkpID8gZW50cnkgOiBhd2FpdCBuYXZpZ2F0b3Iuc3RvcmFnZS5nZXREaXJlY3RvcnkoKTtcbiAgICBmb3IgYXdhaXQgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBlbnRyeS5lbnRyaWVzKCkpIHtcbiAgICAgIGNvbnNvbGUubG9nKCdrZXl2YWwnLCB7XG4gICAgICAgIGtleSxcbiAgICAgICAgdmFsdWVcbiAgICAgIH0pO1xuICAgICAgYXdhaXQgZW50cnkucmVtb3ZlRW50cnkoa2V5KTtcbiAgICB9XG5cbiAgfVxuXG4gIGFzeW5jIGVuZEZldGNoKG1lc3NhZ2UsIGNsZWFuID0gZmFsc2UpIHtcbiAgICBtZXNzYWdlLm5hbWUgPSB0aGlzLmV2ZW50bmFtZXMudGVybWluYXRlO1xuICAgIGlmIChtZXNzYWdlLmhhc093blByb3BlcnR5KFwiYmlnZmlsZVwiKSAmJiBtZXNzYWdlLmJpZ2ZpbGUgIT09IFwiXCIgJiZcbiAgICAgIG1lc3NhZ2UuYmlnZmlsZSAhPT0gZmFsc2UgJiYgbWVzc2FnZS5iaWdmaWxlICE9PSBudWxsKSB7XG4gICAgICBtZXNzYWdlW1wiYmlnZmlsZVwiXSA9IHRoaXMuZ3ppcHBlZC5uYW1lO1xuICAgICAgdGhpcy5nemlwcGVkID0gbnVsbDtcbiAgICB9IGVsc2UgaWYgKHRoaXMuY29udGludWUpIHtcbiAgICAgIGNvbnNvbGUubG9nKCdjb250aW51ZScpXG4gICAgICB0aGlzLnN0cmVhbWhhbmRsZSA9IGF3YWl0IHRoaXMuZmlsZXN0cmVhbS5jcmVhdGVXcml0YWJsZSgpO1xuICAgICAgdGhpcy5pbml0WmlwKCk7XG4gICAgfSBlbHNlIGlmIChjbGVhbiA9PT0gdHJ1ZSkgYXdhaXQgdGhpcy5jbGVhblN0b3JhZ2UoKTtcbiAgICB0aGlzLmVtaXQodGhpcy5ldmVudG5hbWVzLmNvbXBsZXRlLCBtZXNzYWdlKTtcbiAgICBjb25zb2xlLmxvZygnY29udGludWUnLCB0aGlzLmNvbnRpbnVlKVxuICB9XG5cbiAgYXN5bmMgc2VuZENodW5rKHBhdGgsIHN0YXJ0ID0gMCwgY2h1bmtudW0gPSAwLCBjaHVua3NpemUgPSBNQVhTSVpFKSB7XG4gICAgY29uc3QgZmlsZSA9ICh0aGlzLmd6aXBwZWQua2luZCkgPyBhd2FpdCB0aGlzLmd6aXBwZWQuZ2V0RmlsZSgpOiBmaWxlO1xuICAgIHBhdGggPSBwYXRoLnNwbGl0KCcvJyk7XG4gICAgcGF0aC5wb3AoKTtcbiAgICBwYXRoID0gcGF0aC5qb2luKCcvJyk7XG4gICAgY29uc3QgZW5kID0gTWF0aC5taW4oc3RhcnQgKyBjaHVua3NpemUsIGZpbGUuc2l6ZSk7XG4gICAgaWYgKGVuZCA9PT0gZmlsZS5zaXplKSB7XG5cbiAgICAgIHRoaXMuc2VuZFppcEZpbGUoZmlsZSwgcGF0aCwgbnVsbCwgdHJ1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHBhcnRmaWxlID0gZmlsZS5zbGljZShzdGFydCwgZW5kKTtcbiAgICAgIHBhcnRmaWxlLm5hbWUgPSBjaHVua251bSArICdfJyArIGZpbGUubmFtZTtcbiAgICAgIHRoaXMuc2VuZFppcGZpbGUocGFydGZpbGUsIHBhdGgsICgpID0+IHtcbiAgICAgICAgc3RhcnQgKz0gZW5kO1xuICAgICAgICBjaHVua251bSsrO1xuXG4gICAgICAgIGlmIChzdGFydCA8PSBmaWxlLnNpemUpIHRoaXMuc2VuZENodW5rKHBhdGgsIHN0YXJ0LCBjaHVua251bSwgY2h1bmtzaXplKTtcbiAgICAgIH0sIHRydWUpXG4gICAgfVxuICAgIHJldHVybiBjaHVua251bTtcbiAgfVxuICBhc3luYyBnZXRGaWxlKCkge1xuICAgIGNvbnN0IGZpbGUgPSBhd2FpdCB0aGlzLmZpbGVzdHJlYW0uZ2V0RmlsZSgpO1xuICAgIHJldHVybiBmaWxlO1xuICB9XG4gIGFzeW5jIHNlbmRaaXBGaWxlKGZpbGUsIHBhdGgsIGNhbGxiYWNrY2h1bmsgPSBudWxsLCBpc2JpZ2ZpbGUgPSBmYWxzZSkge1xuICAgIGNvbnN0IG1lc3NhZ2UgPSAoaXNiaWdmaWxlKSA/IHtcbiAgICAgIGJpZ2ZpbGU6IGZpbGUubmFtZVxuICAgIH0gOiB7fTtcbiAgICB0aGlzLmVtaXQodGhpcy5ldmVudG5hbWVzLnBlbmRpbmcsIG1lc3NhZ2UpO1xuICAgIGNvbnNvbGUubG9nKCdmaWxlJywgZmlsZSlcbiAgICBjb25zb2xlLmxvZygnY2FsbGJhY2tjaHVuay0tLXNlbmR6aXAnLCBjYWxsYmFja2NodW5rKVxuICAgIGNvbnN0IGZvcm1kYXRhID0gbmV3IEZvcm1EYXRhKCk7XG4gICAgZm9ybWRhdGEuYXBwZW5kKCd0YWcnLCAnZWNvdGF4YV9pbXBvcnQnKTtcbiAgICBmb3JtZGF0YS5hcHBlbmQoJ3BhdGgnLCBwYXRoICsgZmlsZS5uYW1lKTtcbiAgICBmb3JtZGF0YS5hcHBlbmQoJ2ZpbGUnLCBmaWxlLCBmaWxlLm5hbWUpO1xuICAgIGlmICh0aGlzLnBhcnQpIGZvcm1kYXRhLmFwcGVuZCgncGFydCcsIHRoaXMucGFydCk7XG4gICAgZWxzZSBpZiAoY2FsbGJhY2tjaHVuayAhPT0gbnVsbCkgZm9ybWRhdGEuYXBwZW5kKCdpc2NodW5rJywgdHJ1ZSk7XG4gICAgZmV0Y2godGhpcy5vcHRpb25zLnVwbG9hZHVybCwge1xuICAgICAgLy8gIG1vZGU6ICdjb3JzJyxcbiAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICBjcmVkZW50aWFsczogXCJpbmNsdWRlXCIsXG4gICAgICBib2R5OiBmb3JtZGF0YSxcbiAgICB9KS50aGVuKGFzeW5jIChyZXNwb25zZSkgPT4ge1xuICAgICAgY29uc29sZS5sb2coJ3Jlc3BvbnNlLS0tLS0tLS0tLS0tLS0tLS0tLS0tLScsIHJlc3BvbnNlKTtcbiAgICAgIGNvbnNvbGUubG9nKCdjYWxsYmFja2NodW5rLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLScsIGNhbGxiYWNrY2h1bmspXG4gICAgICBpZiAoY2FsbGJhY2tjaHVuayAhPT0gbnVsbCkge1xuICAgICAgICBjYWxsYmFja2NodW5rKCk7XG4gICAgICB9IGVsc2UgdGhpcy5lbmRGZXRjaChtZXNzYWdlKTtcbiAgICB9KTtcbiAgfVxufSJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/modules/files/js-dirtozip.js\n")}}]);